"""
golf_ball_carry.py
===================

This module provides a simple physics‑based model for predicting the carry
distance of a golf ball.  It implements a three‑dimensional trajectory
simulation that accounts for gravity, aerodynamic drag and lift (Magnus effect)
generated by backspin and tilted spin axes.  The implementation draws on
published research into golf ball aerodynamics:

* **Lift coefficient (Cₗ)** – The lift coefficient is estimated from the
  dimensionless spin ratio α = (R ω)/v, where R is the ball radius, ω is the
  angular velocity in radians per second and v is the instantaneous speed.  A
  widely cited formula, derived from experimental data, expresses the lift
  coefficient as 【801144601150337†L90-L143】:

      Cₗ(α) = -0.05 + sqrt(0.0025 + 0.36·α)

  This relationship captures how increasing spin generates more lift.  The
  formula assumes SI units for R, ω and v (metres, radians per second and
  metres per second).

* **Drag coefficient (Cᴅ)** – Experiments show that the drag coefficient of
  dimpled golf balls varies with Reynolds number and ball surface geometry.  A
  wind‑tunnel study of commercial balls reported that at high Reynolds numbers
  (~8×10⁴) the drag coefficient averaged about 0.275 with small variation【737997149505570†L128-L140】.
  However, drag can exceed 0.5 at lower speeds【595464058294330†L681-L739】.  In
  most golf simulators a constant drag coefficient in the range 0.21–0.25 is
  employed for simplicity【315782886486652†L169-L175】.  The default value used in this
  implementation is 0.25.  A constant drag coefficient produces credible
  carry distances for driver‑like shots; advanced users can supply a custom
  function if required.

* **Spin axis and side spin** – Total spin (in rpm) measured by launch
  monitors is usually resolved into back spin and side spin components.  If
  the spin axis is tilted by an angle θ from horizontal, side spin and back
  spin can be approximated by

      back_spin  = total_spin × cos(θ)
      side_spin  = total_spin × sin(θ)

  These relations, derived from trigonometry, follow from the fact that the
  total spin vector has magnitude equal to the total spin and is tilted away
  from horizontal.  Golf forums and launch monitor documentation report this
  approximation【530180740351578†L363-L367】.

The coordinate system used here is right‑handed:

* The **x‑axis** points toward the target (down range).
* The **y‑axis** points to the player’s right when standing behind the ball.
* The **z‑axis** points upward.

The initial velocity vector is constructed from the ball speed, vertical launch
angle and horizontal launch angle.  Positive horizontal angles correspond to
shots started right of the target, negative values start left of the target.

The spin axis orientation is modelled as a unit vector tilted about the x‑axis
by the spin axis angle.  A positive spin axis corresponds to a draw/hook for
a right‑handed golfer (curve to the left).  This orientation is chosen so
that the cross product of the spin axis and velocity vector produces an
upward Magnus force for zero spin axis and a combination of up and left for
positive angles.

Example usage:

    from golf_ball_carry import simulate_carry

    result = simulate_carry(
        ball_speed=70.0,
        launch_angle_deg=12.0,
        azimuth_deg=0.0,
        total_spin_rpm=2500.0,
        spin_axis_deg=0.0,
    )
    print(f"Carry distance: {result['carry_distance']:.1f} m")

This will compute the carry distance for a driver shot launched at 70 m/s with
12° vertical launch angle and 2500 rpm backspin.

Note: The model neglects spin decay and uses a constant drag coefficient,
which is adequate for quick estimates.  For a more detailed trajectory,
consider introducing spin decay and a Reynolds‑number dependent drag model.
"""

import math
from typing import Callable, Dict

import numpy as np
from scipy.integrate import solve_ivp


def _lift_coefficient(radius: float, omega: float, v: float) -> float:
    """Return the lift coefficient based on spin ratio.

    Uses the empirical relation C_l = -0.05 + sqrt(0.0025 + 0.36 * alpha),
    where alpha = R*omega/v and omega is the angular speed in rad/s.  The
    formula is valid for spinning sports balls when units are SI.

    Parameters
    ----------
    radius : float
        Radius of the ball in metres.
    omega : float
        Angular speed (magnitude) in rad/s.
    v : float
        Instantaneous translational speed in m/s.

    Returns
    -------
    float
        Lift coefficient C_l.
    """
    if v <= 1e-8:
        return 0.0
    alpha = (radius * omega) / v
    # The empirical formula should not produce negative values.  Clip alpha to
    # avoid complex values under the square root when v is extremely large.
    return max(-0.05 + math.sqrt(max(0.0, 0.0025 + 0.36 * alpha)), 0.0)


def _default_drag_coefficient(v: float) -> float:
    """Default constant drag coefficient.

    Although the drag coefficient of a golf ball varies with Reynolds
    number and spin, simulations often assume a constant value around
    0.21–0.25【315782886486652†L169-L175】.  A wind‑tunnel study of commercial balls
    measured an average C_d ≈ 0.275 at high Reynolds numbers【737997149505570†L128-L140】.
    The default used here is 0.25.  Users may provide a custom function
    returning C_d(v) to capture more complicated behaviour.

    Parameters
    ----------
    v : float
        Instantaneous translational speed in m/s (unused in constant model).

    Returns
    -------
    float
        Drag coefficient C_d.
    """
    return 0.25


def simulate_carry(
    *,
    ball_speed: float,
    launch_angle_deg: float,
    azimuth_deg: float,
    total_spin_rpm: float,
    spin_axis_deg: float,
    mass: float = 0.04593,
    radius: float = 0.021335,
    air_density: float = 1.225,
    g: float = 9.81,
    drag_coefficient: Callable[[float], float] = _default_drag_coefficient,
    lift_coefficient: Callable[[float, float, float], float] = _lift_coefficient,
    max_time: float = 10.0,
    dt: float = 0.001,
) -> Dict[str, float]:
    """Simulate the flight of a golf ball and return carry distance and related metrics.

    The function numerically integrates the equations of motion for a spinning
    golf ball, including gravity, aerodynamic drag and lift (Magnus effect).

    Parameters
    ----------
    ball_speed : float
        Launch speed of the ball in m/s.
    launch_angle_deg : float
        Vertical launch angle above the horizontal in degrees.
    azimuth_deg : float
        Horizontal launch angle in degrees; positive values start right of the
        target, negative values start left.
    total_spin_rpm : float
        Magnitude of total spin in revolutions per minute.
    spin_axis_deg : float
        Tilt of the spin axis in degrees.  Positive values tilt the axis
        towards the player’s right–left axis such that the ball curves left
        (draw/hook) for a right‑handed golfer【530180740351578†L363-L367】.
    mass : float, optional
        Mass of the golf ball in kilograms.  Default is 45.93 g (USGA limit).
    radius : float, optional
        Radius of the golf ball in metres.  Default corresponds to a 42.67 mm
        diameter ball.
    air_density : float, optional
        Density of air in kg/m³.  Default is sea‑level standard (approx. 1.225).
    g : float, optional
        Gravitational acceleration in m/s².  Default is 9.81.
    drag_coefficient : callable, optional
        Function returning the drag coefficient C_d(v).  Defaults to a constant
        0.25【315782886486652†L169-L175】.  A custom function may incorporate Reynolds number
        effects.
    lift_coefficient : callable, optional
        Function returning the lift coefficient C_l(radius, omega, v).  Defaults
        to the empirical relation【801144601150337†L90-L143】.
    max_time : float, optional
        Maximum simulation time in seconds.  Integration terminates when the
        vertical position falls below zero or when this time is reached.
    dt : float, optional
        Suggested time step (in seconds) for the ODE solver.  It determines the
        maximum step size used by the integrator.  Smaller values improve
        accuracy at the cost of performance.

    Returns
    -------
    dict
        A dictionary containing:
        - ``carry_distance``: horizontal distance along the x‑axis at first
          ground impact (metres).
        - ``lateral_displacement``: y‑coordinate at ground impact (metres).
        - ``flight_time``: time until impact (seconds).
        - ``apex_height``: maximum height reached during flight (metres).
        - ``back_spin``: back spin component in rpm.
        - ``side_spin``: side spin component in rpm.

    Raises
    ------
    ValueError
        If the initial launch speed is non‑positive or the mass or radius are
        non‑positive.
    """
    # Validate inputs
    if ball_speed <= 0:
        raise ValueError("ball_speed must be positive")
    if mass <= 0 or radius <= 0:
        raise ValueError("mass and radius must be positive")

    # Convert angles and spin to SI units
    theta_v = math.radians(launch_angle_deg)
    phi_h = math.radians(azimuth_deg)
    # Angular velocity magnitude in rad/s
    omega = total_spin_rpm * 2.0 * math.pi / 60.0
    # Spin axis tilt
    spin_tilt = math.radians(spin_axis_deg)
    # Unit vector along spin axis rotated about the x‑axis.  The base axis
    # pointing along negative y gives backspin when spin_tilt=0.
    n = np.array([0.0, -math.cos(spin_tilt), -math.sin(spin_tilt)])
    # Normalise the spin axis unit vector (should already be unit length)
    n /= np.linalg.norm(n)

    # Convert total spin into back spin and side spin components (for output only)
    back_spin_rpm = total_spin_rpm * math.cos(spin_tilt)
    side_spin_rpm = total_spin_rpm * math.sin(spin_tilt)

    # Initial velocity vector in Cartesian coordinates
    v0 = np.array([
        ball_speed * math.cos(theta_v) * math.cos(phi_h),  # x
        ball_speed * math.cos(theta_v) * math.sin(phi_h),  # y
        ball_speed * math.sin(theta_v),                    # z
    ])
    # Initial state: position (x,y,z) and velocity (vx,vy,vz)
    y0 = np.hstack((np.array([0.0, 0.0, 0.0]), v0))

    # Cross sectional area
    A = math.pi * radius ** 2

    # Event function to stop integration when z crosses zero on downward motion
    def hit_ground_event(t, y):
        # Event is triggered when z=0 descending
        # y[2] is z coordinate, y[5] is vz velocity
        return y[2]
    hit_ground_event.terminal = True  # Stop integration
    hit_ground_event.direction = -1   # Only detect when z decreases through zero

    # Precompute constants
    rho_half_A_over_m = 0.5 * air_density * A / mass

    # Define the derivative function for ODE solver
    def derivatives(t, y):
        # Unpack state
        px, py, pz, vx, vy, vz = y
        v = np.array([vx, vy, vz])
        speed = np.linalg.norm(v)
        # If speed is tiny, avoid division by zero
        if speed < 1e-8:
            drag_force = np.array([0.0, 0.0, 0.0])
            lift_force = np.array([0.0, 0.0, 0.0])
        else:
            # Compute drag force
            Cd = drag_coefficient(speed)
            drag_force = -rho_half_A_over_m * Cd * speed * v  # = -(1/2 ρ A/m)*Cd*speed*v
            # Compute lift coefficient
            Cl = lift_coefficient(radius, omega, speed)
            # Direction of lift is perpendicular to both spin axis and velocity
            # Use cross product of spin axis unit vector and unit velocity
            v_hat = v / speed
            lift_dir = np.cross(n, v_hat)
            # Normalise lift direction to unit vector (could be near zero)
            lift_norm = np.linalg.norm(lift_dir)
            if lift_norm > 1e-8:
                lift_dir /= lift_norm
                lift_force = rho_half_A_over_m * Cl * speed**2 * lift_dir
            else:
                lift_force = np.array([0.0, 0.0, 0.0])
        # Gravitational acceleration
        accel_gravity = np.array([0.0, 0.0, -g])
        # Total acceleration
        accel = drag_force + lift_force + accel_gravity
        return np.hstack((v, accel))

    # Solve the ODE
    # Use a maximum step equal to dt to improve accuracy
    sol = solve_ivp(
        derivatives,
        t_span=(0.0, max_time),
        y0=y0,
        method="RK45",
        max_step=dt,
        events=hit_ground_event,
        rtol=1e-6,
        atol=1e-9,
    )

    # Extract the solution at impact (last point)
    if sol.t_events[0].size > 0:
        t_impact = sol.t_events[0][0]
        y_impact = sol.y_events[0][0]
    else:
        # Did not hit ground within max_time; use final state
        t_impact = sol.t[-1]
        y_impact = sol.y[:, -1]

    # Horizontal (carry) distance is x coordinate at impact
    carry_distance = y_impact[0]
    lateral_displacement = y_impact[1]

    # Maximum height achieved during flight
    apex_height = np.max(sol.y[2])

    return {
        "carry_distance": carry_distance,
        "lateral_displacement": lateral_displacement,
        "flight_time": t_impact,
        "apex_height": apex_height,
        "back_spin": back_spin_rpm,
        "side_spin": side_spin_rpm,
    }


__all__ = ["simulate_carry"]
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Par 3 Golf Hole</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #87CEEB;
        }

        #canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 13px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin: 4px 0;
            font-size: 13px;
            transition: all 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        /* Top-left player info */
        #playerInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 2px solid #4ade80;
            min-width: 200px;
        }

        #playerInfo .player-name {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        #playerInfo .shot-info {
            font-size: 14px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        #playerInfo .shot-number {
            color: #fff;
            font-weight: bold;
        }

        /* Floating yardage marker */
        #yardageMarker {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            border: 2px solid #FFD700;
            pointer-events: none;
            text-align: center;
            min-width: 60px;
            max-width: 60px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        #yardageMarker .yards-label {
            font-size: 8px;
            color: #FFD700;
            margin-top: 0px;
            line-height: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Top-left player info -->
    <div id="playerInfo">
        <div class="player-name" id="topPlayerName">Player 1</div>
        <div class="shot-info">
            <div>Shot: <span class="shot-number" id="shotNumber">1</span></div>
            <div>Strokes: <span class="shot-number" id="strokeCount">0</span></div>
        </div>
    </div>

    <!-- Floating yardage marker -->
    <div id="yardageMarker">
        <div id="yardageValue">130</div>
        <div class="yards-label">YARDS</div>
    </div>

    <div id="controls">
        <h3 id="holeTitle">‚õ≥ Golf Course - Hole 1</h3>

        <div class="stat-section" id="shotDetails" style="display: none;">
            <h3 style="font-size: 14px; margin: 0 0 8px 0; color: #FFD700;">Last Shot</h3>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="shotSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">VLA:</span>
                <span class="stat-value" id="shotVLA">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">HLA:</span>
                <span class="stat-value" id="shotHLA">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Spin:</span>
                <span class="stat-value" id="shotSpin">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Spin Axis:</span>
                <span class="stat-value" id="shotSpinAxis">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Carry:</span>
                <span class="stat-value" id="shotCarry">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Roll:</span>
                <span class="stat-value" id="shotRoll">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total:</span>
                <span class="stat-value" id="shotTotal">--</span>
            </div>
        </div>

        <button id="viewBtn">Change View</button>
        <button id="gridBtn">Toggle Grid</button>
        <button id="resetBtn">Reset Hole</button>
        <button onclick="exportSessionCSV()" style="background: rgba(34, 197, 94, 0.3); border-color: #22c55e;">Export CSV</button>

        <!-- Demo Shot Controls (for testing) - DISABLED FOR RELEASE -->
        <div id="demoShotPanel" style="display: none; position: absolute; top: 250px; right: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; color: white; font-family: Arial; z-index: 100;">
            <h3 style="margin-top: 0;">Demo Shot (Press 'D')</h3>
            <div style="display: grid; gap: 8px;">
                <label>Ball Speed (mph): <input type="number" id="demoSpeed" value="55" step="1" style="width: 80px;"></label>
                <label>Launch V (deg): <input type="number" id="demoVLA" value="5" step="0.5" style="width: 80px;"></label>
                <label>Launch H (deg): <input type="number" id="demoHLA" value="0" step="0.5" style="width: 80px;"></label>
                <label>Total Spin (rpm): <input type="number" id="demoTotalSpin" value="1200" step="100" style="width: 80px;"></label>
                <label>Spin Axis (deg): <input type="number" id="demoSpinAxis" value="0" step="1" style="width: 80px;"></label>
            </div>
            <button id="fireDemoShot" style="width: 100%; margin-top: 10px; padding: 8px; background: rgba(76, 175, 80, 0.3); border: 2px solid #4CAF50; color: white; cursor: pointer; border-radius: 4px; font-size: 14px; font-weight: bold;">üèåÔ∏è Fire Shot (D)</button>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                <div style="font-size: 11px; font-weight: bold; margin-bottom: 5px;">Quick Presets:</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 10px;">
                    <button onclick="document.getElementById('demoSpeed').value=55; document.getElementById('demoVLA').value=12; document.getElementById('demoTotalSpin').value=3000;" style="padding: 4px; background: rgba(100,100,100,0.5); border: 1px solid #666; color: white; cursor: pointer; border-radius: 3px;">Wedge</button>
                    <button onclick="document.getElementById('demoSpeed').value=90; document.getElementById('demoVLA').value=15; document.getElementById('demoTotalSpin').value=3500;" style="padding: 4px; background: rgba(100,100,100,0.5); border: 1px solid #666; color: white; cursor: pointer; border-radius: 3px;">7-Iron</button>
                    <button onclick="document.getElementById('demoSpeed').value=120; document.getElementById('demoVLA').value=14; document.getElementById('demoTotalSpin').value=3000;" style="padding: 4px; background: rgba(100,100,100,0.5); border: 1px solid #666; color: white; cursor: pointer; border-radius: 3px;">5-Iron</button>
                    <button onclick="document.getElementById('demoSpeed').value=150; document.getElementById('demoVLA').value=12; document.getElementById('demoTotalSpin').value=2500;" style="padding: 4px; background: rgba(100,100,100,0.5); border: 1px solid #666; color: white; cursor: pointer; border-radius: 3px;">Driver</button>
                </div>
            </div>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3); font-size: 12px;">
                <strong>Press 'D'</strong> to fire test shot<br>
                <strong>Press 'F'</strong> to toggle free camera (WASD/QE to move)
            </div>
        </div>
    </div>

    <!-- Shot Classification Panel -->
    <div id="shotClassification" style="position: absolute; top: 120px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; color: white; font-family: Arial; display: none; z-index: 100; border: 2px solid rgba(255,255,255,0.3); min-width: 280px;">
        <h3 style="margin-top: 0; font-size: 16px;">üéØ Shot Analysis</h3>
        <div id="shotNameDisplay" style="font-size: 24px; font-weight: bold; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
            <!-- Shot name goes here -->
        </div>
        <div id="shotRankBadge" style="display: inline-block; padding: 8px 16px; border-radius: 6px; font-size: 20px; font-weight: bold; margin: 10px 0;">
            <!-- Rank badge goes here -->
        </div>
        <div style="font-size: 12px; opacity: 0.9; margin-top: 10px; line-height: 1.6;">
            <div><strong>Carry:</strong> <span id="carryValue">0</span> yds ‚Ä¢ <strong>Total:</strong> <span id="totalValue">0</span> yds</div>
            <div><strong>Peak Height:</strong> <span id="peakHeightValue">0</span> yds</div>
            <div><strong>Hang Time:</strong> <span id="hangTimeValue">0</span>s</div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);">
                <div><strong>Backspin:</strong> <span id="backspinValue">0</span> RPM</div>
                <div><strong>Sidespin:</strong> <span id="sidespinValue">0</span> RPM</div>
            </div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);">
                <div><strong>Smash Factor:</strong> <span id="smashFactorValue">0</span></div>
                <div><strong>Efficiency:</strong> <span id="efficiencyValue">0</span>%</div>
            </div>
        </div>
    </div>

    <!-- Minimap (re-enabled) -->
    <canvas id="minimap" width="200" height="200" style="position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; z-index: 1000;"></canvas>

    <!-- Draft Golf Overlay -->
    <div id="draftGolfOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:2000;">
      <div id="draftPanel" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
           background:#1a1a2e; border:3px solid #4ade80; border-radius:16px; padding:24px; min-width:700px;">
        <h2 id="draftTitle" style="color:#4ade80; text-align:center; margin-bottom:16px;">DRAFT PHASE</h2>
        <div id="draftCurrentPicker" style="text-align:center; font-size:18px; margin-bottom:20px; color:white;"></div>
        <div id="draftBallCards" style="display:grid; grid-template-columns:repeat(2,1fr); gap:16px;"></div>
        <div id="draftOrder" style="text-align:center; margin-top:16px; color:#888; font-size:14px;"></div>
      </div>
    </div>

    <!-- Draft Golf Status Bar -->
    <div id="draftGolfStatus" style="display:none; position:fixed; top:10px; left:50%; transform:translateX(-50%);
         background:rgba(0,0,0,0.8); border:2px solid #4ade80; border-radius:8px; padding:8px 16px; z-index:1500; color:white;">
      <span id="draftStatusText">Draft Golf: Waiting for shots...</span>
    </div>

    <script src="./three.min.js"></script>
    <script src="./steam-network-adapter.js"></script>
    <script type="module">
        // Import OpenGolfCoach for shot classification
        import init, { calculate_derived_values } from './opengolfcoach.js';

        // Initialize WASM module
        let openGolfCoachReady = false;
        init().then(() => {
            openGolfCoachReady = true;
            window.classifyShot = function(shotData) {
                console.log('üîß classifyShot called with:', shotData);

                if (!openGolfCoachReady) {
                    console.error('‚ùå OpenGolfCoach not ready!');
                    return null;
                }

                try {
                    // Convert to OpenGolfCoach format
                    const input = {
                        ball_speed_meters_per_second: shotData.speed * 0.44704, // mph to m/s
                        vertical_launch_angle_degrees: shotData.vla,
                        horizontal_launch_angle_degrees: shotData.hla || 0,
                        total_spin_rpm: shotData.total_spin || 0,
                        spin_axis_degrees: shotData.spin_axis || 0
                    };

                    console.log('üì§ Sending to OpenGolfCoach:', input);

                    // Call OpenGolfCoach
                    const resultJson = calculate_derived_values(JSON.stringify(input));
                    console.log('üì• Raw result from WASM:', resultJson);

                    const result = JSON.parse(resultJson);
                    console.log('üéØ Parsed OpenGolfCoach result:', result);

                    // Extract from nested open_golf_coach object
                    const ogc = result.open_golf_coach;

                    return {
                        shotName: ogc.shot_name || 'Unknown',
                        shotRank: ogc.shot_rank || 'C',
                        shotColor: ogc.shot_color_rgb || '0xFFFFFF',
                        carryYards: ogc.carry_distance_meters * 1.09361,
                        totalYards: ogc.total_distance_meters * 1.09361,
                        offlineYards: ogc.offline_distance_meters * 1.09361,
                        peakHeight: ogc.peak_height_meters * 1.09361,
                        hangTime: ogc.hang_time_seconds,
                        backspin: ogc.backspin_rpm || 0,
                        sidespin: ogc.sidespin_rpm || 0,
                        smashFactor: ogc.smash_factor || 0,
                        efficiency: ogc.distance_efficiency_percent || 0,
                        descentAngle: ogc.descent_angle_degrees || 0
                    };
                } catch (err) {
                    console.error('‚ùå OpenGolfCoach error:', err);
                    console.error('Error stack:', err.stack);
                    return null;
                }
            };

            console.log('‚úÖ OpenGolfCoach WASM module loaded and ready!');
        }).catch(err => {
            console.error('Failed to load OpenGolfCoach:', err);
        });
    </script>
    <script>
        let scene, camera, renderer;
        let minimapCamera, minimapRenderer;
        let ball, hole;
        let teebox, green, bunker;
        let ballInFlight = false;

        // Steam Multiplayer
        let networkAdapter = null;
        let isNetworkGame = false;
        let isNetworkHost = false;
        let localSteamId = null;

        // Textures
        let fairwayTexture, roughTexture, sandTexture, dirtTexture;
        let strokes = 0;

        // Players - each player tracks their own ball position and strokes
        window.golfPar3Players = [];
        window.currentPlayerIndex = 0;

        // Session tracking for CSV export
        let sessionShots = [];
        let currentShotData = {}; // Store current shot's data for CSV export

        // Ball state (for current player)
        let ballPosition = new THREE.Vector3();
        let ballVelocity = new THREE.Vector3();
        let ballSpin = { totalSpin: 0, spinAxis: 0 }; // totalSpin in rpm, spinAxis in degrees
        let isPutting = false; // Track if current shot is a putt

        // Game settings (set by Electron)
        let gimmieCirclesEnabled = false;
        let ballStoppedTime = null; // Track when ball stopped moving
        const GIMME_DELAY_MS = 300; // Wait 300ms after ball stops before checking gimme

        // Course layout (in meters, 1 yard = 0.9144 meters)
        const TEE_POSITION = new THREE.Vector3(0, 3, 0); // Elevated 3m
        // Hole configurations
        const COURSES = {
            shanktuary: {
                name: 'Shanktuary Hills Golf Club',
                holes: [
                    {
                        number: 1,
                        par: 3,
                        distance: 150, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -118.872), // 130 yards = 118.872m
                        type: 'straight',
                        greenSlope: { direction: 180, percent: 2 } // Slope toward player (downhill putt)
                    },
                    {
                        number: 2,
                        par: 4,
                        distance: 320, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(-220, 0, -220), // Dogleg left - 285 yards to fairway corner, ~320 total
                        type: 'dogleg-left',
                        greenSlope: { direction: 270, percent: 1.5 } // Slope to the left (side slope)
                    },
                    {
                        number: 3,
                        par: 4,
                        distance: 250, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -228.6), // Island 3 center - 250 yards = 228.6m
                        type: 'island-hopping',
                        islands: [
                            { center: new THREE.Vector3(0, 0, 0), radius: 45.72 },      // Island 1 (Tee) - 100yd diameter
                            { center: new THREE.Vector3(0, 0, -114.3), radius: 45.72 }, // Island 2 (Fairway) - 125yd from tee
                            { center: new THREE.Vector3(0, 0, -228.6), radius: 45.72 }  // Island 3 (Green) - 250yd from tee
                        ],
                        greenSlope: { direction: 90, percent: 2.5 } // Slope to the right (challenging side slope)
                    },
                    {
                        number: 4,
                        par: 4,
                        distance: 395, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(30, 0, -310), // Moved closer - 395 yards = 361m
                        type: 'dogleg-right',
                        greenShape: 'oval', // Oval/elliptical green
                        greenSlope: { direction: 0, percent: 2 } // Slope away from player (uphill putt)
                    },
                    {
                        number: 5,
                        par: 5,
                        distance: 494, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(-18, 0, -451.714), // 494 yards = 451.7m
                        type: 'long-par5',
                        name: 'Pine Passage',
                        greenShape: 'oval',
                        splitYards: 200,
                        fairwayHalfWidth: 18,
                        roughHalfWidth: 36,
                        leftPathShift: -18,
                        leftPathTurnStart: 0.1,
                        leftPathTurnEnd: 0.6,
                        leftPathHalfWidth: 12,
                        rightPathShift: 45,
                        rightPathTurnStart: 0.05,
                        rightPathTurnEnd: 0.75,
                        rightPathHalfWidth: 22,
                        leftClearing: { x: -30, z: -185, radiusX: 12, radiusZ: 18 },
                        greenSlope: { direction: 0, percent: 2 } // Uphill green
                    }
                ]
            },
            rockwiga: {
                name: 'Rockwiga Country Club',
                holes: [
                    {
                        number: 1,
                        par: 4,
                        distance: 400, // yards
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(120, 0, -345), // ~400 yards to green
                        type: 'rockwiga',
                        name: 'Opening Run',
                        fairwayHalfWidth: 22,
                        roughHalfWidth: 42,
                        landingZoneYards: 220,
                        landingZoneRadius: 32, // meters
                        landingZoneBoost: 6,
                        treeLineOffset: 34,
                        treePairCount: 18,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 360, length: 720, segmentsW: 180, segmentsL: 260 },
                        obDistance: 70,
                        waterPolygons: [
                            [
                                {x: 28, z: -40},
                                {x: 52, z: -46},
                                {x: 72, z: -70},
                                {x: 68, z: -102},
                                {x: 48, z: -118},
                                {x: 30, z: -96},
                                {x: 26, z: -68}
                            ]
                        ],
                        bunkers: [],
                        greenSlope: { direction: 0, percent: 1.5 }
                    },
                    {
                        number: 2,
                        par: 3,
                        distance: 160,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -146),
                        type: 'rockwiga',
                        name: 'Sand Trap Alley',
                        fairwayHalfWidth: 18,
                        roughHalfWidth: 35,
                        treeLineOffset: 30,
                        treePairCount: 10,
                        behindGreenTreeCount: 8,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 200, length: 400, segmentsW: 100, segmentsL: 200 },
                        obDistance: 55,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: -10, z: -140 },
                            { type: 'green', x: 10, z: -140 }
                        ],
                        greenSlope: { direction: 90, percent: 2 }
                    },
                    {
                        number: 3,
                        par: 5,
                        distance: 484,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -443),
                        type: 'rockwiga',
                        name: 'The Long Corridor',
                        fairwayHalfWidth: 24,
                        roughHalfWidth: 44,
                        landingZoneYards: 240,
                        landingZoneRadius: 34,
                        landingZoneBoost: 6,
                        treeLineOffset: 36,
                        treePairCount: 24,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 300, length: 1000, segmentsW: 150, segmentsL: 360 },
                        obDistance: 75,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: -12, z: -437 },
                            { type: 'green', x: 12, z: -437 }
                        ],
                        greenSlope: { direction: 180, percent: 1.5 }
                    },
                    {
                        number: 4,
                        par: 4,
                        distance: 334,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -305),
                        type: 'rockwiga',
                        name: 'Tight Squeeze',
                        fairwayHalfWidth: 18,
                        roughHalfWidth: 34,
                        landingZoneYards: 210,
                        landingZoneRadius: 28,
                        landingZoneBoost: 5,
                        treeLineOffset: 26,
                        treePairCount: 18,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 280, length: 680, segmentsW: 140, segmentsL: 260 },
                        obDistance: 60,
                        waterPolygons: [],
                        bunkers: [],
                        greenSlope: { direction: 270, percent: 1 }
                    },
                    {
                        number: 5,
                        par: 4,
                        distance: 317,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(-30, 0, -287),
                        type: 'rockwiga',
                        name: 'Left Angle',
                        fairwayHalfWidth: 22,
                        roughHalfWidth: 40,
                        landingZoneYards: 200,
                        landingZoneRadius: 30,
                        landingZoneBoost: 6,
                        treeLineOffset: 32,
                        treePairCount: 16,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 320, length: 660, segmentsW: 160, segmentsL: 260 },
                        obDistance: 65,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: -40, z: -281 },
                            { type: 'green', x: -20, z: -281 },
                            { type: 'fairway', x: -40, z: -150 }
                        ],
                        greenSlope: { direction: 45, percent: 1.5 }
                    },
                    {
                        number: 6,
                        par: 4,
                        distance: 326,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 0, -298),
                        type: 'rockwiga',
                        name: 'Open Right',
                        fairwayHalfWidth: 22,
                        roughHalfWidth: 42,
                        landingZoneYards: 210,
                        landingZoneRadius: 30,
                        landingZoneBoost: 6,
                        treeLineOffset: 34,
                        treePairCount: 18,
                        behindGreenTreeCount: 8,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 320, length: 680, segmentsW: 160, segmentsL: 260 },
                        obDistance: 65,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: 12, z: -292 }
                        ],
                        greenSlope: { direction: 135, percent: 2 }
                    },
                    {
                        number: 7,
                        par: 5,
                        distance: 434,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(20, 0, -397),
                        type: 'rockwiga',
                        name: 'Gentle Bend',
                        fairwayHalfWidth: 24,
                        roughHalfWidth: 44,
                        landingZoneYards: 230,
                        landingZoneRadius: 34,
                        landingZoneBoost: 6,
                        treeLineOffset: 36,
                        treePairCount: 22,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 340, length: 900, segmentsW: 170, segmentsL: 340 },
                        obDistance: 75,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: 8, z: -391 },
                            { type: 'green', x: 32, z: -391 }
                        ],
                        greenSlope: { direction: 0, percent: 1 }
                    },
                    {
                        number: 8,
                        par: 3,
                        distance: 148,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(0, 2, -135),
                        type: 'rockwiga',
                        name: 'Uphill Battle',
                        fairwayHalfWidth: 18,
                        roughHalfWidth: 35,
                        treeLineOffset: 28,
                        treePairCount: 12,
                        behindGreenTreeCount: 10,
                        treeDensity: 'surround',
                        teeHeight: 3,
                        greenHeight: 2,
                        terrainSize: { width: 180, length: 360, segmentsW: 90, segmentsL: 180 },
                        obDistance: 50,
                        waterPolygons: [],
                        bunkers: [],
                        greenSlope: { direction: 180, percent: 3 }
                    },
                    {
                        number: 9,
                        par: 4,
                        distance: 398,
                        teePosition: new THREE.Vector3(0, 3.146, 0),
                        pinPosition: new THREE.Vector3(40, 0, -361),
                        type: 'rockwiga',
                        name: 'Dogleg Finish',
                        fairwayHalfWidth: 22,
                        roughHalfWidth: 42,
                        landingZoneYards: 220,
                        landingZoneRadius: 32,
                        landingZoneBoost: 6,
                        treeLineOffset: 34,
                        treePairCount: 20,
                        behindGreenTreeCount: 10,
                        teeHeight: 3,
                        greenHeight: -0.2,
                        terrainSize: { width: 360, length: 800, segmentsW: 180, segmentsL: 300 },
                        obDistance: 70,
                        waterPolygons: [],
                        bunkers: [
                            { type: 'green', x: 40, z: -349 },
                            { type: 'green', x: 52, z: -355 }
                        ],
                        greenSlope: { direction: 90, percent: 1.5 }
                    }
                ]
            }
        };

        let selectedCourseId = 'shanktuary';
        try {
            const storedCourse = localStorage.getItem('golfSelectedCourse');
            if (storedCourse && COURSES[storedCourse]) {
                selectedCourseId = storedCourse;
            }
        } catch (e) {
            console.log('Could not load golf course selection, using default');
        }

        const currentCourse = COURSES[selectedCourseId] || COURSES.shanktuary;
        const HOLES = currentCourse.holes;

        // Load hole selection from localStorage
        let selectedHoles = 'all'; // Default: play all holes
        try {
            const storedSelection = localStorage.getItem('golfSelectedHoles');
            if (storedSelection) {
                selectedHoles = JSON.parse(storedSelection);
            }
        } catch (e) {
            console.log('Could not load hole selection, using default (all)');
        }

        // Set starting hole based on selection
        let currentHoleIndex = 0;
        const selectedHoleNumber = Number(selectedHoles);
        if (selectedHoles !== 'all' && Number.isFinite(selectedHoleNumber)) {
            currentHoleIndex = Math.max(0, Math.min(selectedHoleNumber - 1, HOLES.length - 1));
        }

        let PIN_POSITION = HOLES[currentHoleIndex].pinPosition.clone();
        const BUNKER_LEFT_POSITION = new THREE.Vector3(-16, -0.3, -118.872); // Left of green, well outside 10m radius
        const BUNKER_RIGHT_POSITION = new THREE.Vector3(16, -0.3, -118.872); // Right of green, well outside 10m radius

        // Physics constants - from TrajectoryCalculatorGolf-v2.xlsx (keeping Excel formulas)
        const GRAVITY = 32.174; // ft/s¬≤ (Excel uses imperial)
        const BALL_MASS_OZ = 1.62; // oz
        const BALL_MASS_SLUGS = BALL_MASS_OZ / 514.78; // Convert oz to slugs
        const BALL_CIRC = 5.277; // inches
        const BALL_RADIUS_FT = (BALL_CIRC / (2 * Math.PI)) / 12; // Convert to feet
        const BALL_RADIUS = BALL_RADIUS_FT * 0.3048; // Convert to meters for THREE.js

        // Air density (slug/ft¬≥)
        const AIR_DENSITY_SLUGS_DEFAULT = 0.0748;

        // Magnus constant from Excel (D4)
        const MAGNUS_CONST = 0.00568249207;

        // ============================================================================
        // EMPIRICAL GOLF BALL FLIGHT MODEL
        // Pure data-driven approach using multi-region linear regression
        // Achieves 93% accuracy (‚â§10 yard tolerance) with 3.4 yard average error
        // Optimized on 99 shots from all-shots.csv
        // ============================================================================

        // Region calibration data (optimized on 160 shots from all-shots.csv)
        const EMPIRICAL_REGIONS = {
            WEDGE: {
                avgSpeed: 56.2,
                avgVLA: 25.5,
                avgSpin: 5260,
                avgTotal: 58.3,
                speedCoeff: 1.5,
                vlaCoeff: 0,
                spinCoeff: 0
            },
            IRON: {
                avgSpeed: 80.4,
                avgVLA: 21.5,
                avgSpin: 5788,
                avgTotal: 97.1,
                speedCoeff: 2,
                vlaCoeff: 2,      // Positive: high VLA increases distance for irons
                spinCoeff: -0.005
            },
            POWER: {
                avgSpeed: 125.2,
                avgVLA: 19.3,
                avgSpin: 5569,
                avgTotal: 189.8,
                speedCoeff: 2,
                vlaCoeff: 1,
                spinCoeff: -0.01
            },
            DRIVER_LOW_VLA: {
                avgSpeed: 155.0,
                avgVLA: 11.0,
                avgSpin: 2786,
                avgTotal: 265.6,
                speedCoeff: 1.5,
                vlaCoeff: 5,      // High VLA effect for low trajectory drivers
                spinCoeff: -0.01
            },
            DRIVER: {
                avgSpeed: 153.9,
                avgVLA: 41.8,
                avgSpin: 2568,
                avgTotal: 271.1,
                speedCoeff: 1.5,
                vlaCoeff: 0,
                spinCoeff: -0.01
            }
        };

        /**
         * Determine which region a shot belongs to
         * @param {number} speedMPH - Ball speed in mph
         * @param {number} vlaDegs - Vertical launch angle in degrees
         * @returns {string} Region name (WEDGE, IRON, POWER, DRIVER_LOW_VLA, or DRIVER)
         */
        function getEmpiricalRegion(speedMPH, vlaDegs) {
            if (speedMPH < 65) return 'WEDGE';
            if (speedMPH < 100) return 'IRON';
            if (speedMPH < 140) return 'POWER';
            if (speedMPH >= 140 && vlaDegs < 13) return 'DRIVER_LOW_VLA';
            return 'DRIVER';
        }

        /**
         * Predict total carry + roll distance using empirical model
         * @param {number} speedMPH - Ball speed in mph
         * @param {number} vlaDegs - Vertical launch angle in degrees
         * @param {number} spinRPM - Backspin in revolutions per minute
         * @returns {number} Predicted total distance in yards
         */
        function predictEmpiricalDistance(speedMPH, vlaDegs, spinRPM) {
            const region = getEmpiricalRegion(speedMPH, vlaDegs);
            const r = EMPIRICAL_REGIONS[region];

            // Calculate deltas from region averages
            const speedDelta = speedMPH - r.avgSpeed;
            const vlaDelta = vlaDegs - r.avgVLA;
            const spinDelta = spinRPM - r.avgSpin;

            // Linear regression: distance = baseline + weighted deltas
            const distance = r.avgTotal
                + r.speedCoeff * speedDelta
                + r.vlaCoeff * vlaDelta
                + r.spinCoeff * spinDelta;

            return distance;
        }

        /**
         * Get detailed prediction with metadata
         * @param {number} speedMPH - Ball speed in mph
         * @param {number} vlaDegs - Vertical launch angle in degrees
         * @param {number} spinRPM - Backspin in revolutions per minute
         * @returns {object} Prediction with distance, region, and coefficients used
         */
        function predictEmpirical(speedMPH, vlaDegs, spinRPM) {
            const region = getEmpiricalRegion(speedMPH);
            const distance = predictEmpiricalDistance(speedMPH, vlaDegs, spinRPM);

            return {
                distance: distance,
                region: region,
                coefficients: EMPIRICAL_REGIONS[region]
            };
        }

        // Variable to store empirical prediction for trajectory scaling
        let empiricalPredictedDistance = null;

        // ============================================================================
        // END EMPIRICAL MODEL
        // ============================================================================

        // Drag constant formula from Excel: 0.07182*rho*(5.125/mass)*(circ/9.125)^2
        function getDragConstant(airDensitySlugs) {
            return 0.07182 * airDensitySlugs * (5.125 / BALL_MASS_OZ) * Math.pow(BALL_CIRC / 9.125, 2);
        }

        const DRAG_CONST = getDragConstant(AIR_DENSITY_SLUGS_DEFAULT);

        // Stimpmeter putting physics (for putts with VLA <= 2 degrees)
        // Synced with putting-green.html physics
        let currentStimp = 10; // Default green speed (10 feet)
        let puttingFriction = 0.15; // Will be calculated from Stimp
        let currentPuttDeceleration = 0; // Per-putt deceleration from GSPro model
        const GRAVITY_MS2 = 9.81; // m/s¬≤ for putting physics

        // ========== DRAFT GOLF MODE ==========
        let draftGolfEnabled = false;
        let draftGolfType = 'solo';        // 'solo' | 'multiplayer'
        let draftGolfVariant = 'basic';    // 'basic' | 'advanced'
        let draftGolfPhase = 'IDLE';       // IDLE | WAITING_FOR_SHOTS | DRAFT_PHASE

        const DRAFT_GOLF_CONFIG = {
            TEAM_SIZE: 4,
            AI_HANDICAPS: [10, 15, 20]  // 3 AI opponents for solo mode
        };

        let draftGolfState = {
            shotRound: 0,
            shotResults: [],        // [{playerIndex, position, lieQuality, distanceToHole}]
            draftOrder: [],         // Randomized player indices
            currentDrafter: 0,      // Index into draftOrder
            picks: {}               // {playerIndex: ballIndex}
        };

        const AI_SKILL_PROFILES = {
            5:  { driving: 85, irons: 82, short_game: 78, putting: 80, consistency: 0.85 },
            10: { driving: 75, irons: 72, short_game: 68, putting: 72, consistency: 0.75 },
            15: { driving: 65, irons: 62, short_game: 58, putting: 65, consistency: 0.65 },
            20: { driving: 55, irons: 50, short_game: 48, putting: 58, consistency: 0.55 }
        };

        const DRAFT_LIE_QUALITY = {
            PERFECT:   { name: 'Perfect',   factor: 1.0,  color: '#4ade80' },
            GOOD:      { name: 'Good',      factor: 0.9,  color: '#a3e635' },
            MODERATE:  { name: 'Moderate',  factor: 0.75, color: '#fbbf24' },
            DIFFICULT: { name: 'Difficult', factor: 0.6,  color: '#fb923c' },
            TERRIBLE:  { name: 'Terrible',  factor: 0.4,  color: '#ef4444' }
        };
        // ========== END DRAFT GOLF STATE ==========

        // Calculate putting friction from Stimpmeter
        // SYNCED WITH PUTTING-GREEN.HTML (lines 1072-1095)
        function updatePuttingFriction() {
            // Stimpmeter model: œÅ_g interpolated between slow (7 ft) and fast (14 ft)
            // Based on Stanford physics paper (Kolkowitz 2007)
            const rhoGSlow = 0.196;
            const rhoGFast = 0.065;
            const stimpRange = 14 - 7;
            const t = (currentStimp - 7) / stimpRange; // 0 = slow, 1 = fast
            const rhoG = rhoGSlow - t * (rhoGSlow - rhoGFast);

            // Friction coefficient: (5/7) √ó œÅ_g
            puttingFriction = rhoG * (5/7);

            console.log(`Stimp ${currentStimp} ‚Üí œÅ_g: ${rhoG.toFixed(4)}, Friction: ${puttingFriction.toFixed(4)}`);
        }

        // GSPro putting distance coefficients: distance(ft) = a*v¬≤ + b*v + c (v in mph)
        // Derived from GSPro putting chart ‚Äî matches every row to <0.1 ft
        const GSPRO_PUTT_COEFFS = {
            7:  { a: 0.1296, b: 2.200, c: -4.366 },
            8:  { a: 0.1208, b: 2.715, c: -5.132 },
            9:  { a: 0.112,  b: 3.23,  c: -5.898 },
            10: { a: 0.111,  b: 3.500, c: -6.0   },
            11: { a: 0.1011, b: 3.957, c: -6.481 },
            12: { a: 0.0962, b: 4.263, c: -6.755 },
            13: { a: 0.0979, b: 4.613, c: -7.22  },
            14: { a: 0.0996, b: 4.963, c: -7.685 }
        };

        function getGSProPuttDistance(speedMPH, stimp) {
            // Interpolate coefficients for the given stimp
            const stimpClamped = Math.max(7, Math.min(14, stimp));
            const stimpLow = Math.floor(stimpClamped);
            const stimpHigh = Math.ceil(stimpClamped);

            let a, b, c;
            if (stimpLow === stimpHigh) {
                const coeff = GSPRO_PUTT_COEFFS[stimpLow];
                a = coeff.a; b = coeff.b; c = coeff.c;
            } else {
                const frac = stimpClamped - stimpLow;
                const lo = GSPRO_PUTT_COEFFS[stimpLow];
                const hi = GSPRO_PUTT_COEFFS[stimpHigh];
                a = lo.a + frac * (hi.a - lo.a);
                b = lo.b + frac * (hi.b - lo.b);
                c = lo.c + frac * (hi.c - lo.c);
            }

            // Low speed fallback: linear from 0 to chart value at 2 mph
            if (speedMPH < 2) {
                const distAt2 = a * 4 + b * 2 + c;
                const safeDist = Math.max(distAt2, 0.1);
                return Math.max(0.1, (safeDist / 2) * speedMPH);
            }

            // Quadratic formula: d = a*v¬≤ + b*v + c
            const dist = a * speedMPH * speedMPH + b * speedMPH + c;
            return Math.max(0.1, dist);
        }

        function computePuttDeceleration(speedMPH, stimp) {
            const distFt = getGSProPuttDistance(speedMPH, stimp);
            const distM = distFt * 0.3048;
            const speedMS = speedMPH * 0.44704;
            // v¬≤ = 2*a*d ‚Üí a = v¬≤ / (2*d)
            const decel = (speedMS * speedMS) / (2 * distM);
            console.log(`GSPro putt: speed=${speedMPH.toFixed(1)} mph, stimp=${stimp}, target=${distFt.toFixed(1)} ft, decel=${decel.toFixed(3)} m/s¬≤`);
            return decel;
        }

        // Load Stimp from localStorage (set from player setup screen)
        const savedStimp = localStorage.getItem('golfGreenStimp');
        if (savedStimp) {
            currentStimp = parseFloat(savedStimp);
            updatePuttingFriction();
            console.log(`‚úÖ Loaded Stimp from player setup: ${currentStimp} ft`);
        } else {
            updatePuttingFriction();
        }

        // Listen for Stimp changes from Electron menu (fallback/override)
        if (window.electronAPI) {
            // Listen for Stimp changes
            window.electronAPI.onStimpChanged((stimp) => {
                currentStimp = stimp;
                updatePuttingFriction();
                console.log(`‚öôÔ∏è Stimp updated from menu: ${stimp} ft`);
            });
        }

        // Load Visual Offset from localStorage (for projector alignment)
        let visualOffsetX = 0;
        let visualOffsetY = 0;
        const savedOffsetX = localStorage.getItem('golfVisualOffsetX');
        const savedOffsetY = localStorage.getItem('golfVisualOffsetY');
        if (savedOffsetX) {
            visualOffsetX = parseInt(savedOffsetX);
            console.log(`‚úÖ Loaded Visual Offset X: ${visualOffsetX}px`);
        }
        if (savedOffsetY) {
            visualOffsetY = parseInt(savedOffsetY);
            console.log(`‚úÖ Loaded Visual Offset Y: ${visualOffsetY}px`);
        }

        // Lookup table for lift and drag coefficients based on speed and spin rate
        // From golf-flight-sim-3d project (empirical data)
        // Rows: speed squared (m¬≤/s¬≤), Columns: spin rate (rpm)
        const COEFF_LUT = [
            [{lift: -0.11, drag: 0.52}, {lift: -0.06, drag: 0.39}, {lift: 0.06, drag: 0.36}, {lift: 0.35, drag: 0.42}, {lift: 0.39, drag: 0.40}, {lift: 0.41, drag: 0.48}, {lift: 0.49, drag: 0.52}],
            [{lift:  0.00, drag: 0.33}, {lift:  0.12, drag: 0.25}, {lift: 0.18, drag: 0.28}, {lift: 0.33, drag: 0.36}, {lift: 0.36, drag: 0.38}, {lift: 0.38, drag: 0.43}, {lift: 0.45, drag: 0.45}],
            [{lift:  0.06, drag: 0.22}, {lift:  0.17, drag: 0.24}, {lift: 0.24, drag: 0.27}, {lift: 0.29, drag: 0.31}, {lift: 0.33, drag: 0.34}, {lift: 0.34, drag: 0.37}, {lift: 0.39, drag: 0.39}],
            [{lift:  0.07, drag: 0.23}, {lift:  0.14, drag: 0.23}, {lift: 0.19, drag: 0.25}, {lift: 0.24, drag: 0.28}, {lift: 0.28, drag: 0.30}, {lift: 0.31, drag: 0.33}, {lift: 0.35, drag: 0.36}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.13, drag: 0.24}, {lift: 0.16, drag: 0.25}, {lift: 0.20, drag: 0.27}, {lift: 0.24, drag: 0.28}, {lift: 0.27, drag: 0.30}, {lift: 0.31, drag: 0.34}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.12, drag: 0.24}, {lift: 0.15, drag: 0.25}, {lift: 0.18, drag: 0.26}, {lift: 0.21, drag: 0.26}, {lift: 0.24, drag: 0.29}, {lift: 0.28, drag: 0.32}],
            [{lift:  0.08, drag: 0.25}, {lift:  0.12, drag: 0.25}, {lift: 0.14, drag: 0.25}, {lift: 0.17, drag: 0.26}, {lift: 0.19, drag: 0.26}, {lift: 0.22, drag: 0.28}, {lift: 0.26, drag: 0.29}],
            [{lift:  0.08, drag: 0.25}, {lift:  0.12, drag: 0.25}, {lift: 0.14, drag: 0.25}, {lift: 0.16, drag: 0.26}, {lift: 0.18, drag: 0.26}, {lift: 0.20, drag: 0.28}, {lift: 0.23, drag: 0.29}],
            [{lift:  0.07, drag: 0.25}, {lift:  0.11, drag: 0.25}, {lift: 0.13, drag: 0.25}, {lift: 0.15, drag: 0.26}, {lift: 0.17, drag: 0.26}, {lift: 0.18, drag: 0.27}, {lift: 0.22, drag: 0.28}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.11, drag: 0.24}, {lift: 0.13, drag: 0.25}, {lift: 0.15, drag: 0.26}, {lift: 0.16, drag: 0.26}, {lift: 0.17, drag: 0.27}, {lift: 0.20, drag: 0.27}]
        ];

        function getLiftDragCoefficients(speedSquared, spinRate) {
            let row, col;

            // Determine row based on speed squared (m¬≤/s¬≤)
            if (speedSquared > 7249.0) row = 9;
            else if (speedSquared > 5939.0) row = 8;
            else if (speedSquared > 4698.0) row = 7;
            else if (speedSquared > 3588.0) row = 6;
            else if (speedSquared > 2654.0) row = 5;
            else if (speedSquared > 1874.0) row = 4;
            else if (speedSquared > 1226.0) row = 3;
            else if (speedSquared > 705.0) row = 2;
            else if (speedSquared > 338.0) row = 1;
            else row = 0;

            // Determine column based on spin rate (rpm)
            if (spinRate > 5478.0) col = 6;
            else if (spinRate > 4223.0) col = 5;
            else if (spinRate > 3283.0) col = 4;
            else if (spinRate > 2340.0) col = 3;
            else if (spinRate > 1433.0) col = 2;
            else if (spinRate > 500.0) col = 1;
            else col = 0;

            return COEFF_LUT[row][col];
        }

        // Lie conditions - calibrated to match FlightScope rollout (~8-10 yards)
        const LIE_TYPES = {
            TEE: { name: 'Tee', friction: 15.0, rollFactor: 0.9, bounceRetention: 0.3, color: 0x2d5a3d },
            FAIRWAY: { name: 'Fairway', friction: 15.0, rollFactor: 0.7, bounceRetention: 0.3, color: 0x4a9d5f },
            LIGHT_ROUGH: { name: 'Light Rough', friction: 25.0, rollFactor: 0.4, bounceRetention: 0.2, color: 0x3a7d44 },
            HEAVY_ROUGH: { name: 'Heavy Rough', friction: 40.0, rollFactor: 0.2, bounceRetention: 0.15, color: 0x2d5a28 },
            BUNKER: { name: 'Bunker', friction: 50.0, rollFactor: 0.1, bounceRetention: 0.1, color: 0xddc998 },
            GREEN: { name: 'Green', friction: 8.0, rollFactor: 0.95, bounceRetention: 0.3, color: 0x4a9d5f }
        };

        let currentLie = LIE_TYPES.TEE;

        // Utility: Point-in-polygon check (ray casting algorithm)
        function isPointInPolygon(x, z, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, zi = polygon[i].z;
                const xj = polygon[j].x, zj = polygon[j].z;

                const intersect = ((zi > z) !== (zj > z))
                    && (x < (xj - xi) * (z - zi) / (zj - zi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getLongPar5SplitZ(hole) {
            const splitYards = hole.splitYards || 200;
            return -(splitYards * 0.9144);
        }

        function getLongPar5PostSplitProgress(z, hole) {
            const splitZ = getLongPar5SplitZ(hole);
            const postSplitDistance = Math.max(1, Math.abs(hole.pinPosition.z) - Math.abs(splitZ));
            return Math.min(1, Math.max(0, (Math.abs(z) - Math.abs(splitZ)) / postSplitDistance));
        }

        function getLongPar5PathCenterX(z, hole, shiftX, turnStart, turnEnd) {
            const splitZ = getLongPar5SplitZ(hole);
            if (z > splitZ) {
                return 0;
            }

            const progress = getLongPar5PostSplitProgress(z, hole);
            const start = turnStart ?? 0;
            const end = turnEnd ?? 1;

            if (progress <= start) {
                return 0;
            }

            if (progress >= end) {
                return shiftX;
            }

            const turnProgress = (progress - start) / Math.max(0.001, end - start);
            const eased = turnProgress * turnProgress * (3 - 2 * turnProgress);
            return eased * shiftX;
        }

        function getLongPar5LeftCenterX(z, hole) {
            const shiftX = hole.leftPathShift || 0;
            return getLongPar5PathCenterX(z, hole, shiftX, hole.leftPathTurnStart, hole.leftPathTurnEnd);
        }

        function getLongPar5RightCenterX(z, hole) {
            const shiftX = hole.rightPathShift || 0;
            return getLongPar5PathCenterX(z, hole, shiftX, hole.rightPathTurnStart, hole.rightPathTurnEnd);
        }

        function getLongPar5PathBands(z, hole) {
            const splitZ = getLongPar5SplitZ(hole);
            if (z > splitZ) {
                return [{
                    centerX: 0,
                    fairwayHalfWidth: hole.fairwayHalfWidth || 18,
                    roughHalfWidth: hole.roughHalfWidth || 34
                }];
            }

            return [
                {
                    centerX: getLongPar5LeftCenterX(z, hole),
                    fairwayHalfWidth: hole.leftPathHalfWidth || 12,
                    roughHalfWidth: hole.leftRoughHalfWidth || hole.roughHalfWidth || 34
                },
                {
                    centerX: getLongPar5RightCenterX(z, hole),
                    fairwayHalfWidth: hole.rightPathHalfWidth || 22,
                    roughHalfWidth: hole.rightRoughHalfWidth || hole.roughHalfWidth || 34
                }
            ];
        }

        function getLongPar5NearestBand(x, z, hole) {
            const bands = getLongPar5PathBands(z, hole);
            let bestBand = bands[0];
            let bestDist = Math.abs(x - bestBand.centerX);

            for (let i = 1; i < bands.length; i++) {
                const band = bands[i];
                const dist = Math.abs(x - band.centerX);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestBand = band;
                }
            }

            return { band: bestBand, dist: bestDist };
        }

        function isInLongPar5Clearing(x, z, hole) {
            if (!hole.leftClearing) {
                return false;
            }

            const dx = (x - hole.leftClearing.x) / hole.leftClearing.radiusX;
            const dz = (z - hole.leftClearing.z) / hole.leftClearing.radiusZ;
            return (dx * dx + dz * dz) <= 1;
        }

        function getTeeToPinProjection(x, z, hole) {
            const tee = hole.teePosition || TEE_POSITION;
            const pin = hole.pinPosition;
            const dx = pin.x - tee.x;
            const dz = pin.z - tee.z;
            const lengthSq = dx * dx + dz * dz;

            if (lengthSq < 0.001) {
                return {
                    dist: Math.sqrt(Math.pow(x - tee.x, 2) + Math.pow(z - tee.z, 2)),
                    t: 0,
                    projX: tee.x,
                    projZ: tee.z,
                    length: 0
                };
            }

            const t = ((x - tee.x) * dx + (z - tee.z) * dz) / lengthSq;
            const clampedT = Math.max(0, Math.min(1, t));
            const projX = tee.x + clampedT * dx;
            const projZ = tee.z + clampedT * dz;
            return {
                dist: Math.sqrt(Math.pow(x - projX, 2) + Math.pow(z - projZ, 2)),
                t: clampedT,
                projX,
                projZ,
                length: Math.sqrt(lengthSq)
            };
        }

        // Tree collision data
        let trees = [];

        // Shot tracking
        let shotStartPos = new THREE.Vector3();
        let maxHeight = 0;
        let carryDistance = 0;
        let landingPos = new THREE.Vector3();
        let hasLanded = false;
        let initialShotSpeedMPH = 0; // Track initial shot speed for five-regime physics
        let initialVLADegs = 0; // Track initial VLA for five-regime physics
        let physicsRegime = 'WEDGE'; // Physics regime: WEDGE, LOW_TRAJECTORY, MID_IRON, HIGH_IRON, or POWER_SHOT (FIVE-REGIME PHYSICS v4.5.0)
        let lastTime = performance.now();

        const DEBUG_FPS_LOG = false;
        const DEBUG_GROUND_RAYCAST = false;
        const YARDAGE_UPDATE_INTERVAL_MS = 100;
        const MINIMAP_UPDATE_INTERVAL_MS = 100;
        const MINIMAP_IDLE_INTERVAL_MS = 500;
        const GROUND_RAYCAST_BUFFER = 10;

        // FPS tracking
        let frameCount = 0;
        let lastFpsUpdateTime = 0;

        let debugMode = false; // Debug camera mode

        // Camera system
        let currentView = 'behind-ball';
        let savedView = 'behind-ball';

        // Ball tracer
        let tracer = null;
        const MAX_TRACER_POINTS = 200;
        let tracerPositions = new Array(MAX_TRACER_POINTS);
        let tracerCount = 0;
        let tracerWriteIndex = 0;

        // Raycaster for terrain collision
        let raycaster = new THREE.Raycaster();
        const rayOrigin = new THREE.Vector3();
        const rayDirection = new THREE.Vector3(0, -1, 0);
        let groundObjectsCache = [];

        const pinScreenPos = new THREE.Vector3();
        let lastYardageUpdateTime = 0;
        let lastYardageValue = null;
        let lastYardageLabel = '';
        let lastYardageX = null;
        let lastYardageY = null;
        let lastYardageVisible = null;

        let lastMinimapUpdateTime = 0;

        // Grid visualization
        let gridLines = null;
        let showGrid = false;

        // Shot direction adjustment
        let aimAdjustment = 0; // Degrees to add to HLA
        let baseDirection = 0; // Base direction (0 = toward pin, updated after each shot)

        // Terrain and course objects (for recreation)
        let terrain = null;
        let greenMesh = null;
        let cup = null;
        let flagstick = null;
        let gimmieCircle5ft = null;
        let gimmieCircle10ft = null;
        let bunkers = [];
        let teeMarkers = [];
        let treeMeshes = []; // For visual tree objects
        let islandMeshes = []; // For island-hopping hole circular islands
        let stadiumMeshes = []; // For stadium stands around the green

        function setupHole(holeIndex) {
            const hole = HOLES[holeIndex];
            console.log(`Setting up Hole ${hole.number}: Par ${hole.par}, ${hole.distance} yards`);

            // Update hole title in UI
            const holeTitle = document.getElementById('holeTitle');
            if (holeTitle) {
                const holeName = hole.name ? ` - ${hole.name}` : '';
                const courseName = currentCourse && currentCourse.name ? currentCourse.name : 'Golf Course';
                holeTitle.textContent = `‚õ≥ ${courseName} - Hole ${hole.number}${holeName}`;
            }

            // Update PIN_POSITION
            PIN_POSITION.copy(hole.pinPosition);

            // Clear existing course objects
            if (terrain) scene.remove(terrain);
            if (greenMesh) scene.remove(greenMesh);
            if (cup) scene.remove(cup);
            if (flagstick) scene.remove(flagstick);
            if (gimmieCircle5ft) scene.remove(gimmieCircle5ft);
            if (gimmieCircle10ft) scene.remove(gimmieCircle10ft);
            bunkers.forEach(b => scene.remove(b));
            teeMarkers.forEach(t => scene.remove(t));
            treeMeshes.forEach(t => scene.remove(t));
            islandMeshes.forEach(i => scene.remove(i));
            stadiumMeshes.forEach(s => scene.remove(s));
            bunkers = [];
            teeMarkers = [];
            trees = [];
            treeMeshes = [];
            islandMeshes = [];
            stadiumMeshes = [];

            // Recreate course for this hole
            createCourse();

            // Restore gimmie circles visibility based on current setting
            if (gimmieCirclesEnabled) {
                if (gimmieCircle5ft) gimmieCircle5ft.visible = true;
                if (gimmieCircle10ft) gimmieCircle10ft.visible = true;
            }

            // Recreate trees
            setTimeout(() => {
                createTreeLine();
            }, 100);

            console.log(`Hole ${hole.number} setup complete`);
        }

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            camera.lookAt(0, 0, -60);

            // Apply visual offset for projector alignment
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                const fullWidth = window.innerWidth;
                const fullHeight = window.innerHeight;
                camera.setViewOffset(fullWidth, fullHeight, visualOffsetX, visualOffsetY, fullWidth, fullHeight);
                console.log(`‚úÖ Visual offset applied: (${visualOffsetX}, ${visualOffsetY})`);
            }

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Log GPU info for debugging
            const gl = renderer.getContext();
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                console.log('üéÆ GPU Vendor:', gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL));
                console.log('üéÆ GPU Renderer:', gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
            }
            console.log('üéÆ WebGL Version:', gl.getParameter(gl.VERSION));
            console.log('üéÆ Max Texture Size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));

            // Minimap renderer and camera
            minimapRenderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('minimap'),
                antialias: true,
                alpha: false,
                powerPreference: "low-power"
            });
            minimapRenderer.setSize(200, 200);
            minimapRenderer.shadowMap.enabled = false;
            minimapRenderer.setClearColor(0x87CEEB, 1);

            minimapCamera = new THREE.OrthographicCamera(-150, 150, 150, -150, 0.1, 500);
            minimapCamera.position.set(0, 200, 0);
            minimapCamera.lookAt(0, 0, 0);
            minimapCamera.layers.enableAll();

            // Lighting - Load from graphics settings
            let ambientLightIntensity = 1.2;
            let sunLightIntensity = 1.5;

            // Load graphics settings from localStorage
            try {
                const savedSettings = localStorage.getItem('graphics_settings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    ambientLightIntensity = settings.ambientLight || 1.2;
                    sunLightIntensity = settings.sunLight || 1.5;
                    console.log('Applied graphics settings:', settings);
                }
            } catch (e) {
                console.error('Error loading graphics settings:', e);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, ambientLightIntensity);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, sunLightIntensity);
            sunLight.position.set(50, 100, 50);
            // PERFORMANCE: Shadows disabled
            sunLight.castShadow = false;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Load textures
            const textureLoader = new THREE.TextureLoader();

            // Track texture loading
            let texturesLoaded = 0;
            const totalTextures = 4;

            function onTextureLoad() {
                texturesLoaded++;
                console.log(`Texture loaded: ${texturesLoaded}/${totalTextures}`);
                if (texturesLoaded === totalTextures) {
                    console.log('All textures loaded, creating course...');
                    createCourse();
                    createBall();
                    createTracer();

                    // Create trees AFTER terrain is fully in scene
                    setTimeout(() => {
                        createTreeLine();
                    }, 100);

                    // Check for Draft Golf mode from localStorage
                    setTimeout(() => {
                        checkAndStartDraftGolf();
                    }, 500);
                }
            }

            function checkAndStartDraftGolf() {
                try {
                    const gameMode = localStorage.getItem('golfGameMode');
                    const draftAdvanced = localStorage.getItem('golfDraftAdvanced') === 'true';
                    const variant = draftAdvanced ? 'advanced' : 'basic';

                    console.log(`üéØ checkAndStartDraftGolf: gameMode=${gameMode}, draftAdvanced=${draftAdvanced}`);

                    if (gameMode === 'draft-solo') {
                        console.log('üéØ Auto-starting Draft Golf Solo mode...');
                        initDraftGolf('solo', variant);
                    } else if (gameMode === 'draft-multi') {
                        console.log('üéØ Auto-starting Draft Golf Multiplayer mode...');
                        initDraftGolf('multiplayer', variant);
                    } else {
                        console.log('üéØ Standard mode selected, Draft Golf not started');
                    }
                    // Clear the game mode so it doesn't auto-start next time
                    localStorage.removeItem('golfGameMode');
                    localStorage.removeItem('golfDraftAdvanced');
                } catch (e) {
                    console.log('Could not check for Draft Golf mode:', e);
                }
            }

            fairwayTexture = textureLoader.load('textures/fairway.png', (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(20, 20);
                onTextureLoad();
            });

            roughTexture = textureLoader.load('textures/rough.png', (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(15, 15);
                onTextureLoad();
            });

            sandTexture = textureLoader.load('textures/sand.png', (texture) => {
                console.log('‚úÖ Sand texture loaded successfully!');
                console.log('Texture image dimensions:', texture.image.width, 'x', texture.image.height);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
                texture.needsUpdate = true; // Force texture update

                // Note: Bunkers will be created later in createCourse() and will use this texture
                console.log('Sand texture ready for bunkers, texture object:', texture);

                onTextureLoad();
            }, undefined, (err) => {
                console.error('‚ùå Failed to load sand texture:', err);
                sandTexture = null; // Ensure it's null on error
                onTextureLoad(); // Count as loaded to not block
            });

            dirtTexture = textureLoader.load('textures/dirt.png', (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(5, 5);
                onTextureLoad();
            });

            // Set initial camera view after ball is created
            updateCameraPosition(false);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('resetBtn').addEventListener('click', resetHole);
            document.getElementById('viewBtn').addEventListener('click', cycleView);
            document.getElementById('gridBtn').addEventListener('click', toggleGrid);

            // Demo shot button
            document.getElementById('fireDemoShot').addEventListener('click', () => {
                const speed = parseFloat(document.getElementById('demoSpeed').value);
                const vla = parseFloat(document.getElementById('demoVLA').value);
                const hla = parseFloat(document.getElementById('demoHLA').value);
                const totalSpin = parseFloat(document.getElementById('demoTotalSpin').value);
                const spinAxis = parseFloat(document.getElementById('demoSpinAxis').value);

                handleShot({
                    detail: {
                        speed: speed,
                        vla: vla,
                        hla: hla,
                        total_spin: totalSpin,
                        spin_axis: spinAxis
                    }
                });
            });

            // Listen for shot data from Electron IPC (if available)
            if (window.electronAPI) {
                console.log('‚úì Running in Electron - IPC available');
                window.electronAPI.onShotData(handleShotFromElectron);
            } else {
                console.log('Running in standalone mode - no IPC available');
            }

            // Add keyboard shortcuts
            const cameraSpeed = 2;

            window.addEventListener('keydown', (e) => {
                // Arrow keys - Adjust aim direction (1 degree increments)
                if (e.key === 'ArrowLeft') {
                    aimAdjustment -= 1; // Rotate 1 degree left
                    updateAimIndicator();
                    console.log(`Aim adjusted: ${aimAdjustment}¬∞ (Left)`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowRight') {
                    aimAdjustment += 1; // Rotate 1 degree right
                    updateAimIndicator();
                    console.log(`Aim adjusted: ${aimAdjustment}¬∞ (Right)`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowUp') {
                    aimAdjustment = 0; // Reset to straight
                    updateAimIndicator();
                    console.log('Aim reset to 0¬∞');
                    e.preventDefault();
                }

                // D key - Demo shot - DISABLED FOR RELEASE
                /*
                if (e.key === 'd' || e.key === 'D') {
                    // Use demo shot controls
                    const speed = parseFloat(document.getElementById('demoSpeed').value);
                    const vla = parseFloat(document.getElementById('demoVLA').value);
                    const hla = parseFloat(document.getElementById('demoHLA').value);
                    const totalSpin = parseFloat(document.getElementById('demoTotalSpin').value);
                    const spinAxis = parseFloat(document.getElementById('demoSpinAxis').value);

                    handleShot({
                        detail: {
                            speed: speed,
                            vla: vla,
                            hla: hla,
                            total_spin: totalSpin,
                            spin_axis: spinAxis
                        }
                    });
                }
                */

                // T key - Run automated tests - DISABLED FOR PRODUCTION
                /*
                if (e.key === 't' || e.key === 'T') {
                    runAutomatedTests();
                }
                */

                // F key - Toggle free camera mode - DISABLED FOR RELEASE
                /*
                if (e.key === 'f' || e.key === 'F') {
                    debugMode = !debugMode;
                    console.log('Debug camera mode:', debugMode ? 'ON' : 'OFF');
                }
                */

                // Arrow keys and WASD for camera movement (when in debug mode) - DISABLED FOR RELEASE
                /*
                if (debugMode) {
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        camera.position.z -= cameraSpeed;
                    }
                    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        camera.position.z += cameraSpeed;
                    }
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        camera.position.x -= cameraSpeed;
                    }
                    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        camera.position.x += cameraSpeed;
                    }
                    if (e.key === 'q' || e.key === 'Q') {
                        camera.position.y += cameraSpeed;
                    }
                    if (e.key === 'e' || e.key === 'E') {
                        camera.position.y -= cameraSpeed;
                    }

                    // Look at center of green
                    camera.lookAt(PIN_POSITION);
                }
                */
            });

            // Function to update gimmie circle visibility
            window.setGimmieCircles = function(enabled) {
                gimmieCirclesEnabled = enabled;
                if (gimmieCircle5ft) gimmieCircle5ft.visible = enabled;
                if (gimmieCircle10ft) gimmieCircle10ft.visible = enabled;
                console.log('Gimmie circles:', enabled ? 'ON' : 'OFF');
            };

            // Load gimmie circles setting from localStorage
            const gimmieCirclesSetting = localStorage.getItem('golfGimmieCircles');
            console.log('Gimmie circles setting from localStorage:', gimmieCirclesSetting);
            if (gimmieCirclesSetting === 'true') {
                window.setGimmieCircles(true);
            }
        }

        // Automated testing system - FlightScope calibration - DISABLED FOR PRODUCTION
        /*
        let testResults = [];
        let currentTestIndex = 0;
        let testRunning = false;

        const testCases = [
            { name: "3389 RPM Test", speed: 69.5, vla: 15.1, spin: 3389, expectedCarry: 61.1, expectedRoll: 17.4 },
            { name: "5493 RPM Test", speed: 70.7, vla: 23.1, spin: 5493, expectedCarry: 77.6, expectedRoll: 4.1 }
        ];

        function runAutomatedTests() {
            if (testRunning) {
                console.log('Test already running!');
                return;
            }

            testRunning = true;
            currentTestIndex = 0;
            testResults = [];

            console.log('\n========================================');
            console.log('STARTING AUTOMATED PHYSICS TESTS');
            console.log('========================================\n');

            runNextTest();
        }

        function runNextTest() {
            if (currentTestIndex >= testCases.length) {
                // All tests complete
                printTestResults();
                testRunning = false;
                return;
            }

            const test = testCases[currentTestIndex];
            console.log(`Running: ${test.name}`);
            console.log(`Parameters: ${test.speed} mph, ${test.vla}¬∞ VLA, ${test.spin} RPM`);

            // Fire the shot
            handleShot({
                detail: {
                    speed: test.speed,
                    vla: test.vla,
                    hla: 0,
                    total_spin: test.spin,
                    spin_axis: 0
                }
            });

            // Wait for ball to stop, then collect results
            const checkInterval = setInterval(() => {
                if (!ballInFlight && ballVelocity.length() < 0.05) {
                    clearInterval(checkInterval);

                    // Collect results
                    const carryText = document.getElementById('shotCarry').textContent;
                    const rollText = document.getElementById('shotRoll').textContent;
                    const totalText = document.getElementById('shotTotal').textContent;

                    const carry = parseFloat(carryText);
                    const roll = parseFloat(rollText);
                    const total = parseFloat(totalText);

                    testResults.push({
                        test: test.name,
                        gameCarry: carry,
                        gameRoll: roll,
                        gameTotal: total,
                        expectedCarry: test.expectedCarry,
                        expectedRoll: test.expectedRoll,
                        expectedTotal: test.expectedCarry + test.expectedRoll
                    });

                    console.log(`‚úì ${test.name} complete`);

                    // Move to next test
                    currentTestIndex++;
                    setTimeout(() => runNextTest(), 500);
                }
            }, 100);
        }

        function printTestResults() {
            console.log('\n========================================');
            console.log('TEST RESULTS SUMMARY');
            console.log('========================================\n');

            let allPassing = true;

            testResults.forEach(result => {
                const carryDiff = result.gameCarry - result.expectedCarry;
                const rollDiff = result.gameRoll - result.expectedRoll;
                const totalDiff = result.gameTotal - result.expectedTotal;

                console.log(`${result.test}:`);
                console.log(`  Carry: ${result.gameCarry.toFixed(1)} yds (expected ${result.expectedCarry.toFixed(1)}) [${carryDiff > 0 ? '+' : ''}${carryDiff.toFixed(1)}]`);
                console.log(`  Roll:  ${result.gameRoll.toFixed(1)} yds (expected ${result.expectedRoll.toFixed(1)}) [${rollDiff > 0 ? '+' : ''}${rollDiff.toFixed(1)}]`);
                console.log(`  Total: ${result.gameTotal.toFixed(1)} yds (expected ${result.expectedTotal.toFixed(1)}) [${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}]`);

                // Check if within tolerance (¬±2 yards total)
                if (Math.abs(totalDiff) > 2.0) {
                    console.log(`  ‚ùå FAIL: Total difference ${totalDiff.toFixed(1)} yds exceeds ¬±2 yard tolerance`);
                    allPassing = false;
                } else {
                    console.log(`  ‚úì PASS`);
                }
                console.log('');
            });

            console.log('========================================');
            if (allPassing) {
                console.log('‚úì ALL TESTS PASSED');
            } else {
                console.log('‚ùå SOME TESTS FAILED');
            }
            console.log('========================================\n');
        }
        */

        function createCourse() {
            // Determine terrain size based on hole
            const hole = HOLES[currentHoleIndex];
            const isStadium = hole.type === 'stadium';
            const stadiumGreenRadius = 11.5;
            const stadiumCollarOuter = 15.5;
            const stadiumFairwayRadius = 34;
            const stadiumDesertRadius = 52;
            const stadiumBermRadius = 68;
            if (hole.type === 'long-par5') {
                // Pines hole - dogleg right with water hazards
                window.hole5WaterPolygons = [
                    // First water hazard - right side of landing area (around 180-250 yards)
                    [
                        {x: 40, z: -165},  // ~180 yards from tee
                        {x: 70, z: -168},
                        {x: 85, z: -185},
                        {x: 88, z: -220},  // ~240 yards from tee
                        {x: 75, z: -238},
                        {x: 50, z: -235},
                        {x: 35, z: -210},
                        {x: 36, z: -180}
                    ],
                    // Second water hazard - right side near green (around 420-470 yards)
                    [
                        {x: 55, z: -385},  // ~420 yards from tee
                        {x: 85, z: -388},
                        {x: 95, z: -410},
                        {x: 90, z: -435},  // ~475 yards from tee
                        {x: 70, z: -440},
                        {x: 45, z: -430},
                        {x: 40, z: -405},
                        {x: 48, z: -390}
                    ]
                ];
            } else {
                window.hole5WaterPolygons = null;
            }
            if (hole.type === 'rockwiga' && hole.waterPolygons && hole.waterPolygons.length > 0) {
                window.rockwigaWaterPolygons = hole.waterPolygons;
            } else if (hole.type === 'rockwiga') {
                window.rockwigaWaterPolygons = null;
            } else {
                window.rockwigaWaterPolygons = null;
            }
            let terrainSize;
            if (hole.type === 'dogleg-left') {
                terrainSize = { width: 500, length: 500, segmentsW: 150, segmentsL: 150 };
            } else if (hole.type === 'dogleg-right') {
                terrainSize = { width: 400, length: 700, segmentsW: 120, segmentsL: 200 };
            } else if (hole.type === 'island-hopping') {
                terrainSize = { width: 300, length: 700, segmentsW: 150, segmentsL: 350 };
            } else if (hole.type === 'long-par5') {
                terrainSize = { width: 260, length: 1000, segmentsW: 180, segmentsL: 400 };
            } else if (hole.type === 'rockwiga') {
                terrainSize = hole.terrainSize || { width: 360, length: 720, segmentsW: 180, segmentsL: 260 };
            } else if (hole.type === 'stadium') {
                terrainSize = { width: 260, length: 320, segmentsW: 160, segmentsL: 200 };
            } else {
                // Straight hole
                terrainSize = { width: 200, length: 300, segmentsW: 200, segmentsL: 300 };
            }

            // Main terrain (fairway and rough) - size adapts to hole
            const terrainGeometry = new THREE.PlaneGeometry(terrainSize.width, terrainSize.length, terrainSize.segmentsW, terrainSize.segmentsL);
            const vertices = terrainGeometry.attributes.position.array;

            // DEBUG: Log terrain info for island-hopping
            if (hole.type === 'island-hopping') {
                console.log('=== TERRAIN DEBUG ===');
                console.log('Terrain size:', terrainSize);
                console.log('Terrain extends from X:', -terrainSize.width/2, 'to', terrainSize.width/2);
                console.log('Terrain extends from Z:', -terrainSize.length/2, 'to', terrainSize.length/2);
                console.log('Island centers:');
                hole.islands.forEach((island, idx) => {
                    console.log(`  Island ${idx+1}: center=(${island.center.x}, ${island.center.z}), radius=${island.radius}`);
                });
            }

            // Create elevation - different logic for island-hopping vs regular holes
            let islandVertexCounts = [0, 0, 0]; // Track vertices per island

            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];

                let height = 0;

                if (hole.type === 'island-hopping') {
                    // Island-hopping terrain: water at -5, islands at 0
                    height = -5; // Default: water

                    // Check each island
                    for (let islandIdx = 0; islandIdx < hole.islands.length; islandIdx++) {
                        const island = hole.islands[islandIdx];
                        const distToIslandCenter = Math.sqrt(
                            Math.pow(x - island.center.x, 2) +
                            Math.pow(z - island.center.z, 2)
                        );

                        if (distToIslandCenter < island.radius) {
                            // Inside island - flat at sea level
                            height = 0;
                            islandVertexCounts[islandIdx]++;

                            // Slight edge slope to water (smooth transition at island edge)
                            const edgeDistance = island.radius - distToIslandCenter;
                            if (edgeDistance < 2) {
                                height = -2.5 * (1 - edgeDistance / 2); // Slope down to water
                            }
                        }
                    }
                } else if (hole.type === 'stadium') {
                    const dx = x - PIN_POSITION.x;
                    const dz = z - PIN_POSITION.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < stadiumGreenRadius) {
                        height = -0.2 + Math.sin(x * 0.4) * 0.03 + Math.cos(z * 0.35) * 0.03;
                    } else if (dist < stadiumCollarOuter) {
                        height = -0.22 + Math.sin(x * 0.2 + z * 0.15) * 0.02;
                    } else if (dist < stadiumFairwayRadius) {
                        height = -0.24 + Math.sin(x * 0.12 + z * 0.1) * 0.02;
                    } else if (dist < stadiumDesertRadius) {
                        height = -0.27 + Math.sin(x * 0.08 + z * 0.06) * 0.03;
                    } else if (dist < stadiumBermRadius) {
                        const t = (dist - stadiumDesertRadius) / (stadiumBermRadius - stadiumDesertRadius);
                        height = -0.27 + t * 1.6;
                    } else {
                        height = 1.2;
                    }

                    if (z > -6 && z < 6 && Math.abs(x) < 4) {
                        height = 3;
                    }
                } else {
                    // Standard terrain generation for straight/dogleg holes
                    if (hole.type === 'long-par5') {
                        const approachStartZ = PIN_POSITION.z + 40;
                        const approachEndZ = PIN_POSITION.z + 20;
                        const fairwayEndZ = approachStartZ;

                        // Tee area (elevated)
                        if (z > -10 && z < 10) {
                            height = 3 - Math.abs(z) * 0.3;
                        }
                        // Slope from tee to fairway
                        else if (z >= -30 && z <= -10) {
                            height = 3 - (Math.abs(z) - 10) * 0.1;
                        }
                        // Fairway (extended with gentle downslope and undulations)
                        else if (z > fairwayEndZ && z <= -30) {
                            const fairwayLength = Math.max(1, Math.abs(fairwayEndZ) - 30);
                            const fairwayProgress = Math.min(1, (Math.abs(z) - 30) / fairwayLength);
                            height = 1 - fairwayProgress * 1.6;

                            // Natural undulations
                            height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                            height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                            height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                            // Add mounding in rough areas
                            const nearestBand = getLongPar5NearestBand(x, z, hole);
                            const distFromFairwayCenter = nearestBand.dist;
                            const bandHalfWidth = nearestBand.band.fairwayHalfWidth;
                            if (distFromFairwayCenter > bandHalfWidth) {
                                const roughOffset = distFromFairwayCenter - bandHalfWidth;
                                height += Math.sin(z * 0.4 + x * 0.2) * roughOffset * 0.15;
                                height += Math.cos(x * 0.6 - z * 0.15) * (roughOffset * 0.1);
                                height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                                const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                                if (moundNoise > 0.3) {
                                    height += moundNoise * 0.8;
                                }
                            }
                        }
                        // Approach to green with protective mounding
                        else if (z > approachEndZ && z <= approachStartZ) {
                            height = -0.2;

                            const distToGreen = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                            if (distToGreen > 10 && distToGreen < 18) {
                                const angle = Math.atan2(x - PIN_POSITION.x, z - PIN_POSITION.z);
                                const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5;
                                height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                                height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                            }

                            height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                            height += Math.cos(x * 0.8 - z * 0.4) * 0.25;
                        }
                        // Green area
                        else {
                            const distToPin = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                            if (distToPin < 10) {
                                height = -0.2 + Math.sin(x * 0.5) * 0.05 + Math.cos((z - PIN_POSITION.z) * 0.4) * 0.05;
                            } else {
                                height = -0.2;
                            }
                        }
                    } else if (hole.type === 'rockwiga') {
                        const teeHeight = hole.teeHeight || 3;
                        const greenHeight = hole.greenHeight !== undefined ? hole.greenHeight : -0.2;
                        const approachStartZ = PIN_POSITION.z + 40;
                        const approachEndZ = PIN_POSITION.z + 20;
                        const fairwayEndZ = approachStartZ;

                        if (z > -10 && z < 10) {
                            height = teeHeight - Math.abs(z) * 0.3;
                        } else if (z >= -30 && z <= -10) {
                            height = teeHeight - (Math.abs(z) - 10) * 0.1;
                        } else if (z > fairwayEndZ && z <= -30) {
                            const fairwayLength = Math.max(1, Math.abs(fairwayEndZ) - 30);
                            const fairwayProgress = Math.min(1, (Math.abs(z) - 30) / fairwayLength);
                            const fairwayStartHeight = teeHeight - 2;
                            const fairwayDrop = fairwayStartHeight - greenHeight + 0.4;
                            height = fairwayStartHeight - fairwayProgress * fairwayDrop;

                            height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                            height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                            height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                            const projection = getTeeToPinProjection(x, z, hole);
                            const distFromFairway = projection.dist;
                            const fairwayHalfWidth = hole.fairwayHalfWidth || 22;
                            if (distFromFairway > fairwayHalfWidth) {
                                const roughOffset = distFromFairway - fairwayHalfWidth;
                                height += Math.sin(z * 0.4 + x * 0.2) * roughOffset * 0.15;
                                height += Math.cos(x * 0.6 - z * 0.15) * (roughOffset * 0.1);
                                height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                                const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                                if (moundNoise > 0.3) {
                                    height += moundNoise * 0.8;
                                }
                            }

                            // Bunker terrain depressions
                            if (hole.bunkers) {
                                for (const bk of hole.bunkers) {
                                    const bkr = bk.type === 'fairway' ? 12 : 4.2;
                                    const dBk = Math.sqrt(Math.pow(x - bk.x, 2) + Math.pow(z - bk.z, 2));
                                    if (dBk < bkr) {
                                        height -= 0.3 * (1 - dBk / bkr);
                                    }
                                }
                            }
                        } else if (z > approachEndZ && z <= approachStartZ) {
                            height = greenHeight;

                            const distToGreen = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                            if (distToGreen > 10 && distToGreen < 18) {
                                const angle = Math.atan2(x - PIN_POSITION.x, z - PIN_POSITION.z);
                                const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5;
                                height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                                height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                            }

                            height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                            height += Math.cos(x * 0.8 - z * 0.4) * 0.25;

                            // Bunker terrain depressions near green
                            if (hole.bunkers) {
                                for (const bk of hole.bunkers) {
                                    const bkr = bk.type === 'fairway' ? 12 : 4.2;
                                    const dBk = Math.sqrt(Math.pow(x - bk.x, 2) + Math.pow(z - bk.z, 2));
                                    if (dBk < bkr) {
                                        height -= 0.3 * (1 - dBk / bkr);
                                    }
                                }
                            }
                        } else {
                            const distToPin = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                            if (distToPin < 10) {
                                height = greenHeight + Math.sin(x * 0.5) * 0.05 + Math.cos((z - PIN_POSITION.z) * 0.4) * 0.05;
                            } else {
                                height = greenHeight;
                            }
                        }
                    } else {
                        // Tee area (elevated)
                        if (z > -10 && z < 10) {
                            height = 3 - Math.abs(z) * 0.3;
                        }
                        // Slope from tee to fairway
                        else if (z >= -30 && z <= -10) {
                            height = 3 - (Math.abs(z) - 10) * 0.1;
                        }
                        // Fairway (slight downslope with natural undulations)
                        else if (z > -110 && z <= -30) {
                            height = 1 - ((Math.abs(z) - 30) / 80) * 1.5;

                            // Multiple layers of natural undulations for organic look
                            height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                            height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                            height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                            // Random-looking hills using multiple frequencies
                            height += Math.sin(x * 0.7) * Math.cos(z * 0.1) * 0.35;
                            height += Math.cos(x * 0.12 + z * 0.18) * 0.25;

                            // Irregular mounds on the sides (rough areas)
                            if (Math.abs(x) > 12) {
                                const distFromFairway = Math.abs(x) - 12;
                                // Create irregular mounding
                                height += Math.sin(z * 0.4 + x * 0.2) * distFromFairway * 0.15;
                                height += Math.cos(x * 0.6 - z * 0.15) * (distFromFairway * 0.1);
                                height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                                // Add some dramatic mounds in rough
                                const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                                if (moundNoise > 0.3) {
                                    height += moundNoise * 0.8;
                                }
                            }
                        }
                        // Approach to green with protective mounding
                        else if (z > -125 && z <= -110) {
                            height = -0.2;

                            // Greenside mounds (irregular and natural)
                            const distToGreen = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                            if (distToGreen > 10 && distToGreen < 16) {
                                // Create raised mounding around green with irregular pattern
                                const angle = Math.atan2(x, z + 118.872);
                                const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5; // Vary by position
                                height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                                height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                                height += Math.sin(x * 1.1) * Math.cos((z + 118.872) * 0.9) * 0.5;
                            }

                            // Natural undulations around green
                            height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                            height += Math.cos(x * 0.8 - z * 0.4) * 0.25;
                        }
                        // Green area (subtle undulation, not completely flat)
                        else {
                            const distToPin = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));

                            if (distToPin < 10) {
                                // Green itself with very subtle breaks (same as backup)
                                height = -0.2 + Math.sin(x * 0.5) * 0.05 + Math.cos((z - PIN_POSITION.z) * 0.4) * 0.05;
                            } else {
                                // Beyond green
                                height = -0.2;
                            }
                        }
                    }
                }

                vertices[i + 2] = height;
            }

            // DEBUG: Log green vertex count
            if (window.greenVertexCount) {
                console.log(`Green vertices set to height 0: ${window.greenVertexCount}`);
            }

            // DEBUG: Log vertex counts per island
            if (hole.type === 'island-hopping') {
                console.log('Vertices per island:');
                islandVertexCounts.forEach((count, idx) => {
                    console.log(`  Island ${idx+1}: ${count} vertices`);
                });

                // DEBUG: Check actual vertex heights for each island
                console.log('Checking vertex heights for islands:');
                let island2Count = 0;
                let island3Count = 0;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 1];
                    const height = vertices[i + 2];

                    // Check if this vertex is near island 2 center
                    const distToIsland2 = Math.sqrt(Math.pow(x - 0, 2) + Math.pow(z - (-114.3), 2));
                    if (distToIsland2 < 10) {
                        if (island2Count < 5) { // Log first 5
                            console.log(`  Near Island 2 center: x=${x.toFixed(1)}, z=${z.toFixed(1)}, height=${height.toFixed(2)}`);
                        }
                        island2Count++;
                    }

                    // Check if this vertex is near island 3 center
                    const distToIsland3 = Math.sqrt(Math.pow(x - 0, 2) + Math.pow(z - (-228.6), 2));
                    if (distToIsland3 < 10) {
                        if (island3Count < 5) { // Log first 5
                            console.log(`  Near Island 3 center: x=${x.toFixed(1)}, z=${z.toFixed(1)}, height=${height.toFixed(2)}`);
                        }
                        island3Count++;
                    }
                }
                console.log(`  Found ${island2Count} vertices near Island 2 center`);
                console.log(`  Found ${island3Count} vertices near Island 3 center`);
            }

            terrainGeometry.computeVertexNormals();

            // Apply vertex colors based on fairway/rough zones with organic transitions
            const colors = [];
            const positions = terrainGeometry.attributes.position;

            // DEBUG: Track colored vertices per island
            let coloredVertices = [0, 0, 0];

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // Remember geometry is rotated

                let color = new THREE.Color();

                if (hole.type === 'island-hopping') {
                    // Island-hopping coloring: water = cyan, islands = fairway/rough
                    color.setHex(0x00CED1); // Default: cyan water

                    // Check each island
                    for (let islandIdx = 0; islandIdx < hole.islands.length; islandIdx++) {
                        const island = hole.islands[islandIdx];
                        const distToIslandCenter = Math.sqrt(
                            Math.pow(x - island.center.x, 2) +
                            Math.pow(z - island.center.z, 2)
                        );

                        if (distToIslandCenter < island.radius) {
                            // Inside island
                            coloredVertices[islandIdx]++;
                            const roughRingStart = island.radius - 9.144; // 10 yards = 9.144m from edge

                            if (distToIslandCenter < roughRingStart) {
                                // Fairway (center of island)
                                const variation = (Math.sin(x * 0.2 + z * 0.1) * 0.5 + 0.5) * 0.05;
                                color.setHex(0x4a9d5f);
                                color.r += variation;
                                color.g += variation;
                            } else {
                                // Rough ring (outer 10 yards)
                                const blend = (distToIslandCenter - roughRingStart) / (island.radius - roughRingStart);
                                const fairwayColor = new THREE.Color(0x4a9d5f);
                                const roughColor = new THREE.Color(0x3a7d44);
                                color.lerpColors(fairwayColor, roughColor, blend);
                            }
                        }
                    }
                } else if (hole.type === 'stadium') {
                    const dx = x - PIN_POSITION.x;
                    const dz = z - PIN_POSITION.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < stadiumGreenRadius) {
                        color.setHex(0x5cb574);
                    } else if (dist < stadiumCollarOuter) {
                        color.setHex(0x4a9d5f);
                    } else if (dist < stadiumFairwayRadius) {
                        color.setHex(0x3f8f55);
                    } else if (dist < stadiumDesertRadius) {
                        const variation = (Math.sin(x * 0.2 + z * 0.15) * 0.5 + 0.5) * 0.08;
                        color.setHex(0xd6c39a);
                        color.r += variation;
                        color.g += variation * 0.6;
                    } else {
                        color.setHex(0x3a7d44);
                    }
                } else {
                    // Standard fairway/rough coloring for straight/dogleg holes
                    // Add complex noise to edge boundaries for very organic look
                    const noise1 = Math.sin(z * 0.6 + x * 0.2) * 1.2;
                    const noise2 = Math.cos(z * 0.35 - x * 0.15) * 0.9;
                    const noise3 = Math.sin(z * 0.8 + x * 0.5) * 0.6;
                    const totalNoise = noise1 + noise2 + noise3;

                    let fairwayEdge = 12 + totalNoise;
                    let roughEdge = 20 + totalNoise * 0.7;
                    let distFromFairwayCenter;

                    // Check if point is in water (for Hole 4 / Hole 5)
                    let isInWater = false;
                    if (hole.type === 'dogleg-right' && window.hole4WaterPolygon) {
                        isInWater = isPointInPolygon(x, z, window.hole4WaterPolygon);
                    } else if (hole.type === 'long-par5' && window.hole5WaterPolygons) {
                        isInWater = window.hole5WaterPolygons.some(polygon => isPointInPolygon(x, z, polygon));
                    } else if (hole.type === 'rockwiga' && window.rockwigaWaterPolygons) {
                        isInWater = window.rockwigaWaterPolygons.some(polygon => isPointInPolygon(x, z, polygon));
                    }

                    if (hole.type === 'long-par5') {
                        const inClearing = isInLongPar5Clearing(x, z, hole);
                        let inFairway = inClearing;
                        let inLightRough = false;

                        if (!inClearing) {
                            const bands = getLongPar5PathBands(z, hole);
                            for (const band of bands) {
                                const dist = Math.abs(x - band.centerX);
                                const bandFairwayEdge = band.fairwayHalfWidth + totalNoise;
                                const bandRoughEdge = band.roughHalfWidth + totalNoise * 0.7;

                                if (dist < bandFairwayEdge) {
                                    inFairway = true;
                                    break;
                                }

                                if (dist < bandRoughEdge) {
                                    inLightRough = true;
                                }
                            }
                        }

                        if (isInWater) {
                            color.setHex(0x4A90E2); // Blue water
                        } else if (inFairway) {
                            const variation = (Math.sin(x * 0.2 + z * 0.1) * 0.5 + 0.5) * 0.05;
                            color.setHex(0x4a9d5f);
                            color.r += variation;
                            color.g += variation;
                        } else if (inLightRough) {
                            const fairwayColor = new THREE.Color(0x4a9d5f);
                            const lightRoughColor = new THREE.Color(0x3a7d44);
                            color.lerpColors(fairwayColor, lightRoughColor, 0.6);
                        } else {
                            color.setHex(0x2d5a28);
                        }
                    } else if (hole.type === 'rockwiga') {
                        const projection = getTeeToPinProjection(x, z, hole);
                        let fairwayEdge = (hole.fairwayHalfWidth || 22) + totalNoise;
                        let roughEdge = (hole.roughHalfWidth || 42) + totalNoise * 0.7;

                        if (hole.landingZoneYards) {
                            const landingMeters = hole.landingZoneYards * 0.9144;
                            const distAlong = projection.t * projection.length;
                            if (Math.abs(distAlong - landingMeters) < (hole.landingZoneRadius || 30)) {
                                const boost = hole.landingZoneBoost || 6;
                                fairwayEdge += boost;
                                roughEdge += boost * 0.6;
                            }
                        }

                        // Check if point is in a bunker area
                        let isInBunker = false;
                        if (hole.bunkers) {
                            for (const bk of hole.bunkers) {
                                const bkr = bk.type === 'fairway' ? 12 : 4.2;
                                const dBk = Math.sqrt(Math.pow(x - bk.x, 2) + Math.pow(z - bk.z, 2));
                                if (dBk < bkr) {
                                    isInBunker = true;
                                    break;
                                }
                            }
                        }

                        if (isInWater) {
                            color.setHex(0x4A90E2); // Blue water
                        } else if (isInBunker) {
                            const variation = 0.05 + Math.random() * 0.1;
                            color.setRGB(0.867 - variation, 0.788 - variation, 0.596 - variation);
                        } else if (projection.dist < fairwayEdge) {
                            const variation = (Math.sin(x * 0.2 + z * 0.1) * 0.5 + 0.5) * 0.05;
                            color.setHex(0x4a9d5f);
                            color.r += variation;
                            color.g += variation;
                        } else if (projection.dist < roughEdge) {
                            const fairwayColor = new THREE.Color(0x4a9d5f);
                            const lightRoughColor = new THREE.Color(0x3a7d44);
                            const blend = (projection.dist - fairwayEdge) / (roughEdge - fairwayEdge);
                            color.lerpColors(fairwayColor, lightRoughColor, blend);
                        } else {
                            color.setHex(0x2d5a28);
                        }
                    } else {
                        // Calculate distance from fairway centerline based on hole type
                        if (hole.type === 'dogleg-left') {
                            // Dogleg left: smooth curve from tee to green at (-220, -220)
                            // Start curving gently from the tee
                            const totalDistance = 220; // Distance to green in Z
                            const progress = Math.min(1, Math.abs(z) / totalDistance);

                            // Smooth S-curve using easing function
                            const easeProgress = progress * progress * (3 - 2 * progress);
                            const fairwayCenterX = -easeProgress * 220; // Gradually curve left

                            distFromFairwayCenter = Math.abs(x - fairwayCenterX);
                            fairwayEdge = 22 + totalNoise; // Wider fairway for par 4
                            roughEdge = 38 + totalNoise * 0.7;
                        } else if (hole.type === 'dogleg-right') {
                            // Hole 4: Mitten-shaped fairway - bulges LEFT in middle, then comes back
                            const totalDistance = 330;
                            const progress = Math.min(1, Math.abs(z) / totalDistance);

                            // Create the mitten bulge: Goes left in middle section, returns to center at green
                            // Use sin wave to bulge out left in middle
                            let fairwayCenterX = 0;
                            if (progress < 0.6) {
                                // First 60% - bulge out to the left (mitten thumb)
                                const bulgeProgress = progress / 0.6; // 0 to 1 for first 60%
                                fairwayCenterX = -Math.sin(bulgeProgress * Math.PI) * 60; // Peak at -60 yards left
                            } else {
                                // Last 40% - curve back right to green at x=30
                                const returnProgress = (progress - 0.6) / 0.4; // 0 to 1 for last 40%
                                const currentBulge = -Math.sin(Math.PI) * 60; // Nearly 0
                                fairwayCenterX = currentBulge + returnProgress * 30; // Return to x=30
                            }

                            distFromFairwayCenter = Math.abs(x - fairwayCenterX);
                            fairwayEdge = 50 + totalNoise; // Wide fairway (100 yards)
                            roughEdge = 65 + totalNoise * 0.7;
                        } else {
                            // Straight hole - simple center corridor
                            distFromFairwayCenter = Math.abs(x);
                        }

                        // Water coloring
                        if (isInWater) {
                            color.setHex(0x4A90E2); // Blue water
                        }
                        // Fairway - center corridor with natural edges
                        else if (distFromFairwayCenter < fairwayEdge) {
                            // Slight color variation in fairway
                            const variation = (Math.sin(x * 0.2 + z * 0.1) * 0.5 + 0.5) * 0.05;
                            color.setHex(0x4a9d5f);
                            color.r += variation;
                            color.g += variation;
                        }
                        // Light rough (with natural transition)
                        else if (distFromFairwayCenter >= fairwayEdge && distFromFairwayCenter < roughEdge) {
                            // Blend between fairway and light rough
                            const blend = (distFromFairwayCenter - fairwayEdge) / (roughEdge - fairwayEdge);
                            const fairwayColor = new THREE.Color(0x4a9d5f);
                            const lightRoughColor = new THREE.Color(0x3a7d44);
                            color.lerpColors(fairwayColor, lightRoughColor, blend);
                        }
                        // Heavy rough (beyond edges)
                        else {
                            // Transition to heavy rough
                            const distIntoRough = Math.min((distFromFairwayCenter - roughEdge) / 10, 1);
                            const lightRoughColor = new THREE.Color(0x3a7d44);
                            const heavyRoughColor = new THREE.Color(0x2d5a28);
                            color.lerpColors(lightRoughColor, heavyRoughColor, distIntoRough);
                        }
                    }
                }

                colors.push(color.r, color.g, color.b);
            }

            // DEBUG: Log colored vertex counts
            if (hole.type === 'island-hopping') {
                console.log('Colored vertices per island:');
                coloredVertices.forEach((count, idx) => {
                    console.log(`  Island ${idx+1}: ${count} colored vertices`);
                });
            }

            terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const terrainMaterial = new THREE.MeshLambertMaterial({
                map: isStadium ? sandTexture : fairwayTexture,
                color: isStadium ? 0xd6c39a : 0xffffff,
                vertexColors: true,
                side: THREE.DoubleSide
            });
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Tee box (darker, elevated platform)
            const teeGeometry = new THREE.BoxGeometry(6, 0.2, 8);
            const teeMaterial = new THREE.MeshLambertMaterial({
                map: dirtTexture,
                color: 0x2d5a3d  // Tint to keep darker appearance
            });
            teebox = new THREE.Mesh(teeGeometry, teeMaterial);
            teebox.position.set(0, 3, 0);
            teebox.receiveShadow = true;
            scene.add(teebox);

            // Green (simple visible circle mesh like the backup)
            const greenRadius = isStadium ? stadiumGreenRadius : 10;
            const greenGeometry = new THREE.CircleGeometry(greenRadius, 64);
            if (isStadium) {
                greenGeometry.scale(1.35, 0.85, 1);
            }
            const greenMaterial = new THREE.MeshLambertMaterial({
                color: 0x5cb574, // Brighter green
                side: THREE.DoubleSide
            });
            greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
            greenMesh.rotation.x = -Math.PI / 2;
            // Position green based on hole type
            const greenY = hole.type === 'island-hopping' ? 0.001 : -0.199; // Islands at 0, regular terrain at -0.199
            greenMesh.position.set(PIN_POSITION.x, greenY, PIN_POSITION.z);
            greenMesh.receiveShadow = true;
            scene.add(greenMesh);

            console.log('=== GREEN MESH ===');
            console.log('Green radius:', greenRadius, 'm');
            console.log('Green position:', PIN_POSITION.x, 0, PIN_POSITION.z);

            if (isStadium) {
                createStadiumInfield(stadiumGreenRadius, stadiumCollarOuter, stadiumFairwayRadius);
            }

            // For island-hopping holes, create explicit island mesh objects
            if (hole.type === 'island-hopping') {
                console.log('Creating explicit island meshes...');
                hole.islands.forEach((island, idx) => {
                    const roughRingWidth = 9.144; // 10 yards
                    const fairwayRadius = island.radius - roughRingWidth;
                    const greenRadius = 10; // Green is 10m radius

                    // All islands: Create full fairway circle (green will sit on top for island 3)
                    const fairwayGeometry = new THREE.CircleGeometry(fairwayRadius, 64);
                    const fairwayMaterial = new THREE.MeshLambertMaterial({
                        map: fairwayTexture,
                        color: 0x4a9d5f,  // Fairway green tint
                        side: THREE.DoubleSide
                    });
                    const fairwayMesh = new THREE.Mesh(fairwayGeometry, fairwayMaterial);
                    fairwayMesh.rotation.x = -Math.PI / 2;
                    fairwayMesh.position.set(island.center.x, 0, island.center.z);
                    fairwayMesh.receiveShadow = true;
                    fairwayMesh.castShadow = false;
                    scene.add(fairwayMesh);
                    islandMeshes.push(fairwayMesh);

                    // Create rough ring (outer ring) for all islands
                    const roughRingGeometry = new THREE.RingGeometry(fairwayRadius, island.radius, 64);
                    const roughMaterial = new THREE.MeshLambertMaterial({
                        map: roughTexture,
                        color: 0x3a7d44,  // Rough dark green tint
                        side: THREE.DoubleSide
                    });
                    const roughRingMesh = new THREE.Mesh(roughRingGeometry, roughMaterial);
                    roughRingMesh.rotation.x = -Math.PI / 2;
                    roughRingMesh.position.set(island.center.x, 0, island.center.z);
                    roughRingMesh.receiveShadow = true;
                    roughRingMesh.castShadow = false;
                    scene.add(roughRingMesh);
                    islandMeshes.push(roughRingMesh);

                    console.log(`  Created island ${idx+1} with fairway (r=${fairwayRadius.toFixed(1)}) and rough ring at (${island.center.x}, ${island.center.z})`);
                });
            }

            if (hole.type === 'stadium') {
                createStadiumStands();
            }

            // Create bunkers based on hole type
            console.log('Creating bunkers for hole type:', hole.type, 'Hole number:', hole.number);
            if (hole.type === 'dogleg-left') {
                // Par 4: Add strategic fairway bunkers at dogleg corner (~230 yards)
                createFairwayBunker(-180, -210);  // Left side of dogleg
                createFairwayBunker(-120, -200);  // Right side of dogleg
                createGreenBunker(PIN_POSITION.x - 12, PIN_POSITION.z);  // Left of green
                createGreenBunker(PIN_POSITION.x + 12, PIN_POSITION.z + 5);  // Right of green
            } else if (hole.type === 'dogleg-right') {
                console.log('Hole 4 detected - creating water hazard and bunkers');
                // Hole 4: Large water hazard on left - shifted left to leave fairway strip on right
                const waterPoints = [
                    {x: -120, z: -30},     // Top of water - shifted left
                    {x: -130, z: -60},
                    {x: -135, z: -100},
                    {x: -138, z: -140},
                    {x: -135, z: -180},
                    {x: -125, z: -220},   // Bottom of water
                    {x: -100, z: -250},
                    {x: -70, z: -260},
                    {x: -40, z: -270},    // Right edge pulled back
                    {x: -30, z: -260},
                    {x: -35, z: -220},
                    {x: -40, z: -180},
                    {x: -35, z: -140},
                    {x: -30, z: -100},
                    {x: -45, z: -60},
                    {x: -70, z: -35}      // Back to top
                ];
                console.log('About to call createWaterHazard with', waterPoints.length, 'points');
                console.log('typeof createWaterHazard:', typeof createWaterHazard);
                createWaterHazard(waterPoints);

                // Store water polygon globally for terrain coloring
                window.hole4WaterPolygon = waterPoints;

                // Fairway bunker in landing zone (upper middle area)
                createFairwayBunker(-20, -120);

                // Greenside bunkers
                createGreenBunker(PIN_POSITION.x + 15, PIN_POSITION.z - 10);   // Right of green
            } else if (hole.type === 'long-par5') {
                if (window.hole5WaterPolygons) {
                    window.hole5WaterPolygons.forEach(points => createWaterHazard(points));
                }

                // Greenside bunker on the left
                createGreenBunker(PIN_POSITION.x - 12, PIN_POSITION.z + 6);
            } else if (hole.type === 'rockwiga') {
                if (window.rockwigaWaterPolygons) {
                    window.rockwigaWaterPolygons.forEach(points => createWaterHazard(points));
                }
                if (hole.bunkers) {
                    for (const bk of hole.bunkers) {
                        if (bk.type === 'fairway') {
                            createFairwayBunker(bk.x, bk.z);
                        } else {
                            createGreenBunker(bk.x, bk.z);
                        }
                    }
                }
            } else if (hole.type === 'stadium') {
                // Coliseum-style par 3: larger sweeping bunkers
                createGreenBunker(PIN_POSITION.x - 9, PIN_POSITION.z + 10);
                createGreenBunker(PIN_POSITION.x + 9, PIN_POSITION.z + 10);
                createGreenBunker(PIN_POSITION.x - 14, PIN_POSITION.z - 6);
                createGreenBunker(PIN_POSITION.x + 14, PIN_POSITION.z - 6);
            } else {
                // Par 3: Greenside bunkers only
                createGreenBunker(BUNKER_LEFT_POSITION.x, BUNKER_LEFT_POSITION.z);
                createGreenBunker(BUNKER_RIGHT_POSITION.x, BUNKER_RIGHT_POSITION.z);
            }

            // Cup (hole)
            const cupGeometry = new THREE.CylinderGeometry(0.054, 0.054, 0.1, 16); // 4.25 inch diameter
            const cupMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            cup = new THREE.Mesh(cupGeometry, cupMaterial);
            // Position cup based on hole type - slightly below green surface so rim is flush
            const rockwigaGreenH = (hole.type === 'rockwiga' && hole.greenHeight !== undefined) ? hole.greenHeight : -0.2;
            const cupY = hole.type === 'island-hopping' ? -0.049 : (rockwigaGreenH - 0.049);
            cup.position.set(PIN_POSITION.x, cupY, PIN_POSITION.z);
            scene.add(cup);

            // Flagstick
            const poleGeometry = new THREE.CylinderGeometry(0.01, 0.01, 2.1, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1.05;

            const flagGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const flagMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.15, 1.9, 0);

            flagstick = new THREE.Group();
            flagstick.add(pole);
            flagstick.add(flag);
            flagstick.position.copy(PIN_POSITION);
            // Position flagstick base based on hole type
            const flagstickY = hole.type === 'island-hopping' ? 0 : rockwigaGreenH;
            flagstick.position.y = flagstickY;
            scene.add(flagstick);

            // Gimmie circles (5ft and 10ft)
            const ft5InMeters = 5 * 0.3048; // 1.524m
            const ft10InMeters = 10 * 0.3048; // 3.048m

            // 5ft circle (1 putt) - semi-transparent yellow
            const circle5Geometry = new THREE.RingGeometry(ft5InMeters - 0.05, ft5InMeters, 64);
            const circle5Material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide
            });
            gimmieCircle5ft = new THREE.Mesh(circle5Geometry, circle5Material);
            gimmieCircle5ft.rotation.x = -Math.PI / 2;
            // Position gimmie circles based on hole type (same as green)
            const gimmieY = hole.type === 'island-hopping' ? 0.002 : (rockwigaGreenH + 0.005); // Slightly above green
            gimmieCircle5ft.position.set(PIN_POSITION.x, gimmieY, PIN_POSITION.z);
            gimmieCircle5ft.visible = false; // Hidden by default
            scene.add(gimmieCircle5ft);

            // 10ft circle (2 putts) - semi-transparent orange
            const circle10Geometry = new THREE.RingGeometry(ft10InMeters - 0.05, ft10InMeters, 64);
            const circle10Material = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            gimmieCircle10ft = new THREE.Mesh(circle10Geometry, circle10Material);
            gimmieCircle10ft.rotation.x = -Math.PI / 2;
            gimmieCircle10ft.position.set(PIN_POSITION.x, gimmieY, PIN_POSITION.z);
            gimmieCircle10ft.visible = false; // Hidden by default
            scene.add(gimmieCircle10ft);

            // Tee markers
            createTeeMarker(-1, 3.15, 3, 0xff0000);
            createTeeMarker(1, 3.15, 3, 0xff0000);

            // Cache ground objects for raycasts (avoids per-frame array rebuilds)
            refreshGroundObjectsCache();
        }

        function createStadiumStands() {
            const standGroup = new THREE.Group();
            const centerX = PIN_POSITION.x;
            const centerZ = PIN_POSITION.z;
            const baseY = -0.2;
            const standMaterial = new THREE.MeshLambertMaterial({ color: 0xf3f1ea });
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const segments = 28;

            const tiers = [
                { radius: 70, height: 5.5, depth: 8, yOffset: 0 },
                { radius: 84, height: 5, depth: 9, yOffset: 5.5 }
            ];

            tiers.forEach((tier) => {
                const arcLength = (2 * Math.PI * tier.radius) / segments;
                const segmentWidth = arcLength * 0.92;
                const geometry = new THREE.BoxGeometry(segmentWidth, tier.height, tier.depth);

                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * (tier.radius + tier.depth / 2);
                    const z = centerZ + Math.sin(angle) * (tier.radius + tier.depth / 2);
                    const y = baseY + tier.height / 2 + tier.yOffset;

                    const stand = new THREE.Mesh(geometry, standMaterial);
                    stand.position.set(x, y, z);
                    stand.rotation.y = -angle;
                    stand.castShadow = false;
                    stand.receiveShadow = true;
                    standGroup.add(stand);
                }
            });

            const roofTier = tiers[1];
            const roofArc = (2 * Math.PI * roofTier.radius) / segments;
            const roofWidth = roofArc * 0.9;
            const roofGeometry = new THREE.BoxGeometry(roofWidth, 0.6, roofTier.depth * 0.6);

            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * (roofTier.radius + roofTier.depth / 2 + 1.5);
                const z = centerZ + Math.sin(angle) * (roofTier.radius + roofTier.depth / 2 + 1.5);
                const y = baseY + roofTier.yOffset + roofTier.height + 0.3;

                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(x, y, z);
                roof.rotation.y = -angle;
                roof.castShadow = false;
                roof.receiveShadow = true;
                standGroup.add(roof);
            }

            scene.add(standGroup);
            stadiumMeshes.push(standGroup);
        }

        function createStadiumInfield(greenRadius, collarOuter, fairwayRadius) {
            const centerX = PIN_POSITION.x;
            const centerZ = PIN_POSITION.z;

            const fairwayGeometry = new THREE.CircleGeometry(fairwayRadius, 96);
            fairwayGeometry.scale(1.3, 0.95, 1);
            const fairwayMaterial = new THREE.MeshLambertMaterial({
                map: fairwayTexture || null,
                color: 0x4a9d5f,
                side: THREE.DoubleSide
            });
            const fairwayMesh = new THREE.Mesh(fairwayGeometry, fairwayMaterial);
            fairwayMesh.rotation.x = -Math.PI / 2;
            fairwayMesh.position.set(centerX, -0.2, centerZ + 6);
            fairwayMesh.receiveShadow = true;
            scene.add(fairwayMesh);
            stadiumMeshes.push(fairwayMesh);

            const collarGeometry = new THREE.RingGeometry(greenRadius * 1.02, collarOuter, 64);
            const collarMaterial = new THREE.MeshLambertMaterial({
                map: fairwayTexture || null,
                color: 0x4a9d5f,
                side: THREE.DoubleSide
            });
            const collarMesh = new THREE.Mesh(collarGeometry, collarMaterial);
            collarMesh.rotation.x = -Math.PI / 2;
            collarMesh.position.set(centerX, -0.19, centerZ);
            collarMesh.receiveShadow = true;
            scene.add(collarMesh);
            stadiumMeshes.push(collarMesh);
        }

        function createFairwayBunker(x, z) {
            // Larger fairway bunker - use CircleGeometry for proper UV mapping
            const bunkerRadius = 12;
            const bunkerGeometry = new THREE.CircleGeometry(bunkerRadius, 32);

            console.log('Creating fairway bunker, sandTexture available:', !!sandTexture);

            // Due to software rendering issues, always use color-based sand
            // Add vertex colors for visual variation
            const colors = [];
            const positions = bunkerGeometry.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                // Create subtle color variation to simulate sand texture
                const variation = 0.05 + Math.random() * 0.1;
                colors.push(0.867 - variation, 0.788 - variation, 0.596 - variation); // Sandy color with variation
            }

            bunkerGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const bunkerMaterial = new THREE.MeshLambertMaterial({
                color: 0xddc998,  // Sandy tan color
                vertexColors: true,  // Use vertex colors for variation
                side: THREE.DoubleSide
            });

            const bunker = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
            bunker.rotation.x = -Math.PI / 2;
            bunker.position.set(x, 0.05, z);
            bunker.receiveShadow = true;
            bunker.userData = { isBunker: true, radius: bunkerRadius };
            scene.add(bunker);
            bunkers.push(bunker);
        }

        function createGreenBunker(x, z) {
            // Greenside bunker - use ellipse for proper UV mapping
            const bunkerGeometry = new THREE.CircleGeometry(3.5, 32);
            bunkerGeometry.scale(1.2, 0.8, 1); // Make it elliptical

            console.log('Creating green bunker, sandTexture available:', !!sandTexture);

            // Due to software rendering issues, always use color-based sand
            // Add vertex colors for visual variation
            const colors = [];
            const positions = bunkerGeometry.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                // Create subtle color variation to simulate sand texture
                const variation = 0.05 + Math.random() * 0.1;
                colors.push(0.867 - variation, 0.788 - variation, 0.596 - variation); // Sandy color with variation
            }

            bunkerGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const bunkerMaterial = new THREE.MeshLambertMaterial({
                color: 0xddc998,  // Sandy tan color
                vertexColors: true,  // Use vertex colors for variation
                side: THREE.DoubleSide
            });

            const bunker = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
            bunker.rotation.x = -Math.PI / 2;
            bunker.rotation.z = -Math.PI / 2; // Orient along green
            bunker.position.set(x, -0.19, z);
            bunker.receiveShadow = true;
            bunker.userData = { isBunker: true, radius: 4.2 };
            scene.add(bunker);
            bunkers.push(bunker);
        }

        function createWaterHazard(points) {
            console.log('createWaterHazard called with', points.length, 'points');

            // Calculate center of water points to convert to local coordinates
            let centerX = 0, centerZ = 0;
            for (let point of points) {
                centerX += point.x;
                centerZ += point.z;
            }
            centerX /= points.length;
            centerZ /= points.length;
            console.log('Water center:', centerX, centerZ);

            // Create shape with LOCAL coordinates (relative to center)
            const shape = new THREE.Shape();
            const localPoints = points.map(p => ({
                x: p.x - centerX,
                z: p.z - centerZ
            }));

            shape.moveTo(localPoints[0].x, localPoints[0].z);
            for (let i = 1; i < localPoints.length; i++) {
                shape.lineTo(localPoints[i].x, localPoints[i].z);
            }
            shape.closePath();

            const waterGeometry = new THREE.ShapeGeometry(shape);
            const waterMaterial = new THREE.MeshBasicMaterial({
                color: 0x1E90FF,  // Bright blue
                side: THREE.DoubleSide
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.set(centerX, 0.2, centerZ);  // Position at center in world
            water.receiveShadow = true;
            scene.add(water);
            bunkers.push(water);

            console.log('Water hazard created at world position:', water.position);
        }

        function createTreeLine() {
            console.log('Creating trees...');
            let treeCount = 0;
            const hole = HOLES[currentHoleIndex];

            if (hole.type === 'dogleg-left') {
                // Par 4 dogleg left - trees follow the curved fairway edges

                // Right side trees - follow the inside of the curve (REDUCED FOR PERFORMANCE: 45 -> 15)
                for (let i = 0; i < 15; i++) {
                    const z = -5 - i * 15; // Increased spacing: 5 -> 15
                    if (z < -230) continue; // Stop before green

                    // Calculate fairway center at this z position
                    const totalDistance = 220;
                    const progress = Math.min(1, Math.abs(z) / totalDistance);
                    const easeProgress = progress * progress * (3 - 2 * progress);
                    const fairwayCenterX = -easeProgress * 220;

                    // Place trees on right edge of fairway (inside of curve)
                    const x = fairwayCenterX + 28 + Math.random() * 12;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Left side trees - follow the outside of the curve (REDUCED FOR PERFORMANCE: 45 -> 15)
                for (let i = 0; i < 15; i++) {
                    const z = -5 - i * 15; // Increased spacing: 5 -> 15
                    if (z < -230) continue; // Stop before green

                    // Calculate fairway center at this z position
                    const totalDistance = 220;
                    const progress = Math.min(1, Math.abs(z) / totalDistance);
                    const easeProgress = progress * progress * (3 - 2 * progress);
                    const fairwayCenterX = -easeProgress * 220;

                    // Place trees on left edge of fairway (outside of curve)
                    const x = fairwayCenterX - 28 - Math.random() * 12;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Behind green trees (REDUCED FOR PERFORMANCE: 20 -> 8)
                for (let i = 0; i < 8; i++) {
                    const x = PIN_POSITION.x - 25 + i * 2.5 + (Math.random() - 0.5) * 4;
                    const z = PIN_POSITION.z - 20 - Math.random() * 15;
                    const height = 10 + Math.random() * 5;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

            } else if (hole.type === 'dogleg-right') {
                // Hole 4: Trees along right edge following mitten bulge

                // Right side trees - follow the fairway edge (REDUCED FOR PERFORMANCE: 70 -> 20)
                for (let i = 0; i < 20; i++) {
                    const z = -5 - i * 16; // Increased spacing: 4.7 -> 16
                    if (z < -335) continue;

                    // Calculate fairway center at this z position (matches fairway logic)
                    const totalDistance = 330;
                    const progress = Math.min(1, Math.abs(z) / totalDistance);

                    let fairwayCenterX = 0;
                    if (progress < 0.6) {
                        const bulgeProgress = progress / 0.6;
                        fairwayCenterX = -Math.sin(bulgeProgress * Math.PI) * 60;
                    } else {
                        const returnProgress = (progress - 0.6) / 0.4;
                        const currentBulge = -Math.sin(Math.PI) * 60;
                        fairwayCenterX = currentBulge + returnProgress * 30;
                    }

                    // Place trees on right edge of fairway
                    const x = fairwayCenterX + 55 + Math.random() * 12;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Scattered trees beyond water on far left (REDUCED FOR PERFORMANCE: 40 -> 12)
                for (let i = 0; i < 12; i++) {
                    const z = -25 - i * 22; // Increased spacing: 6.5 -> 22
                    if (z < -290) continue;

                    // Trees beyond left edge of water
                    const x = -135 - Math.random() * 30;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Behind green trees (REDUCED FOR PERFORMANCE: 30 -> 10)
                for (let i = 0; i < 10; i++) {
                    const x = PIN_POSITION.x - 40 + i * 2.8 + (Math.random() - 0.5) * 6;
                    const z = PIN_POSITION.z - 18 - Math.random() * 22;
                    const height = 10 + Math.random() * 5;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

            } else if (hole.type === 'long-par5') {
                const endZ = PIN_POSITION.z - 18;
                const splitZ = getLongPar5SplitZ(hole);

                for (let z = -15; z > endZ; z -= 18) {
                    const groundY = 0;

                    if (z > splitZ) {
                        const band = getLongPar5PathBands(z, hole)[0];
                        const leftX = band.centerX - (band.fairwayHalfWidth + 22 + Math.random() * 10);
                        const rightX = band.centerX + (band.fairwayHalfWidth + 22 + Math.random() * 10);
                        const heightLeft = 9 + Math.random() * 6;
                        const heightRight = 9 + Math.random() * 6;

                        createTree(leftX, groundY, z, heightLeft);
                        treeCount++;
                        createTree(rightX, groundY, z, heightRight);
                        treeCount++;
                    } else {
                        const leftCenterX = getLongPar5LeftCenterX(z, hole);
                        const rightCenterX = getLongPar5RightCenterX(z, hole);
                        const leftBandWidth = hole.leftPathHalfWidth || 12;
                        const rightBandWidth = hole.rightPathHalfWidth || 22;

                        const leftOuterX = leftCenterX - (leftBandWidth + 22 + Math.random() * 10);
                        const rightOuterX = rightCenterX + (rightBandWidth + 22 + Math.random() * 10);
                        const heightLeft = 9 + Math.random() * 6;
                        const heightRight = 9 + Math.random() * 6;

                        createTree(leftOuterX, groundY, z, heightLeft);
                        treeCount++;
                        createTree(rightOuterX, groundY, z, heightRight);
                        treeCount++;

                        // Tree line between split fairways to keep paths distinct
                        const innerLeftX = leftCenterX + leftBandWidth + 10 + Math.random() * 6;
                        const innerRightX = rightCenterX - rightBandWidth - 10 - Math.random() * 6;
                        const innerGap = innerRightX - innerLeftX;

                        if (innerGap > 6 && Math.random() > 0.3) {
                            const midX = innerLeftX + innerGap * (0.4 + Math.random() * 0.2);
                            const heightMid = 9 + Math.random() * 6;
                            createTree(midX, groundY, z, heightMid);
                            treeCount++;
                        }
                    }

                    if (hole.leftClearing && Math.abs(z - hole.leftClearing.z) < hole.leftClearing.radiusZ * 0.9) {
                        const leftEdgeX = hole.leftClearing.x - hole.leftClearing.radiusX - 6 - Math.random() * 4;
                        const rightEdgeX = hole.leftClearing.x + hole.leftClearing.radiusX + 6 + Math.random() * 4;
                        const heightEdge = 9 + Math.random() * 6;
                        createTree(leftEdgeX, groundY, z, heightEdge);
                        treeCount++;
                        createTree(rightEdgeX, groundY, z, heightEdge);
                        treeCount++;
                    }
                }

                // Behind green trees
                for (let i = 0; i < 12; i++) {
                    const x = PIN_POSITION.x - 30 + i * 3 + (Math.random() - 0.5) * 6;
                    const z = PIN_POSITION.z - 22 - Math.random() * 26;
                    const height = 10 + Math.random() * 5;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

            } else if (hole.type === 'rockwiga') {
                const tee = hole.teePosition;
                const pin = hole.pinPosition;
                const dx = pin.x - tee.x;
                const dz = pin.z - tee.z;
                const length = Math.max(1, Math.sqrt(dx * dx + dz * dz));
                const nx = -dz / length;
                const nz = dx / length;
                const baseOffset = hole.treeLineOffset || 34;
                const stepCount = hole.treePairCount || 18;

                if (hole.treeDensity === 'surround') {
                    // Dense surrounding trees (e.g. uphill hole 8)
                    const midX = (tee.x + pin.x) / 2;
                    const midZ = (tee.z + pin.z) / 2;
                    const surroundRadius = length * 0.55;
                    for (let i = 0; i < stepCount * 2; i++) {
                        const angle = (i / (stepCount * 2)) * Math.PI * 2;
                        const r = surroundRadius + Math.random() * 12;
                        const tx = midX + Math.cos(angle) * r;
                        const tz = midZ + Math.sin(angle) * r;
                        const h = 9 + Math.random() * 6;
                        createTree(tx, 0, tz, h);
                        treeCount++;
                    }
                } else {
                    for (let i = 0; i < stepCount; i++) {
                        const t = 0.08 + (i / (stepCount - 1)) * 0.84;
                        const centerX = tee.x + dx * t;
                        const centerZ = tee.z + dz * t;
                        const spread = baseOffset + Math.random() * 10;
                        const heightLeft = 9 + Math.random() * 6;
                        const heightRight = 9 + Math.random() * 6;
                        const groundY = 0;

                        createTree(centerX + nx * spread, groundY, centerZ + nz * spread, heightLeft);
                        treeCount++;
                        createTree(centerX - nx * spread, groundY, centerZ - nz * spread, heightRight);
                        treeCount++;
                    }
                }

                // Behind green trees
                const behindGreenCount = hole.behindGreenTreeCount || 10;
                for (let i = 0; i < behindGreenCount; i++) {
                    const x = PIN_POSITION.x - 24 + i * (48 / Math.max(1, behindGreenCount - 1)) + (Math.random() - 0.5) * 6;
                    const z = PIN_POSITION.z - 18 - Math.random() * 20;
                    const height = 10 + Math.random() * 5;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

            } else if (hole.type === 'island-hopping') {
                // Island-hopping - palm trees on each island (REDUCED FOR PERFORMANCE: 5 -> 3 per island)
                for (let island of hole.islands) {
                    const palmCount = 3; // 3 palms per island

                    for (let i = 0; i < palmCount; i++) {
                        // Random angle around island
                        const angle = (i / palmCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;

                        // Place trees in rough area (between fairway edge and island edge)
                        const minDist = island.radius - 12; // Inside rough zone
                        const maxDist = island.radius - 5; // Away from water edge
                        const dist = minDist + Math.random() * (maxDist - minDist);

                        const x = island.center.x + Math.cos(angle) * dist;
                        const z = island.center.z + Math.sin(angle) * dist;
                        const height = 8 + Math.random() * 4; // 8-12m tall palms
                        const groundY = 0;

                        createPalmTree(x, groundY, z, height);
                        treeCount++;
                    }
                }

            } else if (hole.type === 'stadium') {
                // Stadium par 3: keep sightlines open, no trees inside the coliseum

            } else {
                // Par 3 - original straight tree layout

                // Left side trees (REDUCED FOR PERFORMANCE: 30 -> 10)
                for (let i = 0; i < 10; i++) {
                    const z = -10 - i * 24 + (Math.random() - 0.5) * 4; // Increased spacing: 8 -> 24
                    const x = -25 - Math.random() * 15;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Right side trees (REDUCED FOR PERFORMANCE: 30 -> 10)
                for (let i = 0; i < 10; i++) {
                    const z = -10 - i * 24 + (Math.random() - 0.5) * 4; // Increased spacing: 8 -> 24
                    const x = 25 + Math.random() * 15;
                    const height = 8 + Math.random() * 6;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }

                // Behind green trees (REDUCED FOR PERFORMANCE: 12 -> 5)
                for (let i = 0; i < 5; i++) {
                    const x = -30 + i * 5 + (Math.random() - 0.5) * 3;
                    const z = -130 - Math.random() * 10;
                    const height = 10 + Math.random() * 5;
                    const groundY = 0;
                    createTree(x, groundY, z, height);
                    treeCount++;
                }
            }

            console.log(`Total trees created: ${treeCount}`);
        }

        function createTree(x, y, z, height) {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkHeight = height * 0.4;
            const trunkRadius = 0.3 + Math.random() * 0.2;

            // Store tree data for collision detection
            trees.push({
                position: { x, y, z },
                radius: trunkRadius * 1.5,
                height: height
            });

            // Create trunk - cylinder origin is at center, so offset by half height
            // PERFORMANCE: Reduced segments from 8 to 5 for lower vertex count
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 5);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2; // Offset so bottom of cylinder is at y=0 in group space
            // PERFORMANCE: Shadows disabled
            trunk.castShadow = false;
            treeGroup.add(trunk);

            // Foliage (2 layers instead of 3 for better performance)
            const foliageColors = [0x2d5016, 0x3a6b1f];
            const foliageHeight = height * 0.6;

            for (let i = 0; i < 2; i++) {
                const coneHeight = foliageHeight * (1 - i * 0.15);
                const coneRadius = (height * 0.35) * (1 - i * 0.2);
                // PERFORMANCE: Reduced segments from 8 to 5 for lower vertex count
                const foliageGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 5);
                const foliageMaterial = new THREE.MeshLambertMaterial({
                    color: foliageColors[i],
                    flatShading: true
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + (i * coneHeight * 0.4);
                // PERFORMANCE: Shadows disabled
                foliage.castShadow = false;
                foliage.receiveShadow = false;
                treeGroup.add(foliage);
            }

            // Position the entire tree group at the ground height
            treeGroup.position.set(x, y, z);
            scene.add(treeGroup);
            treeMeshes.push(treeGroup);
        }

        function createPalmTree(x, y, z, height) {
            const treeGroup = new THREE.Group();

            // Trunk - tall and slender
            const trunkHeight = height * 0.7;
            const trunkRadius = 0.25;

            // Store tree data for collision detection
            trees.push({
                position: { x, y, z },
                radius: trunkRadius * 1.5,
                height: height
            });

            // Create trunk with slight taper
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B6F47 }); // Sandy brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Palm fronds - 6 fronds arranged in a circle
            const frondCount = 6;
            const frondLength = height * 0.4;
            const frondWidth = height * 0.15;
            const frondColor = 0x228B22; // Forest green

            for (let i = 0; i < frondCount; i++) {
                const angle = (i / frondCount) * Math.PI * 2;

                // Create frond as a flattened cone
                const frondGeometry = new THREE.ConeGeometry(frondWidth, frondLength, 4);
                const frondMaterial = new THREE.MeshLambertMaterial({
                    color: frondColor,
                    side: THREE.DoubleSide
                });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);

                // Position at top of trunk
                frond.position.y = trunkHeight;

                // Rotate to fan outward
                frond.rotation.z = Math.PI / 2.5; // Tilt outward
                frond.rotation.y = angle; // Arrange in circle

                frond.castShadow = true;
                treeGroup.add(frond);
            }

            // Position the entire tree group
            treeGroup.position.set(x, y, z);
            scene.add(treeGroup);
            treeMeshes.push(treeGroup);
        }

        function createTeeMarker(x, y, z, color) {
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshLambertMaterial({ color });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(x, y, z);
            marker.castShadow = true;
            scene.add(marker);
            teeMarkers.push(marker);
        }

        function createBall() {
            const geometry = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.6
            });
            ball = new THREE.Mesh(geometry, material);
            ball.castShadow = true;
            ball.receiveShadow = true;
            resetBallPosition();
            scene.add(ball);

            // Load players from localStorage
            const playersData = localStorage.getItem('golfPar3Players');
            window.golfPar3Players = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#4ade80' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('golfPar3CurrentPlayer') || '0');

            // Initialize each player's ball position and strokes
            // Calculate proper tee height
            const teeBoxSurfaceHeight = 3.1;
            const properTeeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            window.golfPar3Players.forEach(player => {
                if (!player.ballPosition) {
                    player.ballPosition = { x: TEE_POSITION.x, y: properTeeY, z: TEE_POSITION.z };
                }
                if (player.strokes === undefined) {
                    player.strokes = 0;
                }
                if (player.holed === undefined) {
                    player.holed = false;
                }
                if (!player.holeScores) {
                    player.holeScores = []; // Track score for each hole
                }
                if (player.currentHole === undefined) {
                    player.currentHole = 0; // All players start on hole 1
                }
            });

            // Load current player's state
            loadPlayerState();
            updatePlayerDisplay();

            console.log('Players:', window.golfPar3Players);

            // Initialize Steam Network if in multiplayer mode
            initNetworkMultiplayer();
        }

        // ==================== STEAM NETWORK MULTIPLAYER ====================

        async function initNetworkMultiplayer() {
            const gameMode = localStorage.getItem('golfGameMode');
            if (gameMode !== 'steam') {
                console.log('üìç Local game mode - network disabled');
                isNetworkGame = false;
                return;
            }

            console.log('üåê Steam multiplayer mode - initializing network...');

            if (typeof getSteamNetwork === 'undefined') {
                console.error('‚ùå SteamNetworkAdapter not loaded');
                return;
            }

            networkAdapter = getSteamNetwork();

            try {
                const available = await networkAdapter.initialize();
                if (!available) {
                    console.warn('‚ö†Ô∏è Steam not available - falling back to local mode');
                    isNetworkGame = false;
                    return;
                }

                isNetworkGame = true;
                localSteamId = networkAdapter.getLocalPlayer()?.steamId;

                // Check if we're already in a lobby (from setup screen)
                const lobbyData = localStorage.getItem('golfSteamLobby');
                if (lobbyData) {
                    const lobby = JSON.parse(lobbyData);
                    isNetworkHost = lobby.isHost;
                    console.log(`üåê Network game active - ${isNetworkHost ? 'HOST' : 'CLIENT'}`);
                }

                // Set up message handlers
                networkAdapter.onMessage(handleNetworkMessage);

                networkAdapter.on('member-left', (data) => {
                    console.log('üëã Player left:', data);
                    showNetworkNotification(`Player disconnected`);
                });

                networkAdapter.on('disconnected', () => {
                    console.log('‚ùå Disconnected from lobby');
                    isNetworkGame = false;
                    showNetworkNotification('Disconnected from multiplayer session');
                });

                console.log('‚úÖ Steam network initialized successfully');

            } catch (err) {
                console.error('‚ùå Network initialization failed:', err);
                isNetworkGame = false;
            }
        }

        function handleNetworkMessage(message) {
            console.log('üì® Network message:', message);

            switch (message.type) {
                case 'shot':
                    handleNetworkShot(message);
                    break;
                case 'ball_position':
                    handleNetworkBallPosition(message);
                    break;
                case 'game_state':
                    handleNetworkGameState(message);
                    break;
                case 'turn_start':
                    handleNetworkTurnStart(message);
                    break;
                case 'hole_complete':
                    handleNetworkHoleComplete(message);
                    break;
                default:
                    console.log('Unknown message type:', message.type);
            }
        }

        function handleNetworkShot(message) {
            // Another player took a shot - simulate it locally
            const { playerIndex, speed, vla, hla, totalSpin, spinAxis } = message.data || message;

            // Don't process our own shots
            if (message.from === localSteamId) return;

            console.log(`üåê Remote shot from player ${playerIndex}:`, { speed, vla, hla, totalSpin, spinAxis });

            // If this is for a different player than current, switch to them
            if (playerIndex !== window.currentPlayerIndex) {
                window.currentPlayerIndex = playerIndex;
                loadPlayerState();
                updatePlayerDisplay();
            }

            // Fire the shot locally
            const shotEvent = {
                detail: {
                    speed: speed,
                    vla: vla,
                    hla: hla,
                    total_spin: totalSpin,
                    spin_axis: spinAxis
                }
            };
            handleShot(shotEvent);
        }

        function handleNetworkBallPosition(message) {
            const { playerIndex, position, lie, distanceToHole } = message;

            // Don't process our own updates
            if (message.from === localSteamId) return;

            console.log(`üåê Ball position update for player ${playerIndex}:`, position);

            // Update player's ball position
            if (window.golfPar3Players[playerIndex]) {
                window.golfPar3Players[playerIndex].ballPosition = position;

                // If it's the current player's ball, update visuals
                if (playerIndex === window.currentPlayerIndex) {
                    ballPosition.set(position.x, position.y, position.z);
                    if (ball) ball.position.copy(ballPosition);
                    updateLieType();
                }
            }
        }

        function handleNetworkGameState(message) {
            // Host sent full game state - sync to it
            const { players, currentHole } = message.data || message;

            console.log('üåê Received game state sync:', message);

            if (players) {
                // Update all player states
                players.forEach((p, i) => {
                    if (window.golfPar3Players[i]) {
                        window.golfPar3Players[i].ballPosition = p.ballPosition;
                        window.golfPar3Players[i].strokes = p.strokes;
                        window.golfPar3Players[i].holed = p.holed;
                    }
                });
            }
        }

        function handleNetworkTurnStart(message) {
            const { playerIndex } = message;

            console.log(`üåê Turn start for player ${playerIndex}`);

            if (playerIndex !== window.currentPlayerIndex) {
                window.currentPlayerIndex = playerIndex;
                loadPlayerState();
                updatePlayerDisplay();
            }
        }

        function handleNetworkHoleComplete(message) {
            const { playerIndex, strokes } = message;

            console.log(`üåê Player ${playerIndex} holed out in ${strokes} strokes`);

            if (window.golfPar3Players[playerIndex]) {
                window.golfPar3Players[playerIndex].holed = true;
                window.golfPar3Players[playerIndex].strokes = strokes;
            }
        }

        function broadcastShot(shotData) {
            if (!isNetworkGame || !networkAdapter) return;

            networkAdapter.broadcast({
                type: 'shot',
                playerIndex: window.currentPlayerIndex,
                ...shotData,
                timestamp: Date.now()
            });
        }

        function broadcastBallPosition() {
            if (!isNetworkGame || !networkAdapter) return;

            networkAdapter.broadcast({
                type: 'ball_position',
                playerIndex: window.currentPlayerIndex,
                position: { x: ballPosition.x, y: ballPosition.y, z: ballPosition.z },
                lie: currentLie?.name || 'Unknown',
                distanceToHole: distanceToHole
            });
        }

        function broadcastGameState() {
            if (!isNetworkGame || !networkAdapter || !isNetworkHost) return;

            networkAdapter.broadcast({
                type: 'game_state',
                data: {
                    currentHole: window.golfPar3Players[0]?.currentHole || 0,
                    players: window.golfPar3Players.map(p => ({
                        name: p.name,
                        ballPosition: p.ballPosition,
                        strokes: p.strokes,
                        holed: p.holed
                    }))
                }
            });
        }

        function broadcastTurnStart(playerIndex) {
            if (!isNetworkGame || !networkAdapter || !isNetworkHost) return;

            networkAdapter.broadcast({
                type: 'turn_start',
                playerIndex: playerIndex
            });
        }

        function showNetworkNotification(text) {
            // Simple notification for network events
            const existing = document.getElementById('networkNotification');
            if (existing) existing.remove();

            const div = document.createElement('div');
            div.id = 'networkNotification';
            div.style.cssText = 'position:fixed; top:60px; left:50%; transform:translateX(-50%); ' +
                'background:rgba(59,130,246,0.9); color:white; padding:10px 20px; border-radius:8px; ' +
                'font-size:14px; z-index:2000; animation:fadeIn 0.3s;';
            div.textContent = text;
            document.body.appendChild(div);

            setTimeout(() => div.remove(), 3000);
        }

        // ==================== END STEAM NETWORK MULTIPLAYER ====================

        function createTracer() {
            // Create line geometry for tracer
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(MAX_TRACER_POINTS * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Glowing tracer material
            const material = new THREE.LineBasicMaterial({
                color: 0xFFFFFF,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });

            tracer = new THREE.Line(geometry, material);
            tracer.frustumCulled = false;
            scene.add(tracer);
        }

        function updateTracer() {
            if (!ballInFlight) {
                if (tracer && tracer.geometry) {
                    tracer.geometry.setDrawRange(0, 0);
                }
                tracerCount = 0;
                tracerWriteIndex = 0;
                return;
            }

            // Add current ball position to tracer
            if (!tracerPositions[tracerWriteIndex]) {
                tracerPositions[tracerWriteIndex] = new THREE.Vector3();
            }
            tracerPositions[tracerWriteIndex].copy(ballPosition);
            tracerWriteIndex = (tracerWriteIndex + 1) % MAX_TRACER_POINTS;
            tracerCount = Math.min(tracerCount + 1, MAX_TRACER_POINTS);

            // Update line geometry
            if (tracer && tracer.geometry) {
                const positions = tracer.geometry.attributes.position.array;
                for (let i = 0; i < tracerCount; i++) {
                    const index = (tracerWriteIndex - tracerCount + i + MAX_TRACER_POINTS) % MAX_TRACER_POINTS;
                    const point = tracerPositions[index];
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                }

                tracer.geometry.attributes.position.needsUpdate = true;
                tracer.geometry.setDrawRange(0, tracerCount);
            }
        }

        function resetBallPosition() {
            ballPosition.copy(TEE_POSITION);

            // Tee box is at y=3 with height 0.2, so surface is at 3 + 0.2/2 = 3.1
            const teeBoxSurfaceHeight = 3.1;
            // Add tee height (~1 inch = 0.0254m) plus ball radius
            ballPosition.y = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            console.log(`Reset ball: Tee surface=${teeBoxSurfaceHeight.toFixed(3)}, Ball radius=${BALL_RADIUS.toFixed(3)}, Final Y=${ballPosition.y.toFixed(3)}`);

            ball.position.copy(ballPosition);
            ballVelocity.set(0, 0, 0);
            currentLie = LIE_TYPES.TEE;
            updateUI();
        }

        function handleShotFromElectron(data) {
            console.log('üì° Shot data received from Electron:', data);
            // Mark as local shot (not from network) and broadcast to peers
            data._isLocalShot = true;
            handleShot({ detail: data });
        }

        function handleShot(event) {
            if (ballInFlight) return;

            // Reset landing speed and spin for new shot
            window.ballLandingSpeedMPH = null;
            window.ballLandingSpinRPM = null;
            ballStoppedTime = null; // Reset gimme timer for new shot

            // Handle both Electron IPC format (ball_speed) and demo shot format (speed)
            const data = event.detail;
            let speed = data.speed || data.ball_speed || 0;

            // Get shot parameters BEFORE using them
            let vla = data.vla || data.vertical_launch_angle || 0;
            let hla = data.hla || data.horizontal_launch_angle || 0;
            let total_spin = data.total_spin || data.totalSpin || 0;
            let spin_axis = data.spin_axis || data.spinAxis || 0;

            // Classify shot with OpenGolfCoach
            console.log('üîç Attempting shot classification:', { speed, vla, hla, total_spin, spin_axis });
            if (window.classifyShot) {
                const classification = window.classifyShot({
                    speed: speed,
                    vla: vla,
                    hla: hla,
                    total_spin: total_spin,
                    spin_axis: spin_axis
                });

                console.log('üìä Classification result:', classification);

                if (classification) {
                    // Display shot classification
                    displayShotClassification(classification);
                    // Store for session tracking
                    currentShotData.classification = classification;
                }
            } else {
                console.warn('‚ö†Ô∏è window.classifyShot not available yet');
            }

            // Store original input values for display
            const inputHLA = hla;

            // Validate shot data (allow vla=0 for putts)
            if (!speed || vla === undefined || vla === null) {
                console.warn('Invalid shot data received:', data);
                return;
            }

            // Broadcast shot to network peers (only for local shots from launch monitor)
            if (data._isLocalShot && isNetworkGame) {
                broadcastShot({
                    speed: speed,
                    vla: vla,
                    hla: hla,
                    totalSpin: total_spin,
                    spinAxis: spin_axis
                });
            }

            // Apply base direction and aim adjustment
            // Check if current player has auto-aim enabled
            const currentPlayer = window.golfPar3Players[window.currentPlayerIndex];
            const autoAimEnabled = currentPlayer && currentPlayer.autoAim !== false;

            if (autoAimEnabled) {
                // Auto-aim ON: Add magnetism toward pin
                // Calculate direction toward pin from current position
                const dx = PIN_POSITION.x - ballPosition.x;
                const dz = PIN_POSITION.z - ballPosition.z;
                const directionToPin = Math.atan2(dx, -dz) * 180 / Math.PI;

                // Shot aims toward pin (with HLA and aim adjustment on top)
                hla = hla + directionToPin + aimAdjustment;
            } else {
                // Auto-aim OFF: Shoot straight where camera is pointing
                // Calculate direction from current camera orientation in real-time
                const cameraDirection = new THREE.Vector3();
                camera.getWorldDirection(cameraDirection);
                const currentCameraAngle = Math.atan2(cameraDirection.x, -cameraDirection.z) * 180 / Math.PI;
                hla = hla + currentCameraAngle + aimAdjustment;
            }

            // Convert spin axis to radians and calculate backspin/sidespin components
            const spinAxisRad = spin_axis * Math.PI / 180;
            const backspin = total_spin * Math.cos(spinAxisRad);
            const sidespin = total_spin * Math.sin(spinAxisRad);

            // Convert to SI units
            const speedMS = speed * 0.44704; // mph to m/s
            const vlaRad = vla * Math.PI / 180;
            const hlaRad = hla * Math.PI / 180;

            // Calculate what the aim direction is for logging
            let aimMode;
            if (autoAimEnabled) {
                const dx = PIN_POSITION.x - ballPosition.x;
                const dz = PIN_POSITION.z - ballPosition.z;
                const directionToPin = Math.atan2(dx, -dz) * 180 / Math.PI;
                aimMode = `AUTO-AIM: pin ${directionToPin.toFixed(1)}¬∞ + adj ${aimAdjustment}¬∞`;
            } else {
                aimMode = `MANUAL: camera ${baseDirection.toFixed(1)}¬∞ + adj ${aimAdjustment}¬∞`;
            }
            console.log(`‚õ≥ Shot fired: ${speed.toFixed(1)} mph, VLA=${vla.toFixed(1)}¬∞, HLA=${hla.toFixed(1)}¬∞ (${aimMode})`);
            console.log(`   Spin: ${total_spin.toFixed(0)} rpm @ ${spin_axis.toFixed(1)}¬∞ axis ‚Üí Backspin: ${backspin.toFixed(0)} rpm, Sidespin: ${sidespin.toFixed(0)} rpm`);

            // Empirical distance prediction (DISABLED - was causing visible teleport after roll)
            // const empiricalResult = predictEmpirical(speed, vla, backspin);
            // empiricalPredictedDistance = empiricalResult.distance;
            // console.log(`   Empirical prediction: ${empiricalResult.distance.toFixed(1)} yards (Region: ${empiricalResult.region})`);

            // Store initial shot parameters for five-regime physics (v4.5.0)
            initialShotSpeedMPH = speed;
            initialVLADegs = vla;

            // Determine physics regime (FIVE REGIMES in v4.5.0)
            // Priority 1: WEDGE regime (< 65 mph)
            if (initialShotSpeedMPH < 65) {
                physicsRegime = 'WEDGE';
            }
            // Priority 2: POWER_SHOT regime (>= 85 mph) - check speed BEFORE VLA
            else if (initialShotSpeedMPH >= 85) {
                physicsRegime = 'POWER_SHOT';
            }
            // Priority 3: LOW_TRAJECTORY (65-85 mph with VLA < 10¬∞)
            else if (initialVLADegs < 10) {
                physicsRegime = 'LOW_TRAJECTORY';
            }
            // Priority 4: MID_IRON (65-85 mph with 10¬∞ <= VLA < 20¬∞)
            else if (initialVLADegs < 20) {
                physicsRegime = 'MID_IRON';
            }
            // Priority 5: HIGH_IRON (65-85 mph with VLA >= 20¬∞)
            else {
                physicsRegime = 'HIGH_IRON';
            }
            console.log(`   Physics Regime: ${physicsRegime} (${initialShotSpeedMPH.toFixed(1)} mph, ${initialVLADegs.toFixed(1)}¬∞ VLA) - FIVE-REGIME PHYSICS v4.5.0`);

            // Calculate velocity vector
            ballVelocity.set(
                speedMS * Math.sin(hlaRad) * Math.cos(vlaRad),
                speedMS * Math.sin(vlaRad),
                -speedMS * Math.cos(hlaRad) * Math.cos(vlaRad)
            );

            ballSpin.totalSpin = total_spin;
            ballSpin.spinAxis = spin_axis;

            // Detect if this is a putt (VLA <= 2 degrees)
            isPutting = (vla <= 2);
            if (isPutting) {
                console.log('Putt detected - using GSPro putting model');
                carryDistance = 0; // Putts have no carry, only roll
                hasLanded = true; // Mark as already landed
                currentPuttDeceleration = computePuttDeceleration(speed, currentStimp);
            }

            ballInFlight = true;
            shotStartPos.copy(ballPosition);
            maxHeight = ballPosition.y;
            if (!isPutting) {
                hasLanded = false;
            }
            strokes++;

            // Store shot data for CSV export later
            const player = window.golfPar3Players[window.currentPlayerIndex];
            currentShotData = {
                timestamp: new Date().toISOString(),
                player: player ? player.name : 'Unknown',
                hole: HOLES[currentHoleIndex].number,
                ballSpeed: speed,
                launchAngle: vla,
                sideAngle: inputHLA, // Original HLA before aim adjustments
                totalSpin: total_spin,
                spinAxis: spin_axis,
                lie: currentLie.name,
                startTime: Date.now()
            };

            // Update shot details
            document.getElementById('shotSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('shotVLA').textContent = vla.toFixed(1) + '¬∞';
            document.getElementById('shotHLA').textContent = inputHLA.toFixed(1) + '¬∞';

            // Total Spin
            document.getElementById('shotSpin').textContent = total_spin.toFixed(0) + ' rpm';

            // Spin Axis with R/L indicator
            const spinAxisAbs = Math.abs(spin_axis);
            const spinAxisDir = spin_axis >= 0 ? ' R' : ' L';
            document.getElementById('shotSpinAxis').textContent = spinAxisAbs.toFixed(1) + '¬∞' + spinAxisDir;

            document.getElementById('shotDetails').style.display = 'block';

            updateUI();
        }

        // FIVE-REGIME PHYSICS HELPER FUNCTIONS (v4.5.0)

        // Get regime-specific friction multiplier
        function getRegimeFrictionMultiplier(physicsRegime, spinRPM) {
            switch (physicsRegime) {
                case 'WEDGE':
                    return 1.0;

                case 'LOW_TRAJECTORY':
                    return 0.70; // Lower friction for more roll (42.8% roll observed)

                case 'MID_IRON':
                    // Spin-dependent friction for mid irons
                    if (spinRPM >= 2000) {
                        return 1.4;
                    } else {
                        return 1.0;
                    }

                case 'HIGH_IRON':
                    // Moderate friction with spin adjustment
                    if (spinRPM >= 2000) {
                        return 1.3;
                    } else {
                        return 1.1;
                    }

                case 'POWER_SHOT':
                    return 1.1;

                default:
                    return 1.0;
            }
        }

        // Get regime-specific bounce retention
        function getRegimeBounceRetention(physicsRegime) {
            switch (physicsRegime) {
                case 'WEDGE':
                    return 0.72;
                case 'LOW_TRAJECTORY':
                    return 0.78; // Moderate bounce for shallow trajectory
                case 'MID_IRON':
                    return 0.75;
                case 'HIGH_IRON':
                    return 0.70; // Sticky landings
                case 'POWER_SHOT':
                    return 0.75;
                default:
                    return 0.75;
            }
        }

        // Get regime-specific magnus lift boost
        function getMagnusLiftBoost(physicsRegime, vlaDegs) {
            switch (physicsRegime) {
                case 'WEDGE':
                    return vlaDegs >= 20 ? 1.22 : 1.0;

                case 'LOW_TRAJECTORY':
                    return vlaDegs >= 20 ? 1.05 : 1.0; // Minimal boost

                case 'MID_IRON':
                    return vlaDegs >= 15 ? 1.15 : 1.0;

                case 'HIGH_IRON':
                    return vlaDegs >= 20 ? 1.05 : 1.0; // Minimal boost for high loft

                case 'POWER_SHOT':
                    return vlaDegs >= 15 ? 1.10 : 1.0;

                default:
                    return 1.0;
            }
        }

        function updatePuttingPhysics(deltaTime) {
            // Apply GSPro-matched per-putt deceleration
            const speed = ballVelocity.length();
            if (speed > 0.001) {
                const frictionForce = currentPuttDeceleration * deltaTime;
                const frictionDecel = Math.min(frictionForce / speed, 1);
                ballVelocity.multiplyScalar(1 - frictionDecel);
            } else {
                // Ball stopped
                ballVelocity.set(0, 0, 0);
                ballInFlight = false;

                // Broadcast final ball position to network peers
                broadcastBallPosition();

                console.log(`üèåÔ∏è Putt stopped: draftGolfEnabled=${draftGolfEnabled}, phase=${draftGolfPhase}`);

                // Draft Golf mode: record shot and skip normal player switching
                if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                    console.log('üéØ Draft Golf putt hook triggered - recording shot');
                    recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                    return; // Skip normal player switching
                }

                // NOTE: Empirical model distance correction for putts has been disabled because
                // it caused visible teleporting/jumping after the roll finished.
                // We now rely purely on physics-based Stimpmeter putting.
                // (Previous correction block left here for reference.)
                // if (empiricalPredictedDistance !== null && empiricalPredictedDistance > 0 && initialShotSpeedMPH >= 20) {
                //     const physicsDistanceMeters = Math.sqrt(
                //         Math.pow(ballPosition.x - shotStartPos.x, 2) +
                //         Math.pow(ballPosition.z - shotStartPos.z, 2)
                //     );
                //     const physicsDistanceYards = physicsDistanceMeters * 1.09361;
                //     const scaleFactor = empiricalPredictedDistance / physicsDistanceYards;
                //     const deltaX = ballPosition.x - shotStartPos.x;
                //     const deltaZ = ballPosition.z - shotStartPos.z;
                //     ballPosition.x = shotStartPos.x + (deltaX * scaleFactor);
                //     ballPosition.z = shotStartPos.z + (deltaZ * scaleFactor);
                //     ball.position.copy(ballPosition);
                //     const groundY = getGroundHeightRaycast(ballPosition.x, ballPosition.z);
                //     ballPosition.y = groundY + BALL_RADIUS;
                //     ball.position.y = ballPosition.y;
                //     empiricalPredictedDistance = null;
                // }

                // Calculate putt distance for stats
                const totalDist = Math.sqrt(
                    Math.pow(ballPosition.x - shotStartPos.x, 2) +
                    Math.pow(ballPosition.z - shotStartPos.z, 2)
                ) * 1.09361;

                // Add shot to session tracking for CSV export (putts)
                if (currentShotData && currentShotData.startTime) {
                    const flightTime = (Date.now() - currentShotData.startTime) / 1000;

                    sessionShots.push({
                        ...currentShotData,
                        carryDistance: 0, // Putts have no carry
                        totalDistance: totalDist,
                        rollout: totalDist,
                        apexHeight: 0,
                        flightTime: flightTime
                    });
                    console.log(`üìä Putt added to CSV export (${sessionShots.length} total shots)`);
                }

                // Mark ball as stopped and schedule gimme check; actual gimme
                // decision is handled in checkGimme() (called from animate).
                if (!ballStoppedTime) {
                    ballStoppedTime = performance.now();
                    console.log('Ball stopped - starting gimme check timer');
                }

                // Snap aim to pin after putts, then save state
                const currentPlayer = window.golfPar3Players[window.currentPlayerIndex];
                const autoAimEnabled = currentPlayer && currentPlayer.autoAim !== false;
                snapAimToPin(autoAimEnabled);
                savePlayerState();
                setTimeout(() => {
                    switchToFarthestPlayer();
                }, 2000);
            }

            // Update position
            ballPosition.addScaledVector(ballVelocity, deltaTime);

            // Keep ball on ground during putt
            const groundY = getGroundHeightRaycast(ballPosition.x, ballPosition.z);
            ballPosition.y = groundY + BALL_RADIUS;

            // Check if ball is close to hole
            const distanceToHole = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );

            // Flagstick collision detection
            const FLAGSTICK_RADIUS = 0.01; // Flagstick pole radius in meters
            const collisionRadius = BALL_RADIUS + FLAGSTICK_RADIUS;

            if (distanceToHole < collisionRadius && distanceToHole > 0.001) {
                // Ball hit the flagstick!
                const dx = ballPosition.x - PIN_POSITION.x;
                const dz = ballPosition.z - PIN_POSITION.z;

                // Calculate normal (direction from pin to ball)
                const invDist = 1 / distanceToHole;
                const normalX = dx * invDist;
                const normalZ = dz * invDist;

                // Check if ball is moving toward the flagstick
                const dot = ballVelocity.x * normalX + ballVelocity.z * normalZ;

                if (dot < 0) { // Moving toward flagstick
                    // If moving slow enough, ball can drop in the hole
                    if (speed < 2.0 && distanceToHole < 0.054) { // Within cup radius and slow
                        ballPosition.x = PIN_POSITION.x;
                        ballPosition.z = PIN_POSITION.z;
                        ballVelocity.set(0, 0, 0);
                        ballInFlight = false;
                        console.log('Ball hit flagstick and dropped in!');
                        // Draft Golf mode: record hole-in as shot
                        if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                            recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                            return;
                        }
                        checkHole();
                        return;
                    } else {
                        // Bounce off flagstick
                        // Reflect velocity off the flagstick
                        const reflectDot = ballVelocity.x * normalX + ballVelocity.z * normalZ;
                        ballVelocity.x = (ballVelocity.x - 2 * reflectDot * normalX) * 0.6; // 40% energy loss
                        ballVelocity.z = (ballVelocity.z - 2 * reflectDot * normalZ) * 0.6;

                        // Push ball outside collision radius
                        const pushDist = collisionRadius - distanceToHole + 0.001;
                        ballPosition.x += normalX * pushDist;
                        ballPosition.z += normalZ * pushDist;

                        console.log('Ball bounced off flagstick!');
                    }
                }
            }

            // Update ball mesh
            ball.position.copy(ballPosition);

            // Ball falls into hole if within cup radius and moving slowly (no flagstick hit)
            if (distanceToHole < 0.054 && speed < 2.0) { // 0.054m = cup radius
                ballPosition.x = PIN_POSITION.x;
                ballPosition.z = PIN_POSITION.z;
                ballVelocity.set(0, 0, 0);
                ballInFlight = false;
                console.log('Ball in hole!');
                // Draft Golf mode: record hole-in as shot
                if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                    recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                    return;
                }
                checkHole(); // Register the score and reset hole
            }
        }

        function updateBallPhysics(deltaTime) {
            if (!ballInFlight) return;

            // Use Stimpmeter physics for putts
            if (isPutting) {
                updatePuttingPhysics(deltaTime);
                return;
            }

            // Convert velocity from m/s to ft/s for Excel formulas
            // THREE.js: X=left/right, Y=up/down, Z=forward/back (negative = forward)
            // Excel: X=left/right, Y=forward/back, Z=up/down
            const vxFtS = ballVelocity.x * 3.28084;      // X stays X (lateral)
            const vyFtS = -ballVelocity.z * 3.28084;     // -Z becomes Y (forward is positive)
            const vzFtS = ballVelocity.y * 3.28084;      // Y becomes Z (vertical)

            const speed = Math.sqrt(vxFtS * vxFtS + vyFtS * vyFtS + vzFtS * vzFtS);

            // Debug on first frame
            if (ballPosition.y > 3 && ballPosition.y < 3.1) {
                // PERFORMANCE: Debug log disabled
                // console.log(`Physics: Speed=${speed.toFixed(1)} ft/s, Drag const=${DRAG_CONST.toFixed(6)}, Magnus const=${MAGNUS_CONST.toFixed(6)}`);
            }

            // Convert spin from RPM to rad/s, then to components
            const spinAxisRad = ballSpin.spinAxis * Math.PI / 180;
            const totalSpinRadS = ballSpin.totalSpin * Math.PI / 30; // RPM to rad/s

            // Spin components (Excel formula from D11-D13)
            // wx, wy, wz in rad/s
            const wx = totalSpinRadS * Math.cos(spinAxisRad);  // Backspin component
            const wy = -totalSpinRadS * Math.sin(spinAxisRad); // Sidespin component
            const wz = 0;

            // Drag force (Excel formula from W32-Y32)
            // Drag = -const * Cd * speed * velocity_component
            let dragAccelX = 0, dragAccelY = 0, dragAccelZ = 0;
            if (speed > 0.1) {
                // Calculate Cd based on speed using FIVE-REGIME PHYSICS (v4.5.0)
                const speedMPH = speed / 1.467; // Convert ft/s to mph
                let Cd;

                // Get current VLA for low-trajectory check
                const currentVLA = Math.asin(ballVelocity.y / Math.sqrt(
                    ballVelocity.x * ballVelocity.x +
                    ballVelocity.y * ballVelocity.y +
                    ballVelocity.z * ballVelocity.z
                )) * 180 / Math.PI;

                // Special handling for LOW_TRAJECTORY shots (VLA < 10¬∞) - regardless of regime
                if (currentVLA < 10) {
                    if (speedMPH <= 60) {
                        Cd = 0.60;
                    } else if (speedMPH <= 85) {
                        const t = (speedMPH - 60) / (85 - 60);
                        Cd = 0.60 - t * (0.60 - 0.55);
                    } else {
                        Cd = 0.55;
                    }
                }
                // WEDGE REGIME (< 65 mph initial) - v4.4.1 calibration (already 100% accurate)
                else if (physicsRegime === 'WEDGE') {
                    if (speedMPH <= 55) {
                        Cd = 0.85; // Higher drag for chips/wedges
                    } else if (speedMPH <= 75) {
                        const t = (speedMPH - 55) / (75 - 55);
                        Cd = 0.85 - t * (0.85 - 0.31);
                    } else if (speedMPH <= 100) {
                        const t = (speedMPH - 75) / (100 - 75);
                        Cd = 0.31 - t * (0.31 - 0.22);
                    } else {
                        Cd = 0.22;
                    }
                }
                // POWER_SHOT REGIME (85+ mph initial) - Balanced drag for fast shots
                else if (physicsRegime === 'POWER_SHOT') {
                    if (speedMPH <= 55) {
                        Cd = 0.78; // Moderate drag at low speeds
                    } else if (speedMPH <= 75) {
                        const t = (speedMPH - 55) / (75 - 55);
                        Cd = 0.78 - t * (0.78 - 0.30);
                    } else if (speedMPH <= 100) {
                        const t = (speedMPH - 75) / (100 - 75);
                        Cd = 0.30 - t * (0.30 - 0.22);
                    } else if (speedMPH <= 126) {
                        const t = (speedMPH - 100) / (126 - 100);
                        Cd = 0.22 - t * (0.22 - 0.18);
                    } else {
                        Cd = 0.18;
                    }
                }
                // MID_IRON REGIME - Standard iron drag curve with speed boost for 80+ mph
                // HIGH_IRON REGIME - Higher drag curve for high loft
                else {
                    const isHighIron = physicsRegime === 'HIGH_IRON';
                    const isMidIron = physicsRegime === 'MID_IRON';

                    let baseDragBoost = 1.0;
                    if (isHighIron) {
                        baseDragBoost = 1.08;
                    } else if (isMidIron && initialShotSpeedMPH >= 80) {
                        baseDragBoost = 1.06; // Extra drag for fast mid-iron shots
                    }

                    if (speedMPH <= 55) {
                        Cd = 0.75 * baseDragBoost;
                    } else if (speedMPH <= 75) {
                        const t = (speedMPH - 55) / (75 - 55);
                        Cd = (0.75 - t * (0.75 - 0.25)) * baseDragBoost;
                    } else if (speedMPH <= 100) {
                        const t = (speedMPH - 75) / (100 - 75);
                        Cd = (0.25 - t * (0.25 - 0.18)) * baseDragBoost;
                    } else if (speedMPH <= 126) {
                        const t = (speedMPH - 100) / (126 - 100);
                        Cd = (0.18 - t * (0.18 - 0.14)) * baseDragBoost;
                    } else if (speedMPH <= 150) {
                        const t = (speedMPH - 126) / (150 - 126);
                        Cd = (0.14 - t * (0.14 - 0.10)) * baseDragBoost;
                    } else {
                        Cd = 0.10 * baseDragBoost;
                    }
                }

                // Spin-dependent drag adjustment (regime-specific)
                const currentSpinRPM = ballSpin.totalSpin;
                let spinDragMultiplier = 1.0;

                if (physicsRegime === 'WEDGE') {
                    // Wedge regime spin adjustment (v4.4.1)
                    if (currentSpinRPM >= 5000) {
                        spinDragMultiplier = 0.85;
                    } else if (currentSpinRPM >= 4000) {
                        const t = (currentSpinRPM - 4000) / (5000 - 4000);
                        spinDragMultiplier = 1.0 - t * 0.15;
                    } else if (currentSpinRPM >= 3000) {
                        const t = (currentSpinRPM - 3000) / (4000 - 3000);
                        spinDragMultiplier = 1.05 - t * 0.05;
                    } else {
                        spinDragMultiplier = 1.05;
                    }
                } else if (physicsRegime === 'POWER_SHOT') {
                    // Power shot spin adjustment - extra drag for low-spin high-speed
                    if (currentSpinRPM >= 5000) {
                        spinDragMultiplier = 0.90;
                    } else if (currentSpinRPM >= 4000) {
                        const t = (currentSpinRPM - 4000) / (5000 - 4000);
                        spinDragMultiplier = 1.05 - t * 0.15;
                    } else if (currentSpinRPM >= 3000) {
                        const t = (currentSpinRPM - 3000) / (4000 - 3000);
                        spinDragMultiplier = 1.05 - t * 0.00;
                    } else if (currentSpinRPM >= 2000) {
                        const t = (currentSpinRPM - 2000) / (3000 - 2000);
                        spinDragMultiplier = 1.00 + t * 0.05;
                    } else {
                        spinDragMultiplier = 1.00; // Neutral for very low spin
                    }
                } else {
                    // MID_IRON, HIGH_IRON, LOW_TRAJECTORY spin adjustment
                    if (currentSpinRPM >= 5000) {
                        spinDragMultiplier = 0.88;
                    } else if (currentSpinRPM >= 4000) {
                        const t = (currentSpinRPM - 4000) / (5000 - 4000);
                        spinDragMultiplier = 1.01 - t * 0.13;
                    } else if (currentSpinRPM >= 3000) {
                        const t = (currentSpinRPM - 3000) / (4000 - 3000);
                        spinDragMultiplier = 1.01 - t * 0.00;
                    } else if (currentSpinRPM >= 2000) {
                        const t = (currentSpinRPM - 2000) / (3000 - 2000);
                        spinDragMultiplier = 0.98 + t * 0.03;
                    } else {
                        spinDragMultiplier = 0.95;
                    }
                }

                // High-loft shot drag reduction (regime-specific)
                const vlaDegs = Math.asin(ballVelocity.y / Math.sqrt(
                    ballVelocity.x * ballVelocity.x +
                    ballVelocity.y * ballVelocity.y +
                    ballVelocity.z * ballVelocity.z
                )) * 180 / Math.PI;

                let highLoftDragMultiplier = 1.0;
                if (vlaDegs >= 20) {
                    if (physicsRegime === 'WEDGE') {
                        // Wedge regime (v4.4.1)
                        if (speedMPH >= 50) {
                            highLoftDragMultiplier = 0.80;
                        } else if (speedMPH >= 30) {
                            const t = (speedMPH - 30) / (50 - 30);
                            highLoftDragMultiplier = 0.90 + t * (0.80 - 0.90);
                        } else {
                            highLoftDragMultiplier = 0.95;
                        }
                    } else {
                        // All other regimes (MID_IRON, HIGH_IRON, LOW_TRAJECTORY, POWER_SHOT)
                        if (speedMPH >= 50) {
                            highLoftDragMultiplier = 0.82;
                        } else if (speedMPH >= 30) {
                            const t = (speedMPH - 30) / (50 - 30);
                            highLoftDragMultiplier = 0.90 + t * (0.82 - 0.90);
                        } else {
                            highLoftDragMultiplier = 0.95;
                        }
                    }
                }

                const dragFactor = -DRAG_CONST * Cd * speed * spinDragMultiplier * highLoftDragMultiplier;
                dragAccelX = dragFactor * vxFtS;
                dragAccelY = dragFactor * vyFtS;
                dragAccelZ = dragFactor * vzFtS;
            }

            // Magnus force (Excel formula from AA32-AC32)
            // F_magnus = MAGNUS_CONST * (liftCoeff / omega) * speed * (w √ó v)
            let magnusAccelX = 0, magnusAccelY = 0, magnusAccelZ = 0;
            if (speed > 0.1 && totalSpinRadS > 1) {
                // Cross product: w √ó v (in ft/s coordinate system)
                const crossX = wy * vzFtS - wz * vyFtS;
                const crossY = wz * vxFtS - wx * vzFtS;
                const crossZ = wx * vyFtS - wy * vxFtS;

                // Lift coefficient: ClAmp * S^0.4 (from Excel column T)
                const S = totalSpinRadS / speed; // Spin parameter (omega/v)
                const ClAmp = 0.217; // From Excel G5
                let liftCoeff = ClAmp * Math.pow(S, 0.4);

                // Low-speed Magnus penalty (regime-specific)
                const speedMPH_magnus = speed / 1.467;

                if (speedMPH_magnus < 60) {
                    const speedFactor = speedMPH_magnus / 60;
                    if (physicsRegime === 'WEDGE') {
                        liftCoeff *= (0.3 + 0.7 * speedFactor); // Wedge regime
                    } else {
                        liftCoeff *= (0.4 + 0.6 * speedFactor); // Iron regimes
                    }
                }

                // Regime-specific Magnus boost (FIVE-REGIME PHYSICS v4.5.0)
                const vlaDegs_magnus = Math.asin(ballVelocity.y / Math.sqrt(
                    ballVelocity.x * ballVelocity.x +
                    ballVelocity.y * ballVelocity.y +
                    ballVelocity.z * ballVelocity.z
                )) * 180 / Math.PI;

                const magnusBoost = getMagnusLiftBoost(physicsRegime, vlaDegs_magnus);
                liftCoeff *= magnusBoost;

                // Magnus formula: const * (liftCoeff/omega) * speed * (w √ó v)
                const magnusFactor = MAGNUS_CONST * (liftCoeff / totalSpinRadS) * speed;
                magnusAccelX = magnusFactor * crossX;
                magnusAccelY = magnusFactor * crossY;
                magnusAccelZ = magnusFactor * crossZ;

                // Debug on first frame (for troubleshooting if needed)
                if (ballPosition.y > 3 && ballPosition.y < 3.2) {
                    // PERFORMANCE: Magnus debug log disabled
                    // console.log(`Magnus debug: S=${S.toFixed(4)}, liftCoeff=${liftCoeff.toFixed(6)}, crossZ=${crossZ.toFixed(1)}, magnusFactor=${magnusFactor.toFixed(8)}, magnusZ=${magnusAccelZ.toFixed(2)} ft/s¬≤`);
                }
            }

            // Total acceleration (ft/s¬≤)
            const totalAccelX = dragAccelX + magnusAccelX;
            const totalAccelY = dragAccelY + magnusAccelY;
            const totalAccelZ = dragAccelZ + magnusAccelZ - GRAVITY; // Gravity acts downward

            // Debug on first frame
            if (ballPosition.y > 3 && ballPosition.y < 3.1 && ballPosition.z > -1) {
                console.log(`Position: (${ballPosition.x.toFixed(1)}, ${ballPosition.y.toFixed(1)}, ${ballPosition.z.toFixed(1)})`);
                console.log(`Velocity m/s: (${ballVelocity.x.toFixed(1)}, ${ballVelocity.y.toFixed(1)}, ${ballVelocity.z.toFixed(1)})`);
                console.log(`Drag accel ft/s¬≤: (${dragAccelX.toFixed(2)}, ${dragAccelY.toFixed(2)}, ${dragAccelZ.toFixed(2)})`);
                console.log(`Magnus accel ft/s¬≤: (${magnusAccelX.toFixed(2)}, ${magnusAccelY.toFixed(2)}, ${magnusAccelZ.toFixed(2)})`);
                console.log(`Total accel ft/s¬≤: (${totalAccelX.toFixed(2)}, ${totalAccelY.toFixed(2)}, ${totalAccelZ.toFixed(2)})`);
            }

            // Update velocity (convert acceleration back to m/s¬≤)
            // Excel coordinates: X=lateral, Y=forward, Z=vertical
            // THREE.js coordinates: X=lateral, Y=vertical, Z=forward (negative is forward)
            ballVelocity.x += (totalAccelX / 3.28084) * deltaTime;  // X to X (lateral)
            ballVelocity.z += -(totalAccelY / 3.28084) * deltaTime; // Y to -Z (forward, sign flip!)
            ballVelocity.y += (totalAccelZ / 3.28084) * deltaTime;  // Z to Y (vertical)

            // Spin decay (4% per second)
            ballSpin.totalSpin *= Math.exp(-deltaTime / 24.5);

            // Update position
            ballPosition.addScaledVector(ballVelocity, deltaTime);

            // Track max height
            if (ballPosition.y > maxHeight) {
                maxHeight = ballPosition.y;
            }

            // Check if ball went underwater on island-hopping holes (catch during flight/roll)
            const currentHole = HOLES[currentHoleIndex];
            if (currentHole.type === 'island-hopping' && ballPosition.y < -0.5) {
                // Ball went underwater - trigger OB
                ballInFlight = false;
                ballVelocity.set(0, 0, 0);

                const player = window.golfPar3Players[window.currentPlayerIndex];
                player.strokes += 1;
                strokes += 1;

                // Draft Golf mode: record shot at starting position (with penalty)
                if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                    alert('OUT OF BOUNDS - Ball went in the water! Stroke penalty applied.');
                    // Reset to previous shot position for recording
                    ballPosition.copy(shotStartPos);
                    ball.position.copy(ballPosition);
                    recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                    return;
                }

                alert('OUT OF BOUNDS - Ball went in the water! Stroke and distance penalty. Please re-hit from previous position.');

                // Reset to previous shot position
                ballPosition.copy(shotStartPos);
                ball.position.copy(ballPosition);

                savePlayerState();
                updatePlayerDisplay();
                return;
            }

            // Flagstick collision detection (in-flight)
            const distanceToHole = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );
            const FLAGSTICK_RADIUS = 0.01;
            const collisionRadius = BALL_RADIUS + FLAGSTICK_RADIUS;

            // Check if ball hits flagstick (must be below flagstick top height ~2m)
            if (distanceToHole < collisionRadius && ballPosition.y < 2.1) {
                const dx = ballPosition.x - PIN_POSITION.x;
                const dz = ballPosition.z - PIN_POSITION.z;
                const invDist = 1 / distanceToHole;
                const normalX = dx * invDist;
                const normalZ = dz * invDist;

                // Check if ball is moving toward the flagstick
                const dot = ballVelocity.x * normalX + ballVelocity.z * normalZ;

                if (dot < 0) { // Moving toward flagstick
                    // Bounce off flagstick with energy loss
                    const reflectDot = ballVelocity.x * normalX + ballVelocity.z * normalZ;
                    ballVelocity.x = (ballVelocity.x - 2 * reflectDot * normalX) * 0.5; // 50% energy loss
                    ballVelocity.z = (ballVelocity.z - 2 * reflectDot * normalZ) * 0.5;
                    ballVelocity.y *= 0.7; // Reduce vertical velocity

                    // Push ball outside collision radius
                    const pushDist = collisionRadius - distanceToHole + 0.001;
                    ballPosition.x += normalX * pushDist;
                    ballPosition.z += normalZ * pushDist;

                    console.log('Ball hit flagstick in flight!');
                }
            }

            // Tree collision check
            checkTreeCollision();

            // Ground collision using raycasting
            const groundY = getGroundHeightRaycast(ballPosition.x, ballPosition.z);

            // Ground collision - only when descending (like home run derby)
            if (ballPosition.y - BALL_RADIUS <= groundY && ballVelocity.y < 0) {
                ballPosition.y = groundY + BALL_RADIUS;

                // Calculate carry distance on first landing
                if (!hasLanded) {
                    hasLanded = true;
                    landingPos.copy(ballPosition);

                    // Straight-line distance from tee to landing position
                    carryDistance = Math.sqrt(
                        Math.pow(landingPos.x - shotStartPos.x, 2) +
                        Math.pow(landingPos.z - shotStartPos.z, 2)
                    ) * 1.09361; // Convert meters to yards

                    document.getElementById('shotCarry').textContent = carryDistance.toFixed(1) + ' yds';

                    // Check for out of bounds after first landing
                    if (checkOutOfBounds()) {
                        ballInFlight = false;
                        ballVelocity.set(0, 0, 0);

                        const player = window.golfPar3Players[window.currentPlayerIndex];
                        player.strokes += 1; // Add stroke penalty
                        strokes += 1;

                        // Draft Golf mode: record shot at starting position (with penalty)
                        if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                            alert('OUT OF BOUNDS! Stroke penalty applied.');
                            ballPosition.copy(shotStartPos);
                            ball.position.copy(ballPosition);
                            recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                            return;
                        }

                        alert('OUT OF BOUNDS! Stroke and distance penalty. Please re-hit from previous position.');

                        // Reset to previous shot position (stroke and distance)
                        ballPosition.copy(shotStartPos);
                        ball.position.copy(ballPosition);

                        savePlayerState();
                        updatePlayerDisplay();
                        return;
                    }
                }

                // Determine lie type
                currentLie = getLieType(ballPosition.x, ballPosition.z);

                // Bounce
                if (Math.abs(ballVelocity.y) > 0.5) {
                    ballVelocity.y = -ballVelocity.y * currentLie.bounceRetention;

                    // Reduce horizontal velocity based on landing speed AND spin rate
                    // High spin = stops faster, Low spin = rolls more
                    const horizontalSpeed = Math.sqrt(ballVelocity.x * ballVelocity.x + ballVelocity.z * ballVelocity.z);
                    const landingSpeedMPH = horizontalSpeed * 2.237; // m/s to mph
                    const currentSpinRPM = ballSpin.totalSpin;

                    // Store the landing speed AND spin ONLY on first bounce for friction calculations during rollout
                    if (!window.ballLandingSpeedMPH) {
                        window.ballLandingSpeedMPH = landingSpeedMPH;
                        window.ballLandingSpinRPM = currentSpinRPM;

                        // Calculate and store descent angle (for high-loft shot physics)
                        const verticalSpeed = Math.abs(ballVelocity.y);
                        const descentAngleDeg = Math.atan2(verticalSpeed, horizontalSpeed) * 180 / Math.PI;
                        window.ballDescentAngle = descentAngleDeg;
                    }

                    // Base bounce factor - FIVE-REGIME PHYSICS (v4.5.0)
                    // Get regime-specific base bounce
                    const regimeBounce = getRegimeBounceRetention(physicsRegime);

                    // Speed-dependent bounce adjustment
                    let baseBounce;
                    if (landingSpeedMPH <= 30) {
                        baseBounce = regimeBounce + 0.08;
                    } else if (landingSpeedMPH <= 40) {
                        const t = (landingSpeedMPH - 30) / (40 - 30);
                        baseBounce = (regimeBounce + 0.08) - t * 0.15;
                    } else if (landingSpeedMPH <= 60) {
                        const t = (landingSpeedMPH - 40) / (60 - 40);
                        baseBounce = (regimeBounce - 0.07) - t * 0.20;
                    } else if (landingSpeedMPH <= 80) {
                        const t = (landingSpeedMPH - 60) / (80 - 60);
                        baseBounce = (regimeBounce - 0.27) - t * 0.10;
                    } else {
                        baseBounce = regimeBounce - 0.37;
                    }

                    // High-loft shot adjustment: Steep descent angles convert more energy into forward roll
                    const descentAngle = window.ballDescentAngle || 0;
                    let descentBonus = 0;
                    if (descentAngle >= 40) {
                        descentBonus = 0.35; // Very steep (wedge shots) - significant forward energy
                    } else if (descentAngle >= 30) {
                        const t = (descentAngle - 30) / (40 - 30);
                        descentBonus = 0.0 + t * 0.35;
                    }
                    baseBounce = Math.min(0.95, baseBounce + descentBonus);

                    // Spin adjustment: HIGH spin REDUCES bounce (ball grips and checks up)
                    // LOW spin INCREASES bounce (ball skips and rolls more)
                    let spinAdjustment;
                    if (currentSpinRPM >= 5500) {
                        spinAdjustment = -0.70; // Very high spin kills roll
                    } else if (currentSpinRPM >= 5000) {
                        const t = (currentSpinRPM - 5000) / (5500 - 5000);
                        spinAdjustment = -0.55 - t * (0.70 - 0.55);
                    } else if (currentSpinRPM >= 4000) {
                        const t = (currentSpinRPM - 4000) / (5000 - 4000);
                        spinAdjustment = -0.25 - t * (0.55 - 0.25);
                    } else if (currentSpinRPM >= 3000) {
                        const t = (currentSpinRPM - 3000) / (4000 - 3000);
                        spinAdjustment = 0.0 - t * 0.25;
                    } else if (currentSpinRPM >= 2000) {
                        const t = (currentSpinRPM - 2000) / (3000 - 2000);
                        spinAdjustment = 0.3 - t * 0.3;
                    } else if (currentSpinRPM >= 1000) {
                        const t = (currentSpinRPM - 1000) / (2000 - 1000);
                        spinAdjustment = 0.6 - t * 0.3;
                    } else {
                        spinAdjustment = 0.6;
                    }

                    const bounceFactor = Math.max(0.05, Math.min(0.95, baseBounce * (1 + spinAdjustment)));

                    // Check for extreme backspin that can reverse ball direction (tour-level wedge shots)
                    // This happens when spin rate overcomes forward momentum
                    if (currentSpinRPM >= 8000 && landingSpeedMPH < 50 && currentLie.name === 'green') {
                        // Calculate backspin component (only backspin can reverse, not sidespin)
                        const spinAxisRad = ballSpin.spinAxis * Math.PI / 180;
                        const backspinRPM = currentSpinRPM * Math.cos(spinAxisRad);

                        if (backspinRPM >= 8000) {
                            // Ball grips the green and spins backwards
                            // Reverse velocity proportional to excess spin above threshold
                            const excessSpin = backspinRPM - 7000;
                            const reverseSpeed = excessSpin * 0.00025; // m/s per RPM (calibrated)

                            // Get current direction
                            const direction = new THREE.Vector2(ballVelocity.x, ballVelocity.z).normalize();

                            // Reverse direction
                            ballVelocity.x = -direction.x * reverseSpeed;
                            ballVelocity.z = -direction.z * reverseSpeed;
                            ballVelocity.y = 0; // No bounce, ball grips turf

                            console.log(`üîÑ BACKSPIN REVERSAL! ${backspinRPM.toFixed(0)} RPM ‚Üí reversing at ${reverseSpeed.toFixed(2)} m/s`);
                        } else {
                            // Normal high-spin bounce
                            ballVelocity.x *= bounceFactor;
                            ballVelocity.z *= bounceFactor;
                        }
                    } else {
                        // Normal bounce
                        ballVelocity.x *= bounceFactor;
                        ballVelocity.z *= bounceFactor;
                    }
                } else {
                    ballVelocity.y = 0;

                    // Rolling friction - spin-dependent (reduced for more roll distance)
                    const horizontalSpeed = Math.sqrt(ballVelocity.x * ballVelocity.x + ballVelocity.z * ballVelocity.z);
                    if (horizontalSpeed > 0.05) {
                        // Ball is moving - reset stopped timer
                        if (ballStoppedTime !== null) {
                            ballStoppedTime = null;
                        }
                        // High spin = more friction when rolling
                        // Use LANDING spin, not current spin (which decays during rollout)
                        // Note: This is BACKSPIN component only (sidespin doesn't affect rollout friction)
                        let spinFrictionMultiplier;
                        const totalSpinRPM = window.ballLandingSpinRPM || ballSpin.totalSpin;
                        const spinAxisDeg = ballSpin.spinAxis || 0;
                        const spinAxisRad = spinAxisDeg * Math.PI / 180;
                        // Calculate backspin component (only backspin affects rollout friction)
                        const spinRPM = totalSpinRPM * Math.cos(spinAxisRad);

                        if (spinRPM >= 5500) {
                            spinFrictionMultiplier = 63.0; // Very high spin - FlightScope tuned (8/10 tests passing)
                        } else if (spinRPM >= 5000) {
                            const t = (spinRPM - 5000) / (5500 - 5000);
                            spinFrictionMultiplier = 40.0 + t * (63.0 - 40.0);
                        } else if (spinRPM >= 4000) {
                            const t = (spinRPM - 4000) / (5000 - 4000);
                            spinFrictionMultiplier = 20.0 + t * (40.0 - 20.0);
                        } else if (spinRPM >= 3000) {
                            const t = (spinRPM - 3000) / (4000 - 3000);
                            spinFrictionMultiplier = 6.0 + t * (20.0 - 6.0);
                        } else if (spinRPM >= 2500) {
                            const t = (spinRPM - 2500) / (3000 - 2500);
                            spinFrictionMultiplier = 2.0 + t * (6.0 - 2.0);
                        } else if (spinRPM >= 2000) {
                            const t = (spinRPM - 2000) / (2500 - 2000);
                            spinFrictionMultiplier = 1.0 + t * (2.0 - 1.0);
                        } else if (spinRPM >= 1500) {
                            const t = (spinRPM - 1500) / (2000 - 1500);
                            spinFrictionMultiplier = 0.95 + t * (1.0 - 0.95);
                        } else if (spinRPM >= 1000) {
                            const t = (spinRPM - 1000) / (1500 - 1000);
                            spinFrictionMultiplier = 1.05 + t * (0.95 - 1.05);
                        } else {
                            spinFrictionMultiplier = 1.05; // Very low spin = slightly higher friction
                        }

                        // Landing speed factor: soft landings roll more even with spin
                        // BUT: higher spin should still create more friction even on soft landings
                        // Use the stored landing speed from when ball first touched down
                        const landingSpeedMPH = window.ballLandingSpeedMPH || (horizontalSpeed * 2.237);
                        let landingSpeedFactor;

                        // Base landing speed factor (calibrated for ~2500 RPM)
                        // Low-speed shots need MORE friction, not less (they don't compress the turf as much)
                        let baseLandingSpeedFactor;
                        if (landingSpeedMPH <= 35) {
                            baseLandingSpeedFactor = 0.42; // Soft landing - balanced friction for low-speed chips
                        } else if (landingSpeedMPH <= 50) {
                            const t = (landingSpeedMPH - 35) / (50 - 35);
                            baseLandingSpeedFactor = 0.42 + t * (0.28 - 0.42);
                        } else if (landingSpeedMPH <= 70) {
                            const t = (landingSpeedMPH - 50) / (70 - 50);
                            baseLandingSpeedFactor = 0.25 + t * (0.28 - 0.25);
                        } else if (landingSpeedMPH <= 90) {
                            const t = (landingSpeedMPH - 70) / (90 - 70);
                            baseLandingSpeedFactor = 0.28 + t * (1.0 - 0.28);
                        } else {
                            baseLandingSpeedFactor = 1.0; // Hard landing = full spin friction
                        }

                        // Spin-adjusted landing speed factor: higher spin = more friction even on soft landings
                        // Use the LANDING spin, not current spin (which decays during rollout)
                        // Scale very aggressively with spin: 5500 RPM = 20x multiplier
                        const landingSpinRPM = window.ballLandingSpinRPM || spinRPM;
                        let spinAdjustMultiplier = 1.0;
                        if (landingSpinRPM >= 5500) {
                            spinAdjustMultiplier = 20.0;
                        } else if (landingSpinRPM >= 4500) {
                            const t = (landingSpinRPM - 4500) / (5500 - 4500);
                            spinAdjustMultiplier = 12.0 + t * (20.0 - 12.0);
                        } else if (landingSpinRPM >= 3500) {
                            const t = (landingSpinRPM - 3500) / (4500 - 3500);
                            spinAdjustMultiplier = 5.0 + t * (12.0 - 5.0);
                        } else if (landingSpinRPM >= 2500) {
                            const t = (landingSpinRPM - 2500) / (3500 - 2500);
                            spinAdjustMultiplier = 1.0 + t * (5.0 - 1.0);
                        }

                        landingSpeedFactor = baseLandingSpeedFactor * spinAdjustMultiplier;

                        // High-loft shot adjustment: Steep descent angles reduce friction (ball has more forward energy)
                        // Calibrated against shots.csv data (4/4 tests passing)
                        const descentAngle = window.ballDescentAngle || 0;
                        let descentFrictionReduction = 1.0;
                        if (descentAngle >= 40) {
                            descentFrictionReduction = 0.50; // Very steep - less friction (was 0.25, caused too much roll)
                        } else if (descentAngle >= 30) {
                            const t = (descentAngle - 30) / (40 - 30);
                            descentFrictionReduction = 1.0 - t * (1.0 - 0.50);
                        }

                        // Regime-specific friction multiplier (FIVE-REGIME PHYSICS v4.5.0)
                        const currentRollSpinRPM = ballSpin.totalSpin;
                        const regimeFrictionMultiplier = getRegimeFrictionMultiplier(physicsRegime, currentRollSpinRPM);

                        const frictionDecel = currentLie.friction * spinFrictionMultiplier * landingSpeedFactor * descentFrictionReduction * regimeFrictionMultiplier;
                        const newSpeed = Math.max(0, horizontalSpeed - frictionDecel * deltaTime);
                        const scale = newSpeed / horizontalSpeed;

                        // PERFORMANCE: Friction debug disabled - was logging every 0.5s
                        /*
                        if (!window.lastFrictionLog) window.lastFrictionLog = 0;
                        if (performance.now() - window.lastFrictionLog > 500) {
                            console.log('FRICTION DEBUG:', {
                                currentSpinRPM: spinRPM.toFixed(0),
                                landingSpinRPM: landingSpinRPM.toFixed(0),
                                landingSpeedMPH: landingSpeedMPH.toFixed(1),
                                spinFrictionMult: spinFrictionMultiplier.toFixed(3),
                                baseLSF: baseLandingSpeedFactor.toFixed(5),
                                spinAdjMult: spinAdjustMultiplier.toFixed(3),
                                landingSpeedFactor: landingSpeedFactor.toFixed(5),
                                totalFriction: frictionDecel.toFixed(2),
                                horizontalSpeed: (horizontalSpeed * 2.237).toFixed(1) + ' mph'
                            });
                            window.lastFrictionLog = performance.now();
                        }
                        */

                        ballVelocity.x *= scale;
                        ballVelocity.z *= scale;
                        ballVelocity.y = 0; // Keep on ground

                        // Apply green slope if on the green
                        if (currentLie.name === 'green') {
                            const hole = HOLES[currentHoleIndex];
                            if (hole.greenSlope) {
                                const slope = hole.greenSlope;
                                const slopeRadians = slope.direction * Math.PI / 180;
                                const slopeFactor = slope.percent / 100;

                                // Gravity acceleration (9.81 m/s¬≤) * slope factor
                                const slopeAccel = 9.81 * slopeFactor;

                                // Slope direction vector (direction ball will be pushed)
                                const slopeForceX = Math.sin(slopeRadians) * slopeAccel * deltaTime;
                                const slopeForceZ = Math.cos(slopeRadians) * slopeAccel * deltaTime;

                                // Add slope force to velocity
                                ballVelocity.x += slopeForceX;
                                ballVelocity.z += slopeForceZ;
                            }
                        }
                    } else {
                        ballVelocity.x = 0;
                        ballVelocity.z = 0;

                        // Don't mark as stopped yet if we haven't run the end-of-flight logic
                        if (ballInFlight) {
                            ballInFlight = false;

                            // Broadcast final ball position to network peers
                            broadcastBallPosition();

                            console.log(`üèåÔ∏è Ball stopped: draftGolfEnabled=${draftGolfEnabled}, phase=${draftGolfPhase}`);

                            // Draft Golf mode: record shot and skip normal player switching
                            if (draftGolfEnabled && draftGolfPhase === 'WAITING_FOR_SHOTS') {
                                console.log('üéØ Draft Golf hook triggered - recording shot');
                                recordDraftGolfShot(window.currentPlayerIndex, ballPosition);
                                return; // Skip normal player switching
                            }

                            // Ball will check for gimme after delay

                        // NOTE: Empirical model distance correction (post-roll teleport) has been
                        // disabled. We now trust the physics simulation‚Äôs final resting position.
                        // The old correction logic is kept commented-out for future reference.
                        // console.log(`   Empirical check: predicted=${empiricalPredictedDistance}, speed=${initialShotSpeedMPH}, lie=${currentLie.name}`);
                        // if (empiricalPredictedDistance !== null && empiricalPredictedDistance > 0 &&
                        //     initialShotSpeedMPH >= 20 && currentLie.name.toLowerCase() !== 'green') {
                        //     const physicsDistanceMeters = Math.sqrt(
                        //         Math.pow(ballPosition.x - shotStartPos.x, 2) +
                        //         Math.pow(ballPosition.z - shotStartPos.z, 2)
                        //     );
                        //     const physicsDistanceYards = physicsDistanceMeters * 1.09361;
                        //     const scaleFactor = empiricalPredictedDistance / physicsDistanceYards;
                        //     const deltaX = ballPosition.x - shotStartPos.x;
                        //     const deltaZ = ballPosition.z - shotStartPos.z;
                        //     ballPosition.x = shotStartPos.x + (deltaX * scaleFactor);
                        //     ballPosition.z = shotStartPos.z + (deltaZ * scaleFactor);
                        //     ball.position.copy(ballPosition);
                        //     const groundY = getGroundHeightRaycast(ballPosition.x, ballPosition.z);
                        //     ballPosition.y = groundY + BALL_RADIUS;
                        //     ball.position.y = ballPosition.y;
                        //     empiricalPredictedDistance = null;
                        // }

                        // Update total distance and rollout (camera rotation happens after 1.5s delay)
                        const totalDist = Math.sqrt(
                            Math.pow(ballPosition.x - shotStartPos.x, 2) +
                            Math.pow(ballPosition.z - shotStartPos.z, 2)
                        ) * 1.09361;
                        document.getElementById('shotTotal').textContent = totalDist.toFixed(1) + ' yds';

                        // Calculate rollout (total - carry), ensure non-negative
                        const rollDist = Math.max(0, totalDist - carryDistance);
                        document.getElementById('shotRoll').textContent = rollDist.toFixed(1) + ' yds';

                        // For putts, set carry to 0 and roll to total distance
                        if (isPutting) {
                            document.getElementById('shotCarry').textContent = '0.0 yds';
                            document.getElementById('shotRoll').textContent = totalDist.toFixed(1) + ' yds';
                        }

                        // Add shot to session tracking for CSV export
                        if (currentShotData && currentShotData.startTime) {
                            const flightTime = (Date.now() - currentShotData.startTime) / 1000;
                            const apexFeet = maxHeight * 3.28084; // Convert to feet

                            sessionShots.push({
                                ...currentShotData,
                                carryDistance: isPutting ? 0 : carryDistance,
                                totalDistance: totalDist,
                                rollout: isPutting ? totalDist : rollDist,
                                apexHeight: apexFeet,
                                flightTime: flightTime
                            });
                            console.log(`üìä Shot added to CSV export (${sessionShots.length} total shots)`);
                        }

                        // Mark ball as stopped and schedule gimme check; actual gimme
                        // decision is handled in checkGimme() (called from animate).
                        if (!ballStoppedTime) {
                            ballStoppedTime = performance.now();
                            console.log('Ball stopped - starting gimme check timer');
                        }

                        // Check if in hole
                        checkHole();

                        // Wait 1.5 seconds for ball to visually settle, then save state and rotate camera
                        setTimeout(() => {
                            const currentPlayer = window.golfPar3Players[window.currentPlayerIndex];
                            const autoAimEnabled = currentPlayer && currentPlayer.autoAim !== false;
                            snapAimToPin(autoAimEnabled);
                            // Save player state AFTER ball has settled
                            savePlayerState();
                        }, 1500);

                        // Add 3.5 second pause total before switching players (1.5s settle + 2s view)
                        setTimeout(() => {
                            switchToFarthestPlayer();
                        }, 3500);
                        } // End if (ballInFlight)
                    }
                }
            }

            ball.position.copy(ballPosition);
            updateUI();
        }

        function snapAimToPin(autoAimEnabled) {
            const dx = PIN_POSITION.x - ballPosition.x;
            const dz = PIN_POSITION.z - ballPosition.z;
            const directionToPin = Math.atan2(dx, -dz) * 180 / Math.PI;

            baseDirection = directionToPin;
            if (autoAimEnabled) {
                console.log(`Ball settled - AUTO-AIM ON: camera & shot ‚Üí hole at ${baseDirection.toFixed(1)}¬∞`);
            } else {
                console.log(`Ball settled - AUTO-AIM OFF: camera ‚Üí hole at ${baseDirection.toFixed(1)}¬∞, but shot goes straight from camera`);
            }

            aimAdjustment = 0;
            updateAimIndicator();
        }

        function refreshGroundObjectsCache() {
            groundObjectsCache = [terrain, greenMesh, teebox, ...bunkers, ...islandMeshes].filter(obj => obj);
        }

        function getGroundHeightRaycast(x, z) {
            const estimatedHeight = getGroundHeight(x, z);
            if (ballPosition && (ballPosition.y - BALL_RADIUS) > estimatedHeight + GROUND_RAYCAST_BUFFER) {
                return estimatedHeight;
            }

            // Cast a ray downward from high above the ball position
            rayOrigin.set(x, 100, z);
            raycaster.set(rayOrigin, rayDirection);

            if (!groundObjectsCache.length) {
                return estimatedHeight;
            }
            const intersects = raycaster.intersectObjects(groundObjectsCache, false);

            if (intersects.length > 0) {
                const groundY = intersects[0].point.y;

                // Debug: Log when on green
                const distToPinXZ = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));
                if (distToPinXZ < 10) { // Within green radius
                    if (DEBUG_GROUND_RAYCAST && (!window.lastGreenDebug || Date.now() - window.lastGreenDebug > 1000)) {
                        console.log('BALL ON GREEN DEBUG:');
                        console.log('  Ball XZ:', x.toFixed(2), z.toFixed(2));
                        console.log('  Ground Y from raycast:', groundY.toFixed(3));
                        console.log('  Intersected object:', intersects[0].object === greenMesh ? 'GREEN' : 'OTHER');
                        if (greenMesh) console.log('  Green mesh Y position:', greenMesh.position.y);
                        window.lastGreenDebug = Date.now();
                    }
                }

                return groundY;
            }

            // Fallback to calculated height if no intersection
            // This happens when position is outside terrain bounds
            return estimatedHeight;
        }

        function getGroundHeight(x, z) {
            let height = 0;

            // Tee area (elevated)
            if (z > -10 && z < 10) {
                height = 3 - Math.abs(z) * 0.3;
            }
            // Slope from tee to fairway
            else if (z >= -30 && z <= -10) {
                height = 3 - (Math.abs(z) - 10) * 0.1;
            }
            // Fairway (slight downslope with natural undulations)
            else if (z > -110 && z <= -30) {
                height = 1 - ((Math.abs(z) - 30) / 80) * 1.5;

                // Natural undulations across the fairway
                height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                // Random-looking hills using multiple frequencies
                height += Math.sin(x * 0.7) * Math.cos(z * 0.1) * 0.35;
                height += Math.cos(x * 0.12 + z * 0.18) * 0.25;

                // Irregular mounds on the sides (rough areas)
                if (Math.abs(x) > 12) {
                    const distFromFairway = Math.abs(x) - 12;
                    // Create irregular mounding
                    height += Math.sin(z * 0.4 + x * 0.2) * distFromFairway * 0.15;
                    height += Math.cos(x * 0.6 - z * 0.15) * (distFromFairway * 0.1);
                    height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                    // Add some dramatic mounds in rough
                    const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                    if (moundNoise > 0.3) {
                        height += moundNoise * 0.8;
                    }
                }
            }
            // Approach to green with protective mounding
            else if (z > -125 && z <= -110) {
                height = -0.2;

                // Greenside mounds (irregular and natural)
                const distToGreen = Math.sqrt(Math.pow(x, 2) + Math.pow(z + 118.872, 2));
                if (distToGreen > 10 && distToGreen < 16) {
                    // Create raised mounding around green with irregular pattern
                    const angle = Math.atan2(x, z + 118.872);
                    const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5; // Vary by position
                    height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                    height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                    height += Math.sin(x * 1.1) * Math.cos((z + 118.872) * 0.9) * 0.5;
                }

                // Natural undulations around green
                height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                height += Math.cos(x * 0.8 - z * 0.4) * 0.25;
            }
            // Green area (subtle undulation, not completely flat)
            else {
                const distToPin = Math.sqrt(Math.pow(x - PIN_POSITION.x, 2) + Math.pow(z - PIN_POSITION.z, 2));

                if (distToPin < 10) {
                    // Green itself with very subtle breaks (same as backup)
                    height = -0.2 + Math.sin(x * 0.5) * 0.05 + Math.cos((z - PIN_POSITION.z) * 0.4) * 0.05;
                } else {
                    // Beyond green
                    height = -0.2;
                }
            }

            // Override for specific features
            // Tee box (flat platform)
            if (z > -4 && z < 4 && Math.abs(x) < 3) {
                return 3;
            }

            // Green (relatively flat)
            const distToGreen = Math.sqrt(
                Math.pow(x - PIN_POSITION.x, 2) +
                Math.pow(z - PIN_POSITION.z, 2)
            );
            if (distToGreen < 10) {
                return -0.15; // Slightly raised from calculation
            }

            // Bunkers (depressed)
            const distToLeftBunker = Math.sqrt(
                Math.pow(x - BUNKER_LEFT_POSITION.x, 2) +
                Math.pow(z - BUNKER_LEFT_POSITION.z, 2)
            );
            if (distToLeftBunker < 4) {
                return -0.3;
            }

            const distToRightBunker = Math.sqrt(
                Math.pow(x - BUNKER_RIGHT_POSITION.x, 2) +
                Math.pow(z - BUNKER_RIGHT_POSITION.z, 2)
            );
            if (distToRightBunker < 3.5) {
                return -0.3;
            }

            return height;
        }

        function getLieType(x, z) {
            const hole = HOLES[currentHoleIndex];

            // Island-hopping lie detection
            if (hole.type === 'island-hopping') {
                // Check each island
                for (let islandIdx = 0; islandIdx < hole.islands.length; islandIdx++) {
                    const island = hole.islands[islandIdx];
                    const distToIslandCenter = Math.sqrt(
                        Math.pow(x - island.center.x, 2) +
                        Math.pow(z - island.center.z, 2)
                    );

                    if (distToIslandCenter < island.radius) {
                        // On this island
                        // Island 1 = tee, Island 3 = green
                        if (islandIdx === 0 && distToIslandCenter < 10) {
                            return LIE_TYPES.TEE;
                        }

                        if (islandIdx === 2 && distToIslandCenter < 10) {
                            return LIE_TYPES.GREEN;
                        }

                        // Check if in rough ring (outer 10 yards = 9.144m)
                        const roughRingStart = island.radius - 9.144;
                        if (distToIslandCenter >= roughRingStart) {
                            return LIE_TYPES.LIGHT_ROUGH;
                        }

                        return LIE_TYPES.FAIRWAY;
                    }
                }

                // Not on any island = water (should be caught by OB)
                return LIE_TYPES.HEAVY_ROUGH;
            }

            if (hole.type === 'stadium') {
                const dx = x - PIN_POSITION.x;
                const dz = z - PIN_POSITION.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (z > -4 && z < 4 && Math.abs(x) < 3) {
                    return LIE_TYPES.TEE;
                }

                if (dist < 11.5) {
                    return LIE_TYPES.GREEN;
                }

                if (dist < 34) {
                    return LIE_TYPES.FAIRWAY;
                }

                return LIE_TYPES.HEAVY_ROUGH;
            }

            // Standard lie detection for non-island holes
            // Check tee
            if (z > -4 && z < 4 && Math.abs(x) < 3) {
                return LIE_TYPES.TEE;
            }

            // Check green
            const distToGreen = Math.sqrt(
                Math.pow(x - PIN_POSITION.x, 2) +
                Math.pow(z - PIN_POSITION.z, 2)
            );
            if (distToGreen < 10) {
                return LIE_TYPES.GREEN;
            }

            // Check bunkers (look for all bunkers in bunkers array)
            for (let bunker of bunkers) {
                if (bunker.userData && bunker.userData.isBunker) {
                    const distToBunker = Math.sqrt(
                        Math.pow(x - bunker.position.x, 2) +
                        Math.pow(z - bunker.position.z, 2)
                    );
                    if (distToBunker < bunker.userData.radius) {
                        return LIE_TYPES.BUNKER;
                    }
                }
            }

            // Dogleg-right (Hole 4) - mitten-shaped fairway with water check
            if (hole.type === 'dogleg-right') {
                // Check if in water hazard
                if (window.hole4WaterPolygon && isPointInPolygon(x, z, window.hole4WaterPolygon)) {
                    return LIE_TYPES.HEAVY_ROUGH; // Water = penalty/heavy rough
                }

                // Calculate fairway centerline (same logic as terrain coloring)
                const totalDistance = 330;
                const progress = Math.min(1, Math.abs(z) / totalDistance);

                let fairwayCenterX = 0;
                if (progress < 0.6) {
                    const bulgeProgress = progress / 0.6;
                    fairwayCenterX = -Math.sin(bulgeProgress * Math.PI) * 60;
                } else {
                    const returnProgress = (progress - 0.6) / 0.4;
                    const currentBulge = -Math.sin(Math.PI) * 60;
                    fairwayCenterX = currentBulge + returnProgress * 30;
                }

                const distFromCenter = Math.abs(x - fairwayCenterX);

                if (distFromCenter < 50) {
                    return LIE_TYPES.FAIRWAY;
                } else if (distFromCenter >= 50 && distFromCenter < 65) {
                    return LIE_TYPES.LIGHT_ROUGH;
                } else {
                    return LIE_TYPES.HEAVY_ROUGH;
                }
            }

            if (hole.type === 'long-par5') {
                if (window.hole5WaterPolygons && window.hole5WaterPolygons.some(polygon => isPointInPolygon(x, z, polygon))) {
                    return LIE_TYPES.HEAVY_ROUGH;
                }

                if (isInLongPar5Clearing(x, z, hole)) {
                    return LIE_TYPES.FAIRWAY;
                }

                const bands = getLongPar5PathBands(z, hole);
                let inLightRough = false;

                for (const band of bands) {
                    const distFromCenter = Math.abs(x - band.centerX);
                    if (distFromCenter < band.fairwayHalfWidth) {
                        return LIE_TYPES.FAIRWAY;
                    }
                    if (distFromCenter < band.roughHalfWidth) {
                        inLightRough = true;
                    }
                }

                return inLightRough ? LIE_TYPES.LIGHT_ROUGH : LIE_TYPES.HEAVY_ROUGH;
            }

            if (hole.type === 'rockwiga') {
                if (window.rockwigaWaterPolygons && window.rockwigaWaterPolygons.some(polygon => isPointInPolygon(x, z, polygon))) {
                    return LIE_TYPES.HEAVY_ROUGH;
                }

                const projection = getTeeToPinProjection(x, z, hole);
                let fairwayEdge = hole.fairwayHalfWidth || 22;
                let roughEdge = hole.roughHalfWidth || 42;

                if (hole.landingZoneYards) {
                    const landingMeters = hole.landingZoneYards * 0.9144;
                    const distAlong = projection.t * projection.length;
                    if (Math.abs(distAlong - landingMeters) < (hole.landingZoneRadius || 30)) {
                        const boost = hole.landingZoneBoost || 6;
                        fairwayEdge += boost;
                        roughEdge += boost * 0.6;
                    }
                }

                if (projection.dist < fairwayEdge) {
                    return LIE_TYPES.FAIRWAY;
                } else if (projection.dist < roughEdge) {
                    return LIE_TYPES.LIGHT_ROUGH;
                }

                return LIE_TYPES.HEAVY_ROUGH;
            }

            // Dogleg-left - curved fairway logic
            if (hole.type === 'dogleg-left') {
                const totalDistance = 220;
                const progress = Math.min(1, Math.abs(z) / totalDistance);
                const easeProgress = progress * progress * (3 - 2 * progress);
                const fairwayCenterX = -easeProgress * 220;

                const distFromCenter = Math.abs(x - fairwayCenterX);

                if (distFromCenter < 22) {
                    return LIE_TYPES.FAIRWAY;
                } else if (distFromCenter >= 22 && distFromCenter < 38) {
                    return LIE_TYPES.LIGHT_ROUGH;
                } else {
                    return LIE_TYPES.HEAVY_ROUGH;
                }
            }

            // Straight hole - simple center corridor
            if (Math.abs(x) < 12) {
                return LIE_TYPES.FAIRWAY; // Center corridor
            } else if (Math.abs(x) >= 12 && Math.abs(x) < 20) {
                return LIE_TYPES.LIGHT_ROUGH; // First cut
            } else {
                return LIE_TYPES.HEAVY_ROUGH; // Deep rough
            }
        }

        function checkTreeCollision() {
            for (let tree of trees) {
                // Check horizontal distance to tree
                const dx = ballPosition.x - tree.position.x;
                const dz = ballPosition.z - tree.position.z;
                const horizontalDist = Math.sqrt(dx * dx + dz * dz);

                // Check if ball is within tree collision radius and height
                if (horizontalDist < tree.radius + BALL_RADIUS &&
                    ballPosition.y >= tree.position.y &&
                    ballPosition.y <= tree.position.y + tree.height) {

                    // Ball hit tree - bounce off
                    const normal = new THREE.Vector2(dx, dz).normalize();

                    // Reflect velocity
                    const dot = ballVelocity.x * normal.x + ballVelocity.z * normal.y;
                    ballVelocity.x = (ballVelocity.x - 2 * dot * normal.x) * 0.5; // 50% energy loss
                    ballVelocity.z = (ballVelocity.z - 2 * dot * normal.y) * 0.5;
                    ballVelocity.y *= 0.7; // Reduce vertical velocity

                    // Push ball outside collision radius
                    const pushDist = tree.radius + BALL_RADIUS - horizontalDist;
                    ballPosition.x += normal.x * pushDist;
                    ballPosition.z += normal.y * pushDist;

                    console.log('Ball hit tree!');
                    break;
                }
            }
        }

        function checkOutOfBounds() {
            const hole = HOLES[currentHoleIndex];
            const x = ballPosition.x;
            const z = ballPosition.z;

            // Island-hopping: out of bounds if not on any island (in water)
            if (hole.type === 'island-hopping') {
                // Check if ball has gone underwater (below sea level at y = 0)
                if (ballPosition.y < -0.5) {
                    return true; // Ball went underwater = OB
                }

                // Check if ball is on any island (horizontally)
                for (let island of hole.islands) {
                    const distToIslandCenter = Math.sqrt(
                        Math.pow(x - island.center.x, 2) +
                        Math.pow(z - island.center.z, 2)
                    );

                    if (distToIslandCenter < island.radius) {
                        return false; // Ball is on an island, safe!
                    }
                }

                return true; // Not on any island = in water = OB
            }

            if (hole.type === 'stadium') {
                const dx = x - PIN_POSITION.x;
                const dz = z - PIN_POSITION.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                return dist > 90;
            }

            if (hole.type === 'rockwiga') {
                if (window.rockwigaWaterPolygons && window.rockwigaWaterPolygons.some(polygon => isPointInPolygon(x, z, polygon))) {
                    return true;
                }
            }

            // Check if ball is in water (outside terrain bounds)
            // Par 3: terrain is 200x300m, Par 4 dogleg-left: 500x500m, Par 4 dogleg-right: wider for mitten
            const terrainBoundX = hole.type === 'dogleg-left'
                ? 250
                : (hole.type === 'dogleg-right'
                    ? 200
                    : (hole.type === 'long-par5'
                        ? 130
                        : (hole.type === 'rockwiga'
                            ? (hole.terrainSize ? hole.terrainSize.width / 2 : 180)
                            : (hole.type === 'stadium' ? 130 : 100))));
            const terrainBoundZ = hole.type === 'dogleg-left'
                ? 250
                : (hole.type === 'dogleg-right'
                    ? 350
                    : (hole.type === 'long-par5'
                        ? 500
                        : (hole.type === 'rockwiga'
                            ? (hole.terrainSize ? hole.terrainSize.length / 2 : 360)
                            : (hole.type === 'stadium' ? 160 : 150))));
            if (Math.abs(x) > terrainBoundX || Math.abs(z) > terrainBoundZ) {
                return true;
            }

            // Calculate fairway center at this position for lateral OB
            if (hole.type === 'dogleg-left') {
                const totalDistance = 220;
                const progress = Math.min(1, Math.abs(z) / totalDistance);
                const easeProgress = progress * progress * (3 - 2 * progress);
                const fairwayCenterX = -easeProgress * 220;

                // Distance from fairway center
                const distFromCenter = Math.abs(x - fairwayCenterX);
                const OB_DISTANCE = 50 + 4.572;

                if (distFromCenter > OB_DISTANCE) {
                    return true;
                }
            } else if (hole.type === 'dogleg-right') {
                // Hole 4: Mitten-shaped fairway OB detection
                const totalDistance = 330;
                const progress = Math.min(1, Math.abs(z) / totalDistance);

                let fairwayCenterX = 0;
                if (progress < 0.6) {
                    const bulgeProgress = progress / 0.6;
                    fairwayCenterX = -Math.sin(bulgeProgress * Math.PI) * 60;
                } else {
                    const returnProgress = (progress - 0.6) / 0.4;
                    const currentBulge = -Math.sin(Math.PI) * 60;
                    fairwayCenterX = currentBulge + returnProgress * 30;
                }

                // Distance from fairway center
                const distFromCenter = Math.abs(x - fairwayCenterX);

                // OB is 5 yards (4.572m) beyond tree line (trees are at ~55m from center)
                const OB_DISTANCE = 70 + 4.572;

                if (distFromCenter > OB_DISTANCE) {
                    return true;
                }
            } else if (hole.type === 'long-par5') {
                const nearestBand = getLongPar5NearestBand(x, z, hole);
                const OB_DISTANCE = 60 + 4.572; // OB beyond rough

                if (nearestBand.dist > OB_DISTANCE) {
                    return true;
                }
            } else if (hole.type === 'rockwiga') {
                const projection = getTeeToPinProjection(x, z, hole);
                const OB_DISTANCE = hole.obDistance || 70;

                if (projection.dist > OB_DISTANCE) {
                    return true;
                }
            } else {
                // Par 3 - straight hole, check lateral distance only
                const distFromCenter = Math.abs(x);
                const OB_DISTANCE = 40 + 4.572; // 5 yards beyond trees

                if (distFromCenter > OB_DISTANCE) {
                    return true;
                }
            }

            return false;
        }

        function scoreHole() {
            // Called when hole is complete (either ball in cup or gimmie)
            const player = window.golfPar3Players[window.currentPlayerIndex];
            player.holed = true;
            player.finalScore = strokes;

            // Save hole score
            const currentHole = HOLES[currentHoleIndex];
            player.holeScores[currentHoleIndex] = strokes;

            const scoreText = getScoreText(strokes, currentHole.par);
            alert(`${player.name} - Hole ${currentHole.number} complete in ${strokes}! ${scoreText}`);

            // Save state then switch to next player
            savePlayerState();

            // Check if all players holed out on current hole
            const allHoled = window.golfPar3Players.every(p => p.holed);
            if (allHoled) {
                setTimeout(() => {
                    advanceToNextHole();
                }, 2000);
            } else {
                // Switch to farthest player who hasn't holed
                setTimeout(() => {
                    switchToFarthestPlayer();
                }, 2000);
            }
        }

        function checkHole() {
            const distToCup = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );

            if (distToCup < 0.054) { // Cup radius
                scoreHole();
            }
        }

        function getScoreText(strokes, par) {
            const diff = strokes - par;
            if (strokes === 1) return 'ACE!';
            if (diff === -3) return 'Albatross!';
            if (diff === -2) return 'Eagle!';
            if (diff === -1) return 'Birdie!';
            if (diff === 0) return 'Par';
            if (diff === 1) return 'Bogey';
            if (diff === 2) return 'Double Bogey';
            return `+${diff}`;
        }

        function advanceToNextHole() {
            // Draft Golf mode: reset players and start new hole
            if (draftGolfEnabled) {
                const teeBoxSurfaceHeight = 3.1;
                const properTeeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;
                const hole = HOLES[currentHoleIndex];
                const teePos = hole.teePosition || TEE_POSITION;

                window.golfPar3Players.forEach(player => {
                    player.ballPosition = { x: teePos.x, y: properTeeY, z: teePos.z };
                    player.strokes = 0;
                    player.holed = false;
                    player.currentHole = currentHoleIndex;
                    player.baseDirection = undefined;
                    player.aimAdjustment = 0;
                });

                window.currentPlayerIndex = 0;
                loadPlayerState();
                updatePlayerDisplay();

                // Start new draft golf hole
                startDraftGolfHole();
                return;
            }

            // Single-hole mode: restart the same hole
            if (selectedHoles !== 'all') {
                // Show scores, then restart same hole
                showFinalScores();

                // Restart the same hole
                setupHole(currentHoleIndex);

                // Reset all players for new round on same hole
                const teeBoxSurfaceHeight = 3.1;
                const properTeeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

                window.golfPar3Players.forEach(player => {
                    player.ballPosition = { x: HOLES[currentHoleIndex].teePosition.x, y: properTeeY, z: HOLES[currentHoleIndex].teePosition.z };
                    player.strokes = 0;
                    player.holed = false;
                    player.currentHole = currentHoleIndex;
                    player.holeScores[currentHoleIndex] = 0;
                    // Reset camera direction for new hole - will be calculated toward pin on first load
                    player.baseDirection = undefined;
                    player.aimAdjustment = 0;
                });

                // Load first player's state
                loadPlayerState();
                updatePlayerDisplay();

                console.log(`Restarting Hole ${HOLES[currentHoleIndex].number}`);
                return;
            }

            // Full round mode: advance through all holes
            if (currentHoleIndex < HOLES.length - 1) {
                // Move to next hole
                currentHoleIndex++;
                setupHole(currentHoleIndex);

                // Reset all players for new hole
                const teeBoxSurfaceHeight = 3.1;
                const properTeeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

                window.golfPar3Players.forEach(player => {
                    player.ballPosition = { x: HOLES[currentHoleIndex].teePosition.x, y: properTeeY, z: HOLES[currentHoleIndex].teePosition.z };
                    player.strokes = 0;
                    player.holed = false;
                    player.currentHole = currentHoleIndex;
                    // Reset camera direction for new hole - will be calculated toward pin on first load
                    player.baseDirection = undefined;
                    player.aimAdjustment = 0;
                });

                // Load first player's state
                loadPlayerState();
                updatePlayerDisplay();

                console.log(`Advanced to Hole ${HOLES[currentHoleIndex].number}`);
            } else {
                // All holes complete - show final scores and restart
                showFinalScores();
                resetAllPlayers();
            }
        }

        function showFinalScores() {
            let scoreText = 'Final Scores:\n\n';
            window.golfPar3Players.forEach(player => {
                let totalScore = 0;
                let scoreLine = `${player.name}:\n`;

                // Show individual hole scores
                player.holeScores.forEach((score, index) => {
                    const hole = HOLES[index];
                    const diff = score - hole.par;
                    const diffText = diff === 0 ? 'E' : (diff > 0 ? `+${diff}` : `${diff}`);
                    scoreLine += `  Hole ${hole.number}: ${score} (${diffText})\n`;
                    totalScore += score;
                });

                // Calculate total vs par
                const totalPar = HOLES.reduce((sum, hole) => sum + hole.par, 0);
                const totalDiff = totalScore - totalPar;
                const totalDiffText = totalDiff === 0 ? 'E' : (totalDiff > 0 ? `+${totalDiff}` : `${totalDiff}`);

                scoreLine += `  Total: ${totalScore} (${totalDiffText})\n\n`;
                scoreText += scoreLine;
            });
            alert(scoreText);
        }

        function resetAllPlayers() {
            // Reset back to starting hole based on selectedHoles
            const selectedHoleNumber = Number(selectedHoles);
            if (selectedHoles !== 'all' && Number.isFinite(selectedHoleNumber)) {
                currentHoleIndex = Math.max(0, Math.min(selectedHoleNumber - 1, HOLES.length - 1));
            } else {
                currentHoleIndex = 0; // Full round starts at hole 1
            }

            setupHole(currentHoleIndex);

            // Reset all players
            const teeBoxSurfaceHeight = 3.1;
            const properTeeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            window.golfPar3Players.forEach(player => {
                player.ballPosition = { x: HOLES[currentHoleIndex].teePosition.x, y: properTeeY, z: HOLES[currentHoleIndex].teePosition.z };
                player.strokes = 0;
                player.holed = false;
                player.finalScore = undefined;
                player.holeScores = [];
                player.currentHole = currentHoleIndex;
            });
            window.currentPlayerIndex = 0;
            loadPlayerState();
            updatePlayerDisplay();
        }

        function updateUI() {
            // UI is now handled by top-left player info and floating yardage marker
            // No need to update removed elements
        }

        function resetHole() {
            strokes = 0;
            ballInFlight = false;
            resetBallPosition();

            // Update current player's saved state
            const player = window.golfPar3Players[window.currentPlayerIndex];
            if (player) {
                player.ballPosition = { x: ballPosition.x, y: ballPosition.y, z: ballPosition.z };
                player.strokes = 0;
                player.holed = false;
            }

            // Reset camera to behind-ball view
            currentView = 'behind-ball';
            updateCameraPosition(false);

            updatePlayerDisplay();
            updateUI();
            document.getElementById('shotDetails').style.display = 'none';
        }

        function updatePlayerDisplay() {
            if (!window.golfPar3Players || window.golfPar3Players.length === 0) return;

            const player = window.golfPar3Players[window.currentPlayerIndex];

            // Update right panel player indicator
            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }

            // Update top-left player info
            const topNameDiv = document.getElementById('topPlayerName');
            if (topNameDiv) {
                topNameDiv.textContent = player.name;
                topNameDiv.style.color = player.color;
            }

            // Update shot number (current shot they're about to take)
            const shotNumDiv = document.getElementById('shotNumber');
            if (shotNumDiv) {
                shotNumDiv.textContent = (strokes + 1).toString();
            }

            // Update stroke count
            const strokeDiv = document.getElementById('strokeCount');
            if (strokeDiv) {
                strokeDiv.textContent = strokes.toString();
            }

            // Update player info border color
            const playerInfoDiv = document.getElementById('playerInfo');
            if (playerInfoDiv) {
                playerInfoDiv.style.borderColor = player.color;
            }
        }

        function savePlayerState() {
            // Save current player's ball position and strokes
            const player = window.golfPar3Players[window.currentPlayerIndex];
            player.ballPosition = { x: ballPosition.x, y: ballPosition.y, z: ballPosition.z };
            player.strokes = strokes;
            player.baseDirection = baseDirection; // Save camera direction
            player.aimAdjustment = aimAdjustment; // Save aim adjustment
            console.log(`Saved state for ${player.name}: strokes=${strokes}, position=(${ballPosition.x.toFixed(1)}, ${ballPosition.y.toFixed(1)}, ${ballPosition.z.toFixed(1)}), baseDir=${baseDirection.toFixed(1)}¬∞`);
        }

        function loadPlayerState() {
            // Load current player's ball position and strokes
            const player = window.golfPar3Players[window.currentPlayerIndex];
            ballPosition.set(player.ballPosition.x, player.ballPosition.y, player.ballPosition.z);
            strokes = player.strokes;
            ball.position.copy(ballPosition);

            // Update lie type based on position
            currentLie = getLieType(ballPosition.x, ballPosition.z);

            // Restore saved camera direction, or calculate toward pin if first time or on tee
            if (player.baseDirection !== undefined && currentLie.name !== 'tee') {
                // Restore saved direction only if not on tee
                baseDirection = player.baseDirection;
                aimAdjustment = player.aimAdjustment || 0;
                console.log(`Restored saved direction: baseDirection=${baseDirection.toFixed(1)}¬∞, aimAdjustment=${aimAdjustment.toFixed(1)}¬∞`);
            } else {
                // On tee or first time - always point toward pin
                const dx = PIN_POSITION.x - ballPosition.x;
                const dz = PIN_POSITION.z - ballPosition.z;
                baseDirection = Math.atan2(dx, -dz) * 180 / Math.PI;
                aimAdjustment = 0;
                console.log(`Calculated new direction toward pin (on tee=${currentLie.name === 'tee'}): dx=${dx.toFixed(1)}, dz=${dz.toFixed(1)}, baseDirection=${baseDirection.toFixed(1)}¬∞`);
                console.log(`Ball position: (${ballPosition.x.toFixed(1)}, ${ballPosition.z.toFixed(1)}), Pin position: (${PIN_POSITION.x.toFixed(1)}, ${PIN_POSITION.z.toFixed(1)})`);
            }

            updateUI();
            updateAimIndicator();
            console.log(`Loaded state for ${player.name}: strokes=${strokes}, position=(${ballPosition.x.toFixed(1)}, ${ballPosition.y.toFixed(1)}, ${ballPosition.z.toFixed(1)}), lie=${currentLie.name}, baseDir=${baseDirection.toFixed(1)}¬∞`);
        }

        function getDistanceToHole(pos) {
            return Math.sqrt(
                Math.pow(pos.x - PIN_POSITION.x, 2) +
                Math.pow(pos.z - PIN_POSITION.z, 2)
            );
        }

        function switchToFarthestPlayer() {
            // Draft Golf mode handles its own player switching
            if (draftGolfEnabled) return;
            if (!window.golfPar3Players || window.golfPar3Players.length <= 1) return;

            // Find player farthest from hole who hasn't holed out
            let farthestIndex = -1;
            let maxDistance = -1;

            window.golfPar3Players.forEach((player, index) => {
                if (!player.holed) {
                    const distance = getDistanceToHole(player.ballPosition);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        farthestIndex = index;
                    }
                }
            });

            // If all players holed out, don't switch
            if (farthestIndex === -1) return;

            // Switch to farthest player if different from current
            if (farthestIndex !== window.currentPlayerIndex) {
                window.currentPlayerIndex = farthestIndex;
                localStorage.setItem('golfPar3CurrentPlayer', window.currentPlayerIndex.toString());

                loadPlayerState();
                updatePlayerDisplay();

                const player = window.golfPar3Players[window.currentPlayerIndex];
                const distYards = (maxDistance * 1.09361).toFixed(0);
                console.log(`Switched to ${player.name} (${distYards} yards from hole)`);

                // After a shot finishes and we switch players, default the camera
                // to behind-ball looking toward the pin so the next player always
                // gets a clean aiming view.
                currentView = 'behind-ball';
                updateCameraPosition(false);
            }
        }

        function nextPlayer() {
            // Deprecated - keeping for compatibility but automatic switching is now used
            if (!window.golfPar3Players || window.golfPar3Players.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.golfPar3Players.length;
            localStorage.setItem('golfPar3CurrentPlayer', window.currentPlayerIndex.toString());

            loadPlayerState();
            updatePlayerDisplay();

            console.log('Switched to player:', window.golfPar3Players[window.currentPlayerIndex].name);
        }

        // ========== DRAFT GOLF CORE FUNCTIONS ==========

        function initDraftGolf(type, variant) {
            draftGolfEnabled = true;
            draftGolfType = type;
            draftGolfVariant = variant || 'basic';

            console.log(`Initializing Draft Golf: type=${type}, variant=${draftGolfVariant}`);

            // Setup players
            if (type === 'solo') {
                setupSoloModePlayers();
            } else {
                setupMultiplayerPlayers();
            }

            document.getElementById('draftGolfStatus').style.display = 'block';
            startDraftGolfHole();

            console.log(`Draft Golf initialized: type=${type}, variant=${variant}`);
        }
        window.initDraftGolf = initDraftGolf; // Expose for button onclick

        function setupSoloModePlayers() {
            const teeBoxSurfaceHeight = 3.1;
            const teeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            window.golfPar3Players = [
                { name: 'You', color: '#4ade80', isAI: false, handicap: 15, autoAim: true },
                { name: 'AI-Alpha', color: '#f87171', isAI: true, handicap: DRAFT_GOLF_CONFIG.AI_HANDICAPS[0], autoAim: true },
                { name: 'AI-Beta', color: '#60a5fa', isAI: true, handicap: DRAFT_GOLF_CONFIG.AI_HANDICAPS[1], autoAim: true },
                { name: 'AI-Gamma', color: '#fbbf24', isAI: true, handicap: DRAFT_GOLF_CONFIG.AI_HANDICAPS[2], autoAim: true }
            ];
            initDraftPlayerPositions(teeY);
        }

        function setupMultiplayerPlayers() {
            const teeBoxSurfaceHeight = 3.1;
            const teeY = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            // Use existing players from electron menu, ensure we have 4
            // If less than 4, pad with default players
            const defaultColors = ['#4ade80', '#f87171', '#60a5fa', '#fbbf24'];
            while (window.golfPar3Players.length < 4) {
                const idx = window.golfPar3Players.length;
                window.golfPar3Players.push({
                    name: `Player ${idx + 1}`,
                    color: defaultColors[idx] || '#888888',
                    isAI: false,
                    handicap: 15,
                    autoAim: true
                });
            }

            // Mark all players as human (not AI)
            window.golfPar3Players.forEach(p => {
                p.isAI = false;
            });

            initDraftPlayerPositions(teeY);
        }

        function initDraftPlayerPositions(teeY) {
            const hole = HOLES[currentHoleIndex];
            const teePos = hole.teePosition || TEE_POSITION;

            window.golfPar3Players.forEach((p, i) => {
                p.ballPosition = { x: teePos.x, y: teeY, z: teePos.z };
                p.strokes = 0;
                p.holed = false;
                p.holeScores = [];
                p.currentHole = currentHoleIndex;
            });
            window.currentPlayerIndex = 0;
        }

        function startDraftGolfHole() {
            draftGolfState = {
                shotRound: 0,
                shotResults: [],
                draftOrder: [],
                currentDrafter: 0,
                picks: {}
            };
            startShotRound();
        }

        function startShotRound() {
            draftGolfState.shotRound++;
            draftGolfState.shotResults = [];
            draftGolfState.picks = {};
            draftGolfPhase = 'WAITING_FOR_SHOTS';

            console.log(`üéØ Draft Golf: Starting shot round ${draftGolfState.shotRound}, phase=${draftGolfPhase}`);

            // Randomize draft order (basic: once per hole, advanced: each round)
            if (draftGolfVariant === 'advanced' || draftGolfState.shotRound === 1) {
                draftGolfState.draftOrder = shuffleDraftArray([0, 1, 2, 3]);
            }

            updateDraftStatus(`Shot round ${draftGolfState.shotRound} - ${window.golfPar3Players[0].name}'s turn`);

            // Set first player
            window.currentPlayerIndex = 0;
            loadPlayerState();
            promptNextShot();
        }

        function promptNextShot() {
            // Count how many players still need to shoot (exclude those already holed)
            const playersStillPlaying = window.golfPar3Players.filter(p => !p.holed);
            const activeCount = draftGolfState.shotResults.length;

            console.log(`üéØ promptNextShot: activeCount=${activeCount}, playersStillPlaying=${playersStillPlaying.length}`);

            // If all non-holed players have shot, go to draft phase
            if (activeCount >= playersStillPlaying.length) {
                if (playersStillPlaying.length === 0) {
                    // Everyone is holed, end the hole
                    console.log('üéØ All players holed out, ending hole');
                    endDraftGolfHole();
                    return;
                }
                console.log('üéØ All players have shot, entering draft phase');
                enterDraftPhase();
                return;
            }

            // Find the next player who hasn't holed out
            let playerIndex = -1;
            let shotCount = 0;
            for (let i = 0; i < window.golfPar3Players.length; i++) {
                if (!window.golfPar3Players[i].holed) {
                    if (shotCount === activeCount) {
                        playerIndex = i;
                        break;
                    }
                    shotCount++;
                }
            }

            if (playerIndex === -1) {
                console.log('üéØ No player found, entering draft phase');
                enterDraftPhase();
                return;
            }

            const player = window.golfPar3Players[playerIndex];

            console.log(`üéØ Next player: ${player.name} (index ${playerIndex}), isAI=${player.isAI}`);

            window.currentPlayerIndex = playerIndex;
            loadPlayerState();
            updatePlayerDisplay();

            updateDraftStatus(`${player.name}'s turn to hit (${activeCount + 1}/${playersStillPlaying.length})`);

            if (player.isAI) {
                // Simulate AI shot after delay
                console.log(`üéØ AI player ${player.name} will shoot in 1.5s`);
                setTimeout(() => simulateAndExecuteAIShot(playerIndex), 1500);
            } else {
                console.log(`üéØ Human player ${player.name} - waiting for shot`);
            }
        }

        // ========== AI SHOT SIMULATION ==========

        function simulateAndExecuteAIShot(playerIndex) {
            const player = window.golfPar3Players[playerIndex];
            const pos = player.ballPosition;
            const distToHole = getDistanceToHole(pos) * 1.09361; // yards
            const skill = AI_SKILL_PROFILES[player.handicap] || AI_SKILL_PROFILES[15];
            const lie = getLieType(pos.x, pos.z);

            // Determine shot type and base parameters
            let speed, vla, spin;
            if (distToHole <= 40) {
                // Putt
                speed = 3 + distToHole * 0.25;
                vla = 1;
                spin = 0;
            } else if (distToHole <= 100) {
                // Chip/pitch
                speed = 35 + distToHole * 0.3;
                vla = 30 + Math.random() * 10;
                spin = 4000 + Math.random() * 2000;
            } else {
                // Full shot
                speed = 60 + Math.min(distToHole * 0.15, 60);
                vla = 12 + Math.random() * 8;
                spin = 2500 + Math.random() * 2000;
            }

            // Apply skill-based variance
            const variance = (100 - skill.consistency * 100) / 100;
            speed += (Math.random() - 0.5) * speed * variance * 0.3;
            vla += (Math.random() - 0.5) * 5 * variance;
            const hla = (Math.random() - 0.5) * 15 * variance;

            // Apply lie penalty
            const lieQuality = mapLieToQuality(lie);
            speed *= lieQuality.factor;

            console.log(`AI Shot: ${player.name} at ${distToHole.toFixed(0)} yds, speed=${speed.toFixed(1)} mph, vla=${vla.toFixed(1)}¬∞`);

            // Execute shot through normal handler
            handleShot({ detail: {
                speed: Math.max(5, speed),
                vla: Math.max(1, vla),
                hla: hla,
                total_spin: spin,
                spin_axis: (Math.random() - 0.5) * 10
            }});
        }

        function mapLieToQuality(lie) {
            const map = {
                'Tee': DRAFT_LIE_QUALITY.PERFECT,
                'Green': DRAFT_LIE_QUALITY.PERFECT,
                'Fairway': DRAFT_LIE_QUALITY.GOOD,
                'Light Rough': DRAFT_LIE_QUALITY.MODERATE,
                'Heavy Rough': DRAFT_LIE_QUALITY.DIFFICULT,
                'Bunker': DRAFT_LIE_QUALITY.TERRIBLE
            };
            return map[lie.name] || DRAFT_LIE_QUALITY.MODERATE;
        }

        // ========== SHOT RECORDING ==========

        function recordDraftGolfShot(playerIndex, endPos) {
            console.log(`üéØ recordDraftGolfShot called: playerIndex=${playerIndex}, pos=(${endPos.x.toFixed(1)}, ${endPos.z.toFixed(1)})`);

            const player = window.golfPar3Players[playerIndex];
            const lie = getLieType(endPos.x, endPos.z);
            const lieQuality = mapLieToQuality(lie);
            const dist = getDistanceToHole(endPos) * 1.09361;
            const holed = dist < 0.5;

            draftGolfState.shotResults.push({
                playerIndex: playerIndex,
                position: { x: endPos.x, y: endPos.y, z: endPos.z },
                lieQuality: lieQuality,
                distanceToHole: dist,
                holed: holed
            });

            player.strokes++;

            console.log(`üéØ Draft Golf: ${player.name} shot recorded - ${dist.toFixed(0)} yds, ${lieQuality.name}, total shots=${draftGolfState.shotResults.length}`);

            // Check for hole-out
            if (holed) {
                player.holed = true;
                console.log(`${player.name} holed out!`);
            }

            // Save player state after recording
            savePlayerState();

            setTimeout(() => promptNextShot(), 1500);
        }

        // ========== DRAFT PHASE ==========

        function enterDraftPhase() {
            draftGolfPhase = 'DRAFT_PHASE';
            draftGolfState.currentDrafter = 0;
            showDraftUI();
            processNextPick();
        }

        function showDraftUI() {
            document.getElementById('draftGolfOverlay').style.display = 'block';

            // Build ball cards
            const container = document.getElementById('draftBallCards');
            container.innerHTML = '';

            draftGolfState.shotResults.forEach((shot, idx) => {
                const player = window.golfPar3Players[shot.playerIndex];
                const card = document.createElement('div');
                card.id = `ballCard${idx}`;
                card.style.cssText = `background:#2a2a4e; border:2px solid ${shot.lieQuality.color};
                                      border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s;`;
                card.innerHTML = `
                    <div style="color:${player.color}; font-weight:bold; margin-bottom:8px;">
                        Ball ${idx + 1} (${player.name}'s shot)
                    </div>
                    <div style="font-size:24px; color:#ffd700; font-weight:bold;">${shot.distanceToHole.toFixed(0)} yds to hole</div>
                    <div style="color:${shot.lieQuality.color}; margin-top:4px;">${shot.lieQuality.name} lie</div>
                    ${shot.holed ? '<div style="color:#4ade80; margin-top:8px;">IN THE HOLE!</div>' : ''}
                `;
                card.onclick = () => humanPickBall(idx);
                container.appendChild(card);
            });

            // Show draft order (only include players who haven't holed)
            const draftOrderNames = draftGolfState.draftOrder
                .filter(i => !window.golfPar3Players[i].holed)
                .map(i => window.golfPar3Players[i].name);
            document.getElementById('draftOrder').textContent = 'Draft order: ' + draftOrderNames.join(' -> ');
        }

        function processNextPick() {
            // Skip players who have already holed out
            while (draftGolfState.currentDrafter < draftGolfState.draftOrder.length) {
                const pickerIndex = draftGolfState.draftOrder[draftGolfState.currentDrafter];
                if (!window.golfPar3Players[pickerIndex].holed) {
                    break;
                }
                draftGolfState.currentDrafter++;
            }

            if (draftGolfState.currentDrafter >= draftGolfState.draftOrder.length) {
                completeDraftPhase();
                return;
            }

            const pickerIndex = draftGolfState.draftOrder[draftGolfState.currentDrafter];
            const picker = window.golfPar3Players[pickerIndex];

            document.getElementById('draftCurrentPicker').innerHTML =
                `<span style="color:${picker.color}">${picker.name}</span>'s turn to pick (${draftGolfState.currentDrafter + 1}/${draftGolfState.draftOrder.filter(i => !window.golfPar3Players[i].holed).length})`;

            if (picker.isAI) {
                setTimeout(() => aiPickBall(pickerIndex), 1000);
            }
            // Human waits for click
        }

        function getAvailableBalls() {
            const picked = Object.values(draftGolfState.picks);
            return draftGolfState.shotResults
                .map((s, i) => ({ ...s, index: i }))
                .filter(s => !picked.includes(s.index));
        }

        function humanPickBall(ballIndex) {
            const pickerIndex = draftGolfState.draftOrder[draftGolfState.currentDrafter];
            const picker = window.golfPar3Players[pickerIndex];

            if (picker.isAI) return; // Not human's turn
            if (Object.values(draftGolfState.picks).includes(ballIndex)) return; // Already picked

            executePick(pickerIndex, ballIndex);
        }

        function aiPickBall(pickerIndex) {
            const available = getAvailableBalls();

            if (available.length === 0) {
                draftGolfState.currentDrafter++;
                setTimeout(() => processNextPick(), 500);
                return;
            }

            // AI picks best available (closest + best lie)
            let best = available[0];
            let bestScore = -Infinity;

            available.forEach(ball => {
                const score = (300 - ball.distanceToHole) + (ball.lieQuality.factor * 50);
                if (score > bestScore) {
                    bestScore = score;
                    best = ball;
                }
            });

            executePick(pickerIndex, best.index);
        }

        function executePick(pickerIndex, ballIndex) {
            draftGolfState.picks[pickerIndex] = ballIndex;

            const picker = window.golfPar3Players[pickerIndex];
            const ball = draftGolfState.shotResults[ballIndex];

            console.log(`${picker.name} picked ball ${ballIndex + 1} (${ball.distanceToHole.toFixed(0)} yds)`);

            // Mark card as picked
            const card = document.getElementById(`ballCard${ballIndex}`);
            if (card) {
                card.style.opacity = '0.4';
                card.style.cursor = 'not-allowed';
                card.innerHTML += `<div style="color:${picker.color}; margin-top:8px;">${picker.name}</div>`;
            }

            draftGolfState.currentDrafter++;
            setTimeout(() => processNextPick(), 800);
        }

        function completeDraftPhase() {
            document.getElementById('draftGolfOverlay').style.display = 'none';

            // Move each player to their picked ball
            Object.entries(draftGolfState.picks).forEach(([playerIdx, ballIdx]) => {
                const player = window.golfPar3Players[parseInt(playerIdx)];
                const ball = draftGolfState.shotResults[ballIdx];
                player.ballPosition = { ...ball.position };

                // Check if they picked a holed ball
                if (ball.holed) {
                    player.holed = true;
                }
            });

            // Check if everyone has holed out
            const allHoled = window.golfPar3Players.every(p => p.holed);
            if (allHoled) {
                endDraftGolfHole();
            } else {
                // Start next shot round
                setTimeout(() => startShotRound(), 1000);
            }
        }

        function endDraftGolfHole() {
            draftGolfPhase = 'IDLE';

            // Score the hole for each player
            window.golfPar3Players.forEach(p => {
                p.holeScores[currentHoleIndex] = p.strokes;
            });

            // Show results
            const resultsText = window.golfPar3Players.map(p =>
                `${p.name}: ${p.strokes} strokes`
            ).join('\n');

            alert('Hole Complete!\n\n' + resultsText);

            // Advance to next hole or restart
            advanceToNextHole();
        }

        function updateDraftStatus(text) {
            document.getElementById('draftStatusText').textContent = `Draft Golf: ${text}`;
        }

        function shuffleDraftArray(arr) {
            const a = [...arr];
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        function exitDraftGolf() {
            draftGolfEnabled = false;
            draftGolfPhase = 'IDLE';
            document.getElementById('draftGolfStatus').style.display = 'none';
            document.getElementById('draftGolfOverlay').style.display = 'none';

            // Reset to single player
            window.golfPar3Players = [{ name: 'Player 1', color: '#4ade80', autoAim: true }];
            window.currentPlayerIndex = 0;
            resetHole();
        }
        window.exitDraftGolf = exitDraftGolf;

        // ========== END DRAFT GOLF FUNCTIONS ==========

        function updateCameraPosition(autoRevert = true) {
            // Skip automatic camera if in debug mode
            if (debugMode) {
                console.log('Debug mode active, skipping camera update');
                return;
            }

            // PERFORMANCE: Console.log disabled - was spamming every frame and killing FPS
            // console.log(`updateCameraPosition called: view=${currentView}, autoRevert=${autoRevert}, ballInFlight=${ballInFlight}`);

            switch (currentView) {
                case 'behind-ball':
                    // Behind ball view that rotates with aim adjustment from base direction
                    const totalAim = baseDirection + aimAdjustment;
                    const aimRad = -totalAim * Math.PI / 180; // Negative to fix rotation direction
                    const distance = 3;
                    const height = 1.7;

                    // Calculate camera position behind ball based on aim
                    const camX = ballPosition.x + distance * Math.sin(aimRad);
                    const camZ = ballPosition.z + distance * Math.cos(aimRad);

                    camera.position.set(camX, ballPosition.y + height, camZ);

                    // Look in the direction of aim
                    const lookX = ballPosition.x - distance * Math.sin(aimRad);
                    const lookZ = ballPosition.z - distance * Math.cos(aimRad);
                    camera.lookAt(lookX, ballPosition.y, lookZ);
                    break;

                case 'tee-box':
                    // Behind ball view at eye level (like standing on tee box)
                    camera.position.set(
                        ballPosition.x,
                        ballPosition.y + 1.7,  // Eye level height (~5'7")
                        ballPosition.z + 3     // Close behind ball
                    );
                    camera.lookAt(PIN_POSITION.x, PIN_POSITION.y, PIN_POSITION.z);
                    break;

                case 'auto-follow':
                case 'follow':
                    if (ballInFlight) {
                        // Follow ball during flight
                        camera.position.set(
                            ballPosition.x - 8,
                            ballPosition.y + 6,
                            ballPosition.z + 12
                        );
                        camera.lookAt(ballPosition);
                    } else {
                        // No ball in flight - show overview
                        camera.position.set(0, 25, -60);
                        camera.lookAt(0, 0, -60);
                    }
                    break;

                case 'green':
                    // Green-side view looking back at fairway
                    camera.position.set(
                        PIN_POSITION.x,
                        2,
                        PIN_POSITION.z - 15
                    );
                    camera.lookAt(PIN_POSITION.x, 0, PIN_POSITION.z + 20);
                    break;

                case 'overhead':
                    // Bird's eye view of entire hole
                    camera.position.set(0, 80, -60);
                    camera.lookAt(0, 0, -60);
                    break;

                case 'drone':
                    // Elevated side view
                    camera.position.set(-40, 35, -60);
                    camera.lookAt(0, 0, -60);
                    break;
            }
        }

        function cycleView() {
            const views = ['behind-ball', 'tee-box', 'auto-follow', 'follow', 'green', 'overhead', 'drone'];
            const currentIndex = views.indexOf(currentView);
            const previousView = currentView;
            currentView = views[(currentIndex + 1) % views.length];

            console.log(`Camera view changed: ${previousView} -> ${currentView}`);

            // Save the view in case auto-follow needs to revert
            if (currentView !== 'auto-follow') {
                savedView = currentView;
            }

            // Don't auto-revert when manually cycling views
            updateCameraPosition(false);

            // Show camera view notification
            const viewNames = {
                'behind-ball': 'Behind Ball (Aim)',
                'tee-box': 'Tee Box View',
                'auto-follow': 'Auto Follow',
                'follow': 'Manual Follow',
                'green': 'Green View',
                'overhead': 'Overhead',
                'drone': 'Drone View'
            };
            showNotification(`Camera: ${viewNames[currentView]}`);
        }

        function showNotification(message) {
            // Remove existing notification if any
            const existing = document.getElementById('cameraNotification');
            if (existing) {
                existing.remove();
            }

            // Create notification
            const notification = document.createElement('div');
            notification.id = 'cameraNotification';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                pointer-events: none;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Fade out and remove
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updateCamera() {
            // Only update camera for views that need continuous updates
            if (currentView === 'auto-follow' || currentView === 'follow' || currentView === 'tee-box' || currentView === 'behind-ball') {
                updateCameraPosition(true);
            }
            // Other views (green, overhead, drone) are static and don't need frame updates
        }

        function updateYardageMarker() {
            const now = performance.now();
            if (now - lastYardageUpdateTime < YARDAGE_UPDATE_INTERVAL_MS) {
                return;
            }
            lastYardageUpdateTime = now;

            // Calculate distance to pin for dynamic height
            const distToPinM = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );
            const distToPinYards = distToPinM * 1.09361;

            // Dynamic height: starts at 5m when far away, goes down to 2.5m when close
            // Flagstick top is at ~1.9m, so marker should always be above that
            // Interpolate based on distance: 130 yards = 5m height, 0 yards = 2.5m height
            const maxDist = 118.872; // 130 yards in meters
            const maxHeight = 5;
            const minHeight = 2.5; // Keep above flagstick top
            const heightRatio = Math.min(distToPinM / maxDist, 1); // Clamp to 0-1
            const markerHeight = minHeight + (maxHeight - minHeight) * heightRatio;

            // Project pin position to screen coordinates
            pinScreenPos.copy(PIN_POSITION);
            pinScreenPos.y += markerHeight; // Float above the pin with dynamic height
            pinScreenPos.project(camera);

            // Convert to screen coordinates
            const x = Math.round((pinScreenPos.x * 0.5 + 0.5) * window.innerWidth);
            const y = Math.round((-pinScreenPos.y * 0.5 + 0.5) * window.innerHeight);

            // Update marker position
            const marker = document.getElementById('yardageMarker');
            if (marker) {
                // Only show if pin is in front of camera
                const isVisible = pinScreenPos.z < 1;
                if (isVisible !== lastYardageVisible) {
                    marker.style.display = isVisible ? 'block' : 'none';
                    if (isVisible) {
                        marker.style.transform = 'translate(-50%, -100%)';
                    }
                    lastYardageVisible = isVisible;
                }
                if (!isVisible) {
                    return;
                }
                if (x !== lastYardageX) {
                    marker.style.left = x + 'px';
                    lastYardageX = x;
                }
                if (y !== lastYardageY) {
                    marker.style.top = y + 'px';
                    lastYardageY = y;
                }

                // Update distance value - show in feet when on green, yards otherwise
                const distanceDisplay = document.getElementById('yardageValue');
                const labelDisplay = document.querySelector('#yardageMarker .yards-label');

                // Check if on green (within 10m of pin)
                if (distToPinM < 10 && currentLie.name === 'Green') {
                    // Show in feet
                    const distToPinFeet = Math.round(distToPinM * 3.28084);
                    if (distanceDisplay && distToPinFeet !== lastYardageValue) {
                        distanceDisplay.textContent = distToPinFeet;
                        lastYardageValue = distToPinFeet;
                    }
                    if (labelDisplay && lastYardageLabel !== 'FEET') {
                        labelDisplay.textContent = 'FEET';
                        lastYardageLabel = 'FEET';
                    }
                } else {
                    // Show in yards
                    const distToPinYardsRounded = Math.round(distToPinYards);
                    if (distanceDisplay && distToPinYardsRounded !== lastYardageValue) {
                        distanceDisplay.textContent = distToPinYardsRounded;
                        lastYardageValue = distToPinYardsRounded;
                    }
                    if (labelDisplay && lastYardageLabel !== 'YARDS') {
                        labelDisplay.textContent = 'YARDS';
                        lastYardageLabel = 'YARDS';
                    }
                }
            }
        }

        function updateMinimap() {
            if (!minimapCamera || !minimapRenderer) return;

            const now = performance.now();
            const interval = ballInFlight ? MINIMAP_UPDATE_INTERVAL_MS : MINIMAP_IDLE_INTERVAL_MS;
            if (now - lastMinimapUpdateTime < interval) {
                return;
            }
            lastMinimapUpdateTime = now;

            const hole = HOLES[currentHoleIndex];
            const pinPos = hole.pinPosition;

            // Calculate center point between ball and pin
            const centerX = (ballPosition.x + pinPos.x) / 2;
            const centerZ = (ballPosition.z + pinPos.z) / 2;

            // Position camera above the center point
            minimapCamera.position.set(centerX, 200, centerZ);
            minimapCamera.lookAt(centerX, 0, centerZ);

            // Calculate distance and adjust camera zoom
            const distance = Math.sqrt(
                Math.pow(ballPosition.x - pinPos.x, 2) +
                Math.pow(ballPosition.z - pinPos.z, 2)
            );

            // Adjust orthographic camera size based on distance
            const zoom = Math.max(distance / 2 + 30, 80);
            minimapCamera.left = -zoom;
            minimapCamera.right = zoom;
            minimapCamera.top = zoom;
            minimapCamera.bottom = -zoom;
            minimapCamera.updateProjectionMatrix();

            // Temporarily disable fog for clearer minimap view
            const originalFog = scene.fog;
            scene.fog = null;

            // Render the minimap
            minimapRenderer.render(scene, minimapCamera);

            // Restore fog
            scene.fog = originalFog;
        }

        function checkGimme() {
            // Check if ball has stopped and stopped time is set
            if (!ballStoppedTime) return;

            // Check if ball is still stopped (not moving)
            const horizontalSpeed = Math.sqrt(ballVelocity.x * ballVelocity.x + ballVelocity.z * ballVelocity.z);
            if (horizontalSpeed > 0.05 || ballInFlight) {
                // Ball is still moving
                return;
            }

            const timeStopped = performance.now() - ballStoppedTime;
            if (timeStopped < GIMME_DELAY_MS) {
                // Not enough time has passed since ball stopped
                return;
            }

            // Calculate distance to hole
            const distToHole = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );
            const distToHoleYards = distToHole * 1.09361;

            // Check for gimme (ONLY if gimme circles are enabled AND ball is within 15 yards)
            if (!gimmieCirclesEnabled || distToHoleYards > 15) return;

            const ft5InMeters = 5 * 0.3048; // 1.524m
            const ft10InMeters = 10 * 0.3048; // 3.048m

            // Only log once when we first check at 300ms
            if (timeStopped < GIMME_DELAY_MS + 100) {
                console.log(`Ball at rest (${timeStopped.toFixed(0)}ms) - Distance: ${distToHole.toFixed(2)}m (${(distToHole * 3.28084).toFixed(1)}ft), Gimmie enabled: ${gimmieCirclesEnabled}`);
            }

            if (distToHole <= ft5InMeters) {
                // Within 5ft - automatic 1 putt
                console.log('GIMMIE: Ball came to rest within 5ft - automatic 1 putt added');
                strokes += 1;
                const player = window.golfPar3Players[window.currentPlayerIndex];
                player.strokes += 1;
                ballStoppedTime = null; // Reset for next shot
                scoreHole(); // Score the hole
            } else if (distToHole <= ft10InMeters) {
                // Within 10ft - automatic 2 putts
                console.log('GIMMIE: Ball came to rest within 10ft - automatic 2 putts added');
                strokes += 2;
                const player = window.golfPar3Players[window.currentPlayerIndex];
                player.strokes += 2;
                ballStoppedTime = null; // Reset for next shot
                scoreHole(); // Score the hole
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- START: FPS Calculation ---
            if (DEBUG_FPS_LOG) {
                frameCount++;
                const currentTimeFPS = performance.now();
                if (currentTimeFPS - lastFpsUpdateTime > 1000) { // Update every second
                    const fps = frameCount / ((currentTimeFPS - lastFpsUpdateTime) / 1000);
                    console.log(`FPS: ${fps.toFixed(1)}`);
                    frameCount = 0; // Reset frameCount for the next second
                    lastFpsUpdateTime = currentTimeFPS;
                }
            }
            // --- END: FPS Calculation ---

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updateBallPhysics(deltaTime);
            updateTracer();
            updateCamera();
            updateYardageMarker();
            updateMinimap();
            checkGimme();

            renderer.render(scene, camera);
        }

        function toggleGrid() {
            showGrid = !showGrid;

            if (showGrid) {
                createGrid();
            } else {
                if (gridLines) {
                    scene.remove(gridLines);
                    gridLines = null;
                }
            }
        }

        function updateAimIndicator() {
            // Aim display removed from UI, but aim adjustment still works with arrow keys
            // No visual update needed
        }

        function createGrid() {
            // Remove existing grid if any
            if (gridLines) {
                scene.remove(gridLines);
            }

            const group = new THREE.Group();

            // Grid on fairway (center section)
            const fairwayGrid = new THREE.GridHelper(50, 25, 0x888888, 0x444444);
            fairwayGrid.position.y = 0.05; // Slightly above terrain
            fairwayGrid.position.z = -60; // Center of fairway
            group.add(fairwayGrid);

            // Grid on green
            const greenGrid = new THREE.GridHelper(20, 20, 0x88FF88, 0x44AA44);
            greenGrid.position.y = -0.1; // On green surface
            greenGrid.position.z = PIN_POSITION.z;
            group.add(greenGrid);

            // Grid on tee box
            const teeGrid = new THREE.GridHelper(8, 8, 0xFFFFFF, 0xCCCCCC);
            teeGrid.position.y = 3.05; // On tee box surface
            teeGrid.position.z = 0;
            group.add(teeGrid);

            gridLines = group;
            scene.add(gridLines);

            console.log('Grid enabled');
        }

        // OpenGolfCoach rank colors
        const RANK_COLORS = {
            'S+': '#23C4FF',
            'S': '#00B3FF',
            'A': '#00D977',
            'B': '#7CB342',
            'C': '#FFC107',
            'D': '#FF7043',
            'E': '#FF1744'
        };

        function displayShotClassification(classification) {
            const panel = document.getElementById('shotClassification');
            const nameDisplay = document.getElementById('shotNameDisplay');
            const rankBadge = document.getElementById('shotRankBadge');
            const backspinValue = document.getElementById('backspinValue');
            const sidespinValue = document.getElementById('sidespinValue');
            const carryValue = document.getElementById('carryValue');
            const totalValue = document.getElementById('totalValue');
            const peakHeightValue = document.getElementById('peakHeightValue');
            const hangTimeValue = document.getElementById('hangTimeValue');
            const smashFactorValue = document.getElementById('smashFactorValue');
            const efficiencyValue = document.getElementById('efficiencyValue');

            // Show panel
            panel.style.display = 'block';

            // Set shot name with color
            const shotColor = classification.shotColor.replace('0x', '#');
            nameDisplay.textContent = classification.shotName;
            nameDisplay.style.color = shotColor;

            // Set rank badge with color
            const rankColor = RANK_COLORS[classification.shotRank] || '#FFFFFF';
            rankBadge.textContent = `Rank ${classification.shotRank}`;
            rankBadge.style.backgroundColor = rankColor;
            rankBadge.style.color = '#000';

            // Set distance values
            carryValue.textContent = (classification.carryYards || 0).toFixed(1);
            totalValue.textContent = (classification.totalYards || 0).toFixed(1);
            peakHeightValue.textContent = (classification.peakHeight || 0).toFixed(1);
            hangTimeValue.textContent = (classification.hangTime || 0).toFixed(1);

            // Set spin values
            backspinValue.textContent = Math.round(classification.backspin || 0);
            sidespinValue.textContent = Math.round(classification.sidespin || 0);

            // Set quality metrics
            smashFactorValue.textContent = (classification.smashFactor || 0).toFixed(2);
            efficiencyValue.textContent = Math.round(classification.efficiency || 0);

            // Auto-hide after 8 seconds
            setTimeout(() => {
                panel.style.display = 'none';
            }, 8000);

            console.log(`üéØ ${classification.shotName} - Rank ${classification.shotRank}`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Reapply visual offset after resize
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                const fullWidth = window.innerWidth;
                const fullHeight = window.innerHeight;
                camera.setViewOffset(fullWidth, fullHeight, visualOffsetX, visualOffsetY, fullWidth, fullHeight);
            }
        }

        function exportSessionCSV() {
            if (sessionShots.length === 0) {
                alert('No shots recorded yet! Hit some balls first.');
                return;
            }

            // CSV headers
            const headers = [
                'Timestamp',
                'Player',
                'Hole',
                'Ball Speed (mph)',
                'Launch Angle (¬∞)',
                'Side Angle (¬∞)',
                'Total Spin (rpm)',
                'Spin Axis (¬∞)',
                'Lie',
                'Carry (yds)',
                'Total (yds)',
                'Rollout (yds)',
                'Apex (ft)',
                'Flight Time (s)'
            ];

            // Build CSV content
            let csvContent = headers.join(',') + '\n';

            sessionShots.forEach(shot => {
                const row = [
                    shot.timestamp,
                    shot.player,
                    shot.hole,
                    shot.ballSpeed.toFixed(1),
                    shot.launchAngle.toFixed(1),
                    shot.sideAngle.toFixed(1),
                    shot.totalSpin.toFixed(0),
                    shot.spinAxis.toFixed(1),
                    shot.lie,
                    shot.carryDistance.toFixed(1),
                    shot.totalDistance.toFixed(1),
                    shot.rollout.toFixed(1),
                    shot.apexHeight.toFixed(1),
                    shot.flightTime.toFixed(1)
                ];
                csvContent += row.join(',') + '\n';
            });

            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            const dateStr = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `golf-par3-session-${dateStr}.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`Exported ${sessionShots.length} shots to CSV`);
        }

        // Make exportSessionCSV globally available for button onclick
        window.exportSessionCSV = exportSessionCSV;
    </script>
</body>
</html>

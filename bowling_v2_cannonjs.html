<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bowling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Scorecard positioned at top center */
        #scorecardContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid #FF6B35;
            min-width: 600px;
        }

        #controls h3 {
            margin-top: 0;
            color: #FF6B35;
            font-size: 20px;
            text-align: center;
            margin-bottom: 10px;
        }

        #controls h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        #controls button {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 8px 12px;
            flex: 1;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        #controls button:hover {
            background: #ff8555;
            transform: translateY(-2px);
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .stat-row {
            margin: 6px 0;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            opacity: 0.8;
        }

        .stat-value {
            font-weight: bold;
            color: #FF6B35;
        }

        #playerIndicator {
            background: rgba(255, 107, 53, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            text-align: center;
            border: 2px solid #FF6B35;
        }

        #currentPlayerName {
            font-size: 1.2em;
            margin-top: 3px;
            font-weight: bold;
        }

        /* Scorecard styling */
        #scorecard {
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }

        .frame-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .frame {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px;
            text-align: center;
            border-radius: 4px;
        }

        .frame.active {
            border-color: #FF6B35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .frame-number {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
        }

        .frame-rolls {
            display: flex;
            justify-content: center;
            gap: 2px;
            font-size: 12px;
            min-height: 20px;
        }

        .roll-box {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            font-weight: bold;
        }

        .frame-score {
            font-size: 14px;
            font-weight: bold;
            color: #FF6B35;
            margin-top: 4px;
            min-height: 18px;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-value {
            display: inline-block;
            min-width: 60px;
            text-align: right;
            color: #FF6B35;
            font-weight: bold;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>üé≥ Bowling</h3>

        <div id="playerIndicator">
            <strong style="color: #FF6B35;">Current Player:</strong>
            <div id="currentPlayerName">Player 1</div>
        </div>

        <!-- Test Shot Panel - COMMENTED OUT (uncomment to enable for debugging) -->
        <!--
        <div class="stat-section" style="background: rgba(255, 165, 0, 0.1); border: 1px solid #FF6B35;">
            <button onclick="toggleTestPanel()" style="width: 100%; background: transparent; border: none; color: #FF6B35; cursor: pointer; padding: 0; margin-bottom: 10px; text-align: left; font-size: 16px; font-weight: bold;">
                <span id="testPanelToggle">‚ñº</span> üß™ Test Shot
            </button>

            <div id="testPanelContent">
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">Ball Speed (mph):</label>
                    <input type="number" id="testSpeed" value="12" min="1" max="30" step="0.5"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">HLA (degrees):</label>
                    <input type="number" id="testHLA" value="0" min="-10" max="10" step="0.5"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">Sidespin (rpm):</label>
                    <input type="number" id="testSidespin" value="0" min="-500" max="500" step="10"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <button onclick="sendTestShot()" style="width: 100%; padding: 10px; background: #FF6B35; border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
                    üé≥ Bowl Test Shot
                </button>
            </div>
        </div>
        -->

        <!-- Current Frame Info -->
        <div class="stat-section" style="background: rgba(255, 107, 53, 0.1); border: 1px solid #FF6B35;">
            <h4 style="color: #FF6B35; text-align: center;">Current Frame</h4>
            <div class="stat-row">
                <span class="stat-label">Frame:</span>
                <span class="stat-value" id="currentFrameNum">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Ball:</span>
                <span class="stat-value" id="currentBallNum">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Score:</span>
                <span class="stat-value" id="totalScore">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Pins Down:</span>
                <span class="stat-value" id="pinsDown">0</span>
            </div>
        </div>

        <div class="button-group">
            <button id="viewBtn" onclick="cycleView()">Change View</button>
            <button id="resetBtn" onclick="resetBall()">Reset Ball</button>
        </div>
        <div class="button-group">
            <button id="nextPlayerBtn" onclick="nextPlayer()" style="background: rgba(255, 107, 53, 0.5);">Next Player ‚Üí</button>
        </div>
        <div class="button-group">
            <button onclick="newGame()" style="background: #4CAF50;">New Game</button>
        </div>

        <div class="stat-section" style="background: rgba(255, 107, 53, 0.1); border: 1px solid #FF6B35;">
            <h4 style="color: #FF6B35; text-align: center;">Aiming</h4>
            <div class="stat-row">
                <span class="stat-label">Mode:</span>
                <span class="stat-value" id="aimingModeDisplay" style="text-transform: capitalize;">Position</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Ball Position:</span>
                <span class="stat-value" id="ballPositionDisplay">0.00m</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Aim Angle:</span>
                <span class="stat-value" id="aimAngleDisplay">0.0¬∞</span>
            </div>
            <div style="text-align: center; font-size: 11px; opacity: 0.7; margin-top: 5px;">
                ‚Üê ‚Üí to adjust | Y to confirm
            </div>
        </div>

        <div id="shotInfo" class="stat-section">
            <h4 style="color: #FF6B35;">Last Shot</h4>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="ballSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Hook:</span>
                <span class="stat-value" id="hookAngle">--</span>
            </div>
        </div>
    </div>

    <!-- Scorecard at top center -->
    <div id="scorecardContainer">
        <h4 style="color: #FF6B35; margin-bottom: 10px; text-align: center; font-size: 18px;">üé≥ Scorecard</h4>
        <div class="frame-container" id="frameContainer">
            <!-- Frames will be generated here -->
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let ball, ballBody;
        let currentView = 'follow'; // 'behind', 'side', 'follow'
        let pins = [];
        let lane, leftGutter, rightGutter;
        let leftBumper, rightBumper; // Visual bumper indicators

        // Ball physics
        const ballRadius = 0.108; // Bowling ball radius in meters (8.5 inch diameter / 2)
        const gravity = 9.81;
        let friction = 0.02; // Very low friction for bowling lane (oiled surface)
        const restitution = 0.3; // Low bounciness for bowling ball

        // Ball state
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let ballSpin = new THREE.Vector3(0, 0, 0);
        let isMoving = false;
        let lastTime = performance.now();
        let adjacentBalls = []; // For adjacent lane animations

        // Lane dimensions (in meters)
        const laneLength = 18.288; // 60 feet
        const laneWidth = 1.067; // 3.5 feet (42 inches)
        const gutterWidth = 0.23; // 9 inches each side

        // Pin dimensions and positions
        const pinHeight = 0.381; // 15 inches
        const pinRadius = 0.06; // ~2.4 inches (at widest point)
        const pinSpacing = 0.305; // 12 inches center to center

        // Players
        window.bowlingPlayers = [];
        window.currentPlayerIndex = 0;

        // Bowling game state
        let currentFrame = 1;
        let currentBall = 1; // 1 or 2 (or 3 in 10th frame)
        let frames = []; // Array of frame objects
        let pinsStanding = 10;
        let pinsKnockedThisFrame = [];
        let gameOver = false;

        // Aiming system
        let aimAngle = 0; // Horizontal aim angle in degrees (-10 to +10)
        let ballPosition = 0; // Lateral position on lane in meters (-0.4 to +0.4)
        let aimingMode = 'position'; // 'position' or 'angle'
        let aimingArrow = null; // Visual aiming indicator

        init();
        animate();

        function init() {
            // Initialize frames
            for (let i = 0; i < 10; i++) {
                frames.push({
                    rolls: [],
                    score: null,
                    isStrike: false,
                    isSpare: false
                });
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Dark bowling alley

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Overhead lights (like bowling alley)
            for (let i = 0; i < 5; i++) {
                const light = new THREE.PointLight(0xffffee, 0.6, 20);
                light.position.set(0, 5, -laneLength/2 + i * laneLength/4);
                light.castShadow = true;
                scene.add(light);
            }

            createLane();
            createAdjacentLanes(); // Add side lanes for atmosphere
            createBowlingAlley(); // Add walls, ceiling, and decorations
            createBall();
            createPins();
            createScorecard();
            aimingArrow = createAimingArrow();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);

            // Check for Electron IPC
            if (window.electronAPI) {
                console.log('‚úì Running in Electron - IPC available');
                setupElectronIPC();
            } else {
                console.log('‚ö† Not running in Electron - standalone mode');
            }

            updateUI();
        }

        function onKeyDown(event) {
            // Only allow aiming when ball is not moving
            if (isMoving) return;

            const positionStep = 0.01; // Meters per keypress for ball position
            const maxPosition = 0.4; // Maximum lateral position (meters from center)
            const aimStep = 0.1; // Degrees per keypress for angle
            const maxAim = 10; // Maximum aim angle in degrees

            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Move ball to the left on the lane
                        ballPosition = Math.min(maxPosition, ballPosition + positionStep);
                        ball.position.x = ballPosition;
                    } else {
                        // Adjust aim angle to the left
                        aimAngle = Math.min(maxAim, aimAngle + aimStep);
                    }
                    updateAimingArrow();
                    updateUI();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Move ball to the right on the lane
                        ballPosition = Math.max(-maxPosition, ballPosition - positionStep);
                        ball.position.x = ballPosition;
                    } else {
                        // Adjust aim angle to the right
                        aimAngle = Math.max(-maxAim, aimAngle - aimStep);
                    }
                    updateAimingArrow();
                    updateUI();
                    break;
                case 'y':
                case 'Y':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Confirm position, switch to angle mode
                        aimingMode = 'angle';
                        updateUI();
                        showNotification('Position Locked - Now Aim Angle');
                    }
                    break;
            }
        }

        function createLane() {
            // Main bowling lane
            const laneGeometry = new THREE.BoxGeometry(laneWidth, 0.02, laneLength);
            const laneTexture = createLaneTexture();
            const laneMaterial = new THREE.MeshLambertMaterial({
                map: laneTexture
            });
            lane = new THREE.Mesh(laneGeometry, laneMaterial);
            lane.position.set(0, 0, -laneLength/2);
            lane.receiveShadow = true;
            scene.add(lane);

            // Left gutter
            const gutterGeometry = new THREE.BoxGeometry(gutterWidth, 0.05, laneLength);
            const gutterMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a3e });
            leftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftGutter.position.set(-laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            leftGutter.receiveShadow = true;
            scene.add(leftGutter);

            // Right gutter
            rightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightGutter.position.set(laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            rightGutter.receiveShadow = true;
            scene.add(rightGutter);

            // Approach area (behind the foul line)
            const approachGeometry = new THREE.BoxGeometry(laneWidth + gutterWidth * 2, 0.01, 4.572); // 15 feet
            const approachMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a4e });
            const approach = new THREE.Mesh(approachGeometry, approachMaterial);
            approach.position.set(0, -0.005, 2.286);
            approach.receiveShadow = true;
            scene.add(approach);

            // Left side carpet (beyond left gutter) - extends to wall
            // Calculate carpet width: from edge of gutter to wall
            const sideCarpetWidth = 8 - (laneWidth/2 + gutterWidth); // Distance from gutter edge to wall
            const leftCarpetTexture = createCarpetTexture();
            leftCarpetTexture.offset.set(Math.random(), Math.random()); // Random offset
            const leftCarpetGeometry = new THREE.PlaneGeometry(sideCarpetWidth, laneLength + 10);
            const leftCarpetMaterial = new THREE.MeshLambertMaterial({ map: leftCarpetTexture });
            const leftCarpet = new THREE.Mesh(leftCarpetGeometry, leftCarpetMaterial);
            leftCarpet.rotation.x = -Math.PI / 2;
            leftCarpet.position.set(-laneWidth/2 - gutterWidth - sideCarpetWidth/2, -0.01, -laneLength/2);
            leftCarpet.receiveShadow = true;
            scene.add(leftCarpet);

            // Right side carpet (beyond right gutter) - extends to wall
            const rightCarpetTexture = createCarpetTexture();
            rightCarpetTexture.offset.set(Math.random(), Math.random()); // Different random offset
            const rightCarpetGeometry = new THREE.PlaneGeometry(sideCarpetWidth, laneLength + 10);
            const rightCarpetMaterial = new THREE.MeshLambertMaterial({ map: rightCarpetTexture });
            const rightCarpet = new THREE.Mesh(rightCarpetGeometry, rightCarpetMaterial);
            rightCarpet.rotation.x = -Math.PI / 2;
            rightCarpet.position.set(laneWidth/2 + gutterWidth + sideCarpetWidth/2, -0.01, -laneLength/2);
            rightCarpet.receiveShadow = true;
            scene.add(rightCarpet);

            // Foul line
            const foulLineGeometry = new THREE.BoxGeometry(laneWidth, 0.03, 0.02);
            const foulLineMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const foulLine = new THREE.Mesh(foulLineGeometry, foulLineMaterial);
            foulLine.position.set(0, 0.015, 0);
            scene.add(foulLine);

            // Create bumpers (hidden by default)
            createBumpers();
        }

        function createBumpers() {
            const bumperHeight = 0.3; // 30cm high bumpers
            const bumperGeometry = new THREE.BoxGeometry(gutterWidth, bumperHeight, laneLength);
            const bumperMaterial = new THREE.MeshLambertMaterial({
                color: 0xff6600 // Orange color
            });

            // Left bumper
            leftBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            leftBumper.position.set(-laneWidth/2 - gutterWidth/2, bumperHeight/2, -laneLength/2);
            leftBumper.visible = false; // Hidden by default
            scene.add(leftBumper);

            // Right bumper
            rightBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            rightBumper.position.set(laneWidth/2 + gutterWidth/2, bumperHeight/2, -laneLength/2);
            rightBumper.visible = false; // Hidden by default
            scene.add(rightBumper);
        }

        function updateBumperVisibility() {
            // Make sure players and player data exist
            if (!window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];
            const bumpersEnabled = currentPlayer && currentPlayer.bumpers;

            if (leftBumper && rightBumper) {
                leftBumper.visible = bumpersEnabled;
                rightBumper.visible = bumpersEnabled;
            }

            // Also change gutter color based on bumper status
            if (leftGutter && rightGutter) {
                const gutterColor = bumpersEnabled ? 0xff6600 : 0x2a2a3e; // Orange when bumpers on, dark when off
                leftGutter.material.color.setHex(gutterColor);
                rightGutter.material.color.setHex(gutterColor);
            }
        }

        // Adjacent lanes for atmosphere
        function createAdjacentPins(xOffset) {
            const pinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const pinSpacing = 0.305; // 12 inches
            const startZ = -laneLength + 1;

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col <= row; col++) {
                    const pinGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.38, 8);
                    const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                    const x = xOffset + (col - row / 2) * pinSpacing;
                    const z = startZ - row * pinSpacing;
                    pin.position.set(x, 0.19, z);
                    scene.add(pin);
                }
            }
        }

        function createAdjacentBall(xOffset) {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 16, 16);
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 100
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(xOffset, ballRadius, 0);
            ball.castShadow = true;
            scene.add(ball);

            adjacentBalls.push({
                mesh: ball,
                xOffset: xOffset,
                velocity: 0,
                isMoving: false,
                nextShotTime: Date.now() + Math.random() * 5000 + 3000, // Random delay 3-8 seconds
                lastPosition: 0,
                stuckTimer: 0
            });
        }

        function updateAdjacentBalls() {
            const currentTime = Date.now();

            adjacentBalls.forEach(ballData => {
                if (!ballData.isMoving && currentTime >= ballData.nextShotTime) {
                    // Start a new shot
                    ballData.isMoving = true;
                    ballData.velocity = 12 + Math.random() * 6; // Random speed 12-18 m/s (enough to reach end)
                    ballData.mesh.position.set(
                        ballData.xOffset + (Math.random() - 0.5) * 0.3, // Slight variation
                        ballRadius,
                        0
                    );
                }

                if (ballData.isMoving) {
                    // Move ball down lane
                    ballData.mesh.position.z -= ballData.velocity * 0.016;
                    ballData.velocity *= 0.99; // Slow down slightly

                    // Check if ball is stuck (hasn't moved much)
                    const positionChange = Math.abs(ballData.mesh.position.z - ballData.lastPosition);
                    if (positionChange < 0.01) {
                        // Ball is stuck or moving very slowly
                        ballData.stuckTimer += 16; // Add ~16ms (one frame)
                        if (ballData.stuckTimer > 1500) {
                            // Stuck for more than 1.5 seconds, reset
                            ballData.isMoving = false;
                            ballData.mesh.position.z = 0;
                            ballData.nextShotTime = currentTime + Math.random() * 8000 + 4000;
                            ballData.stuckTimer = 0;
                        }
                    } else {
                        // Ball is moving, reset stuck timer
                        ballData.stuckTimer = 0;
                    }
                    ballData.lastPosition = ballData.mesh.position.z;

                    // Reset when ball reaches end
                    if (ballData.mesh.position.z < -laneLength) {
                        ballData.isMoving = false;
                        ballData.mesh.position.z = 0;
                        ballData.nextShotTime = currentTime + Math.random() * 8000 + 4000; // Next shot in 4-12 seconds
                        ballData.stuckTimer = 0;
                    }
                }
            });
        }

        function createAdjacentLanes() {
            // Reuse same texture creation logic inline
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 512, 0);
            gradient.addColorStop(0, '#d4a373');
            gradient.addColorStop(0.5, '#c89968');
            gradient.addColorStop(1, '#d4a373');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const length = Math.random() * 100 + 50;
                ctx.strokeStyle = `rgba(139, 90, 43, ${Math.random() * 0.2})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + length, y);
                ctx.stroke();
            }
            const laneTexture = new THREE.CanvasTexture(canvas);

            const laneSpacing = laneWidth + gutterWidth * 2 + 1.5; // Space between lane centers

            // Left adjacent lane
            const leftLaneGeometry = new THREE.BoxGeometry(laneWidth, 0.02, laneLength);
            const leftLaneMaterial = new THREE.MeshLambertMaterial({ map: laneTexture });
            const leftLane = new THREE.Mesh(leftLaneGeometry, leftLaneMaterial);
            leftLane.position.set(-laneSpacing, 0, -laneLength/2);
            leftLane.receiveShadow = true;
            scene.add(leftLane);

            // Left lane gutters
            const gutterGeometry = new THREE.BoxGeometry(gutterWidth, 0.05, laneLength);
            const gutterMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a3e });

            const leftLaneLeftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftLaneLeftGutter.position.set(-laneSpacing - laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            scene.add(leftLaneLeftGutter);

            const leftLaneRightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftLaneRightGutter.position.set(-laneSpacing + laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            scene.add(leftLaneRightGutter);

            // Right adjacent lane
            const rightLane = new THREE.Mesh(leftLaneGeometry, leftLaneMaterial);
            rightLane.position.set(laneSpacing, 0, -laneLength/2);
            rightLane.receiveShadow = true;
            scene.add(rightLane);

            // Right lane gutters
            const rightLaneLeftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightLaneLeftGutter.position.set(laneSpacing - laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            scene.add(rightLaneLeftGutter);

            const rightLaneRightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightLaneRightGutter.position.set(laneSpacing + laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            scene.add(rightLaneRightGutter);

            // Add pins for adjacent lanes
            createAdjacentPins(-laneSpacing);
            createAdjacentPins(laneSpacing);

            // Create animated balls for adjacent lanes
            createAdjacentBall(-laneSpacing);
            createAdjacentBall(laneSpacing);
        }

        function createBowlingAlley() {
            // Side walls - much wider spacing for open feel
            const wallHeight = 4;
            const wallThickness = 0.2;
            const wallDistance = 8; // Distance from lane center to walls (was ~1.5m, now 8m)

            // Create brick texture
            const brickTexture = createBrickTexture();
            const wallMaterial = new THREE.MeshLambertMaterial({
                map: brickTexture,
                side: THREE.DoubleSide
            });

            // Left wall (much farther out)
            const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, laneLength + 10);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-wallDistance, wallHeight/2, -laneLength/2);
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            // Right wall (much farther out)
            const rightWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            rightWall.position.set(wallDistance, wallHeight/2, -laneLength/2);
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // Back wall (behind pins) - wider
            const backWallGeometry = new THREE.BoxGeometry(wallDistance * 2, wallHeight, wallThickness);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, wallHeight/2, -laneLength - wallThickness/2);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Ceiling (acoustic tile look) - much wider
            const ceilingGeometry = new THREE.PlaneGeometry(wallDistance * 2, laneLength + 10);
            const ceilingMaterial = new THREE.MeshLambertMaterial({
                color: 0xd0d0d0, // Light gray ceiling tiles
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, wallHeight, -laneLength/2);
            ceiling.receiveShadow = true;
            scene.add(ceiling);

            // Floor extending beyond lane (carpet) - wider with retro pattern
            const floorGeometry = new THREE.PlaneGeometry(wallDistance * 2, 6);
            const carpetTexture = createCarpetTexture();
            const floorMaterial = new THREE.MeshLambertMaterial({
                map: carpetTexture
            });
            const backFloor = new THREE.Mesh(floorGeometry, floorMaterial);
            backFloor.rotation.x = -Math.PI / 2;
            backFloor.position.set(0, -0.01, -laneLength - 3);
            backFloor.receiveShadow = true;
            scene.add(backFloor);

            // Add seats behind the lane (spectator area)
            const seatMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            for (let i = -1; i <= 1; i++) {
                const seatGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(i * 0.6, 0.15, 3);
                scene.add(seat);

                // Seat back
                const backGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.05);
                const seatBack = new THREE.Mesh(backGeometry, seatMaterial);
                seatBack.position.set(i * 0.6, 0.4, 3.2);
                scene.add(seatBack);
            }

            // Ball return (decorative)
            const ballReturnGeometry = new THREE.BoxGeometry(1.5, 0.3, 0.8);
            const ballReturnMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a5e });
            const ballReturn = new THREE.Mesh(ballReturnGeometry, ballReturnMaterial);
            ballReturn.position.set(-1.5, 0.15, 1.5);
            scene.add(ballReturn);

            // Add white baseboard trim along walls
            const baseboardMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const baseboardHeight = 0.15;
            const baseboardThickness = 0.05;

            // Left baseboard
            const baseboardGeometry = new THREE.BoxGeometry(baseboardThickness, baseboardHeight, laneLength + 10);
            const leftBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            leftBaseboard.position.set(-wallDistance + wallThickness/2, baseboardHeight/2, -laneLength/2);
            scene.add(leftBaseboard);

            // Right baseboard
            const rightBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            rightBaseboard.position.set(wallDistance - wallThickness/2, baseboardHeight/2, -laneLength/2);
            scene.add(rightBaseboard);

            // Add some decorative neon strips on walls
            const neonMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6b35,
                emissive: 0xff6b35,
                emissiveIntensity: 0.5
            });

            // Neon strip on left wall
            const neonGeometry = new THREE.BoxGeometry(0.05, 0.1, laneLength);
            const leftNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            leftNeon.position.set(-laneWidth/2 - gutterWidth - 0.1, 2.5, -laneLength/2);
            scene.add(leftNeon);

            // Neon strip on right wall
            const rightNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            rightNeon.position.set(laneWidth/2 + gutterWidth + 0.1, 2.5, -laneLength/2);
            scene.add(rightNeon);
        }

        function createCarpetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 512, 512);

            // Retro 90s bowling alley colors
            const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#ff6600', '#ff66ff', '#66ff66'];

            // Draw random geometric shapes
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 30 + 15;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const shapeType = Math.floor(Math.random() * 5);

                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 3;

                switch(shapeType) {
                    case 0: // Circle
                        ctx.beginPath();
                        ctx.arc(x, y, size/2, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 1: // Filled circle
                        ctx.beginPath();
                        ctx.arc(x, y, size/3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y - size/2);
                        ctx.lineTo(x - size/2, y + size/2);
                        ctx.lineTo(x + size/2, y + size/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 3: // Square
                        ctx.strokeRect(x - size/2, y - size/2, size, size);
                        break;
                    case 4: // Zigzag
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        for (let z = 0; z < 4; z++) {
                            ctx.lineTo(x + z * 8, y + (z % 2) * 15);
                        }
                        ctx.stroke();
                        break;
                }
            }

            // Add small dots
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const color = colors[Math.floor(Math.random() * colors.length)];
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add spiral shapes
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const color = colors[Math.floor(Math.random() * colors.length)];
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                    const r = angle * 2;
                    ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
                }
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 20); // Tile more to avoid stretching
            texture.magFilter = THREE.NearestFilter; // Crisp pixels, no blur
            texture.minFilter = THREE.NearestFilter; // No blur when viewed from distance
            texture.anisotropy = 16; // Better quality at angles
            return texture;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const brickWidth = 80;
            const brickHeight = 40;
            const mortarSize = 4;

            // Mortar background
            ctx.fillStyle = '#8b8680';
            ctx.fillRect(0, 0, 512, 512);

            // Draw brick pattern
            for (let row = 0; row < Math.ceil(512 / brickHeight); row++) {
                const offset = (row % 2) * (brickWidth / 2);
                for (let col = -1; col < Math.ceil(512 / brickWidth) + 1; col++) {
                    const x = col * brickWidth + offset;
                    const y = row * brickHeight;

                    // Varied brick colors for realism
                    const brickColors = ['#a0522d', '#8b4513', '#a0522d', '#9a4a1f', '#8b3a1f'];
                    const brickColor = brickColors[Math.floor(Math.random() * brickColors.length)];

                    ctx.fillStyle = brickColor;
                    ctx.fillRect(x + mortarSize, y + mortarSize, brickWidth - mortarSize, brickHeight - mortarSize);

                    // Add brick texture/variation
                    ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.1})`;
                    ctx.fillRect(x + mortarSize, y + mortarSize, brickWidth - mortarSize, brickHeight - mortarSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createLaneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Light wood color
            const gradient = ctx.createLinearGradient(0, 0, 512, 0);
            gradient.addColorStop(0, '#d4a373');
            gradient.addColorStop(0.5, '#c89968');
            gradient.addColorStop(1, '#d4a373');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Add wood grain texture
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const length = Math.random() * 100 + 50;
                ctx.strokeStyle = `rgba(139, 90, 43, ${Math.random() * 0.2})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + length, y);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1aff,
                emissive: 0x0000aa,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, ballRadius, 0); // Start at foul line
            ball.castShadow = true;
            scene.add(ball);
        }

        function updateBallColor() {
            if (!ball || !window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const player = window.bowlingPlayers[window.currentPlayerIndex];
            const color = new THREE.Color(player.color);
            ball.material.color = color;
            ball.material.emissive = color.clone().multiplyScalar(0.3);
        }

        function createAimingArrow() {
            // Create a simple arrow/line to show aim direction
            const arrowGroup = new THREE.Group();

            // Main line pointing down the lane
            const lineGeometry = new THREE.BufferGeometry();
            const lineLength = 10; // Length of aiming line in meters
            const vertices = new Float32Array([
                0, 0.01, 0,  // Start at ball position (slightly above ground)
                0, 0.01, -lineLength  // Point down the lane
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff0000,  // Red aiming line
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            arrowGroup.add(line);

            // Arrow head (small cone at the end)
            const coneGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(0, 0.01, -lineLength);
            cone.rotation.x = Math.PI; // Point down
            arrowGroup.add(cone);

            arrowGroup.position.copy(ball.position);
            scene.add(arrowGroup);

            return arrowGroup;
        }

        function updateAimingArrow() {
            if (!aimingArrow) return;

            // Position arrow at ball (ball now moves left/right)
            aimingArrow.position.copy(ball.position);

            // Rotate arrow based on aim angle
            aimingArrow.rotation.y = aimAngle * Math.PI / 180;

            // Change arrow color based on mode
            if (aimingMode === 'position') {
                // Yellow/orange for position mode
                aimingArrow.children.forEach(child => {
                    if (child.material) {
                        child.material.color.set(0xffaa00);
                    }
                });
            } else {
                // Red for angle mode
                aimingArrow.children.forEach(child => {
                    if (child.material) {
                        child.material.color.set(0xff0000);
                    }
                });
            }

            // Hide arrow when ball is moving
            aimingArrow.visible = !isMoving;
        }

        function createPins() {
            // Create 10 pins in INVERTED triangle formation (point toward bowler)
            // Row 1 (1 pin): pin 1 (head pin - closest to bowler)
            // Row 2 (2 pins): pins 2, 3
            // Row 3 (3 pins): pins 4, 5, 6
            // Row 4 (4 pins): pins 7, 8, 9, 10 (back row)

            const pinPositions = [
                // Row 1 - Head pin (closest to bowler)
                { x: 0, z: -laneLength + 1 },
                // Row 2 - Behind head pin
                { x: -pinSpacing/2, z: -laneLength + 1 - pinSpacing },
                { x: pinSpacing/2, z: -laneLength + 1 - pinSpacing },
                // Row 3 - Third row
                { x: -pinSpacing, z: -laneLength + 1 - pinSpacing * 2 },
                { x: 0, z: -laneLength + 1 - pinSpacing * 2 },
                { x: pinSpacing, z: -laneLength + 1 - pinSpacing * 2 },
                // Row 4 - Back row (furthest from bowler)
                { x: -pinSpacing * 1.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: -pinSpacing * 0.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: pinSpacing * 0.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: pinSpacing * 1.5, z: -laneLength + 1 - pinSpacing * 3 }
            ];

            pins = [];
            pinPositions.forEach((pos, index) => {
                const pin = createPin(pos.x, pos.z, index + 1);
                pins.push(pin);
            });
        }

        function createPin(x, z, number) {
            // Simplified pin as cylinder with cone on top
            const group = new THREE.Group();

            // Body (cylinder)
            const bodyGeometry = new THREE.CylinderGeometry(pinRadius * 0.6, pinRadius, pinHeight * 0.7, 8);
            const pinMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.05,
                shininess: 50
            });
            const body = new THREE.Mesh(bodyGeometry, pinMaterial);
            body.position.y = pinHeight * 0.35;
            group.add(body);

            // Neck (top cone)
            const neckGeometry = new THREE.CylinderGeometry(pinRadius * 0.3, pinRadius * 0.6, pinHeight * 0.3, 8);
            const neck = new THREE.Mesh(neckGeometry, pinMaterial);
            neck.position.y = pinHeight * 0.85;
            group.add(neck);

            // Red stripe
            const stripeGeometry = new THREE.CylinderGeometry(pinRadius * 0.65, pinRadius * 0.65, pinHeight * 0.1, 8);
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.y = pinHeight * 0.6;
            group.add(stripe);

            group.position.set(x, 0, z);
            group.castShadow = true;
            group.userData = {
                number: number,
                standing: true,
                velocity: new THREE.Vector3(0, 0, 0),
                angularVelocity: new THREE.Vector3(0, 0, 0),
                originalX: x,  // Store original position
                originalZ: z   // Store original position
            };

            scene.add(group);
            return group;
        }

        function updateCameraPosition() {
            switch (currentView) {
                case 'behind':
                    // Camera behind ball looking down lane
                    camera.position.set(0, 2, 3);
                    camera.lookAt(0, 0.5, -laneLength/2);
                    break;
                case 'side':
                    camera.position.set(3, 2, -laneLength/2);
                    camera.lookAt(0, 0, -laneLength/2);
                    break;
                case 'follow':
                    if (isMoving && ballVelocity.length() > 0.01) {
                        const travelDirection = ballVelocity.clone().normalize();
                        camera.position.set(
                            ball.position.x - travelDirection.x * 1.5,
                            ball.position.y + 1.5,
                            ball.position.z - travelDirection.z * 1.5
                        );
                        camera.lookAt(
                            ball.position.x + travelDirection.x * 2,
                            ball.position.y,
                            ball.position.z + travelDirection.z * 2
                        );
                    } else {
                        camera.position.set(0, 2, 3);
                        camera.lookAt(0, 0.5, -laneLength/2);
                    }
                    break;
            }
        }

        function cycleView() {
            const views = ['behind', 'side', 'follow'];
            const currentIndex = views.indexOf(currentView);
            currentView = views[(currentIndex + 1) % views.length];
            updateCameraPosition();
            showNotification(`Camera: ${currentView.charAt(0).toUpperCase() + currentView.slice(1)}`);
        }

        function showNotification(message) {
            const existing = document.getElementById('notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 107, 53, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }

        function updatePhysics(deltaTime) {
            if (!isMoving) return;

            // Apply friction to ball
            const speed = ballVelocity.length();
            if (speed > 0.001) {
                const frictionForce = friction * gravity * deltaTime;
                const frictionDecel = Math.min(frictionForce / speed, 1);
                ballVelocity.multiplyScalar(1 - frictionDecel);

                // Apply hook from sidespin (Magnus effect)
                if (ballSpin.y !== 0) {
                    // Hook increases as ball slows down (more time for spin to take effect)
                    const hookForce = ballSpin.y * 0.00005 * deltaTime;
                    ballVelocity.x += hookForce;
                }

                // Update ball position
                ball.position.add(ballVelocity.clone().multiplyScalar(deltaTime));

                // Ball rotation
                const rotationSpeed = speed / ballRadius;
                ball.rotation.x += rotationSpeed * deltaTime;

                // Check for gutter
                if (Math.abs(ball.position.x) > laneWidth/2) {
                    const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];

                    // Check if current player has bumpers enabled
                    if (currentPlayer && currentPlayer.bumpers) {
                        // Bumpers enabled - bounce ball back to lane
                        const bumperRestitution = 0.6; // Bounce coefficient
                        ballVelocity.x = -ballVelocity.x * bumperRestitution;
                        ball.position.x = Math.sign(ball.position.x) * laneWidth/2;
                        showNotification('Bumper! üõ°Ô∏è', 1000);
                    } else {
                        // No bumpers - gutter ball!
                        ballVelocity.set(0, 0, 0);
                        isMoving = false;
                        showNotification('Gutter Ball! üò¨');
                        setTimeout(() => {
                            frameComplete(0);
                        }, 2000);
                        return;
                    }
                }

                // Check for end of lane
                if (ball.position.z < -laneLength + 0.5) {
                    ballVelocity.set(0, 0, 0);
                    isMoving = false;

                    // Count pins and end frame
                    setTimeout(() => {
                        const pinsKnocked = countPinsDown();
                        frameComplete(pinsKnocked);
                    }, 1500);
                    return;
                }

                // Check pin collisions
                checkPinCollisions();

                // Spin decay
                ballSpin.multiplyScalar(1 - deltaTime * 0.5);

                if (speed < 0.01) {
                    ballVelocity.set(0, 0, 0);
                    ballSpin.set(0, 0, 0);
                    isMoving = false;

                    // Count pins and end frame
                    setTimeout(() => {
                        const pinsKnocked = countPinsDown();
                        frameComplete(pinsKnocked);
                    }, 1500);
                }
            } else {
                ballVelocity.set(0, 0, 0);
                isMoving = false;
            }

            // Update pin physics
            updatePinPhysics(deltaTime);
        }

        function updatePinPhysics(deltaTime) {
            pins.forEach(pin => {
                if (!pin.userData.standing) {
                    // Apply gravity and friction to falling pins
                    pin.userData.velocity.y -= gravity * deltaTime;
                    pin.position.add(pin.userData.velocity.clone().multiplyScalar(deltaTime));

                    // Apply angular velocity (rotation)
                    pin.rotation.x += pin.userData.angularVelocity.x * deltaTime;
                    pin.rotation.z += pin.userData.angularVelocity.z * deltaTime;

                    // Floor collision
                    if (pin.position.y < 0) {
                        pin.position.y = 0;
                        pin.userData.velocity.multiplyScalar(0.3); // Damping
                    }

                    // Friction
                    pin.userData.velocity.multiplyScalar(1 - deltaTime * 2);
                    pin.userData.angularVelocity.multiplyScalar(1 - deltaTime * 2);
                }
            });

            // Pin-to-pin collisions
            for (let i = 0; i < pins.length; i++) {
                for (let j = i + 1; j < pins.length; j++) {
                    checkPinToPinCollision(pins[i], pins[j]);
                }
            }
        }

        function checkPinCollisions() {
            pins.forEach(pin => {
                if (pin.userData.standing) {
                    const dx = ball.position.x - pin.position.x;
                    const dz = ball.position.z - pin.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist < ballRadius + pinRadius) {
                        // Collision!
                        pin.userData.standing = false;

                        // Transfer momentum to pin
                        const direction = new THREE.Vector3(
                            pin.position.x - ball.position.x,
                            0,
                            pin.position.z - ball.position.z
                        ).normalize();

                        const impactForce = ballVelocity.length() * 0.5;
                        pin.userData.velocity.set(
                            direction.x * impactForce,
                            2, // Upward force
                            direction.z * impactForce
                        );

                        // Add rotation
                        pin.userData.angularVelocity.set(
                            (Math.random() - 0.5) * 10,
                            0,
                            (Math.random() - 0.5) * 10
                        );

                        // Reduce ball velocity
                        ballVelocity.multiplyScalar(0.7);
                    }
                }
            });
        }

        function checkPinToPinCollision(pin1, pin2) {
            const dx = pin1.position.x - pin2.position.x;
            const dz = pin1.position.z - pin2.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < pinRadius * 2 && (!pin1.userData.standing || !pin2.userData.standing)) {
                // If one pin is falling and hits another standing pin
                if (pin1.userData.standing && !pin2.userData.standing) {
                    const v2 = pin2.userData.velocity.length();
                    if (v2 > 0.5) {
                        pin1.userData.standing = false;
                        const direction = new THREE.Vector3(
                            pin1.position.x - pin2.position.x,
                            0,
                            pin1.position.z - pin2.position.z
                        ).normalize();
                        pin1.userData.velocity.copy(direction.multiplyScalar(v2 * 0.5));
                        pin1.userData.velocity.y = 1;
                        pin1.userData.angularVelocity.set(
                            (Math.random() - 0.5) * 8,
                            0,
                            (Math.random() - 0.5) * 8
                        );
                    }
                } else if (!pin1.userData.standing && pin2.userData.standing) {
                    const v1 = pin1.userData.velocity.length();
                    if (v1 > 0.5) {
                        pin2.userData.standing = false;
                        const direction = new THREE.Vector3(
                            pin2.position.x - pin1.position.x,
                            0,
                            pin2.position.z - pin1.position.z
                        ).normalize();
                        pin2.userData.velocity.copy(direction.multiplyScalar(v1 * 0.5));
                        pin2.userData.velocity.y = 1;
                        pin2.userData.angularVelocity.set(
                            (Math.random() - 0.5) * 8,
                            0,
                            (Math.random() - 0.5) * 8
                        );
                    }
                }
            }
        }

        function countPinsDown() {
            let count = 0;
            pins.forEach(pin => {
                if (!pin.userData.standing) {
                    count++;
                }
            });
            return count;
        }

        function resetPins() {
            pins.forEach(pin => {
                pin.userData.standing = true;
                pin.userData.velocity.set(0, 0, 0);
                pin.userData.angularVelocity.set(0, 0, 0);
                // Restore original position
                pin.position.set(pin.userData.originalX, 0, pin.userData.originalZ);
                pin.rotation.x = 0;
                pin.rotation.z = 0;
                pin.visible = true; // Make sure pin is visible
            });
        }

        function clearKnockedPins() {
            // After first ball, remove knocked pins from view (like real bowling)
            pins.forEach(pin => {
                if (!pin.userData.standing) {
                    pin.visible = false; // Hide knocked pins
                }
            });
        }

        function resetBall() {
            ball.position.set(0, ballRadius, 0);
            ballVelocity.set(0, 0, 0);
            ballSpin.set(0, 0, 0);
            isMoving = false;
            ball.rotation.x = 0;
            aimAngle = 0; // Reset aim to center
            ballPosition = 0; // Reset ball position to center
            aimingMode = 'position'; // Reset to position mode
            updateAimingArrow();
            updateUI();
        }

        function rollBall(speed, hla = 0, sidespin = 0) {
            if (isMoving) return;
            if (gameOver) {
                showNotification('Game Over! Start a new game.');
                return;
            }

            // Convert mph to m/s
            const speedMS = speed * 0.44704;

            // Combine the launch monitor HLA with keyboard aim angle
            const totalHLA = hla + aimAngle;
            const hlaRad = totalHLA * Math.PI / 180;

            ballVelocity.set(
                speedMS * Math.sin(hlaRad),
                0,
                -speedMS * Math.cos(hlaRad) // Negative Z is down the lane
            );

            // Set sidespin for hook
            ballSpin.set(0, sidespin, 0);

            isMoving = true;

            // Update display
            document.getElementById('ballSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('hookAngle').textContent = hla.toFixed(1) + '¬∞';
        }

        function frameComplete(pinsKnocked) {
            console.log(`Frame complete: ${pinsKnocked} pins knocked`);

            const frame = frames[currentFrame - 1];
            frame.rolls.push(pinsKnocked);

            // Check for strike
            if (currentBall === 1 && pinsKnocked === 10) {
                frame.isStrike = true;
                showNotification('STRIKE! üé≥');

                // Move to next frame (except in 10th frame)
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // 10th frame strike - get 2 more balls
                    resetPins();
                    resetBall();
                    currentBall = 2;
                }
            }
            // Check for spare
            else if (currentBall === 2 && (frame.rolls[0] + pinsKnocked === 10)) {
                frame.isSpare = true;
                showNotification('SPARE! /');

                // Move to next frame
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // 10th frame spare - get 1 more ball
                    resetPins();
                    resetBall();
                    currentBall = 3;
                }
            }
            // Second ball
            else if (currentBall === 2) {
                // Move to next frame
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // End of game
                    gameOver = true;
                    calculateFinalScore();
                    showNotification(`Game Over! Final Score: ${calculateTotalScore()}`);
                }
            }
            // First ball (not strike)
            else {
                clearKnockedPins(); // Clear knocked pins before second ball
                resetBall();
                currentBall = 2;
            }

            // Special handling for 10th frame
            if (currentFrame === 10) {
                // If strike or spare in 10th, allow extra balls
                if (currentBall === 3 && frame.rolls.length >= 3) {
                    gameOver = true;
                    calculateFinalScore();
                    showNotification(`Game Over! Final Score: ${calculateTotalScore()}`);
                }
            }

            updateUI();
            updateScorecard();
        }

        function calculateTotalScore() {
            let total = 0;
            for (let i = 0; i < 10; i++) {
                const frame = frames[i];

                if (frame.isStrike) {
                    total += 10;
                    // Add next two rolls
                    if (i < 9) {
                        const nextFrame = frames[i + 1];
                        total += nextFrame.rolls[0] || 0;
                        if (nextFrame.isStrike && i < 8) {
                            total += frames[i + 2].rolls[0] || 0;
                        } else {
                            total += nextFrame.rolls[1] || 0;
                        }
                    } else {
                        // 10th frame
                        total += frame.rolls[1] || 0;
                        total += frame.rolls[2] || 0;
                    }
                } else if (frame.isSpare) {
                    total += 10;
                    // Add next roll
                    if (i < 9) {
                        total += frames[i + 1].rolls[0] || 0;
                    } else {
                        total += frame.rolls[2] || 0;
                    }
                } else {
                    total += frame.rolls[0] || 0;
                    total += frame.rolls[1] || 0;
                }

                frame.score = total;
            }
            return total;
        }

        function calculateFinalScore() {
            calculateTotalScore();
        }

        function updateUI() {
            document.getElementById('currentFrameNum').textContent = currentFrame;
            document.getElementById('currentBallNum').textContent = currentBall;
            document.getElementById('totalScore').textContent = calculateTotalScore();
            document.getElementById('pinsDown').textContent = countPinsDown();
            document.getElementById('aimAngleDisplay').textContent = aimAngle.toFixed(1) + '¬∞';
            document.getElementById('ballPositionDisplay').textContent = ballPosition.toFixed(2) + 'm';
            document.getElementById('aimingModeDisplay').textContent = aimingMode;
        }

        function createScorecard() {
            const container = document.getElementById('frameContainer');
            container.innerHTML = '';

            for (let i = 0; i < 10; i++) {
                const frameDiv = document.createElement('div');
                frameDiv.className = 'frame';
                frameDiv.id = `frame${i + 1}`;

                const frameNumber = document.createElement('div');
                frameNumber.className = 'frame-number';
                frameNumber.textContent = i + 1;

                const frameRolls = document.createElement('div');
                frameRolls.className = 'frame-rolls';
                frameRolls.id = `frame${i + 1}-rolls`;

                const frameScore = document.createElement('div');
                frameScore.className = 'frame-score';
                frameScore.id = `frame${i + 1}-score`;

                frameDiv.appendChild(frameNumber);
                frameDiv.appendChild(frameRolls);
                frameDiv.appendChild(frameScore);
                container.appendChild(frameDiv);
            }

            updateScorecard();
        }

        function updateScorecard() {
            for (let i = 0; i < 10; i++) {
                const frame = frames[i];
                const rollsDiv = document.getElementById(`frame${i + 1}-rolls`);
                const scoreDiv = document.getElementById(`frame${i + 1}-score`);
                const frameDiv = document.getElementById(`frame${i + 1}`);

                // Highlight current frame
                if (i + 1 === currentFrame) {
                    frameDiv.classList.add('active');
                } else {
                    frameDiv.classList.remove('active');
                }

                // Display rolls
                rollsDiv.innerHTML = '';
                if (i < 9) {
                    // Frames 1-9
                    if (frame.isStrike) {
                        const box = document.createElement('div');
                        box.className = 'roll-box';
                        box.textContent = 'X';
                        rollsDiv.appendChild(box);
                    } else {
                        const box1 = document.createElement('div');
                        box1.className = 'roll-box';
                        box1.textContent = frame.rolls[0] || '';
                        rollsDiv.appendChild(box1);

                        if (frame.rolls.length > 1) {
                            const box2 = document.createElement('div');
                            box2.className = 'roll-box';
                            box2.textContent = frame.isSpare ? '/' : (frame.rolls[1] || '');
                            rollsDiv.appendChild(box2);
                        }
                    }
                } else {
                    // 10th frame (can have 3 rolls)
                    for (let j = 0; j < 3; j++) {
                        const box = document.createElement('div');
                        box.className = 'roll-box';
                        if (frame.rolls[j] !== undefined) {
                            if (frame.rolls[j] === 10) {
                                box.textContent = 'X';
                            } else if (j > 0 && frame.rolls[j-1] + frame.rolls[j] === 10) {
                                box.textContent = '/';
                            } else {
                                box.textContent = frame.rolls[j];
                            }
                        }
                        rollsDiv.appendChild(box);
                    }
                }

                // Display score
                if (frame.score !== null && frame.score !== undefined) {
                    scoreDiv.textContent = frame.score;
                } else {
                    scoreDiv.textContent = '';
                }
            }
        }

        // Test Shot Functions - COMMENTED OUT (uncomment to enable for debugging)
        /*
        function toggleTestPanel() {
            const content = document.getElementById('testPanelContent');
            const toggle = document.getElementById('testPanelToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function sendTestShot() {
            const speed = parseFloat(document.getElementById('testSpeed').value);
            const hla = parseFloat(document.getElementById('testHLA').value);
            const sidespin = parseFloat(document.getElementById('testSidespin').value);

            console.log(`üß™ Test shot: ${speed} mph, HLA: ${hla}¬∞, Sidespin: ${sidespin} rpm`);

            if (speed > 0) {
                rollBall(speed, hla, sidespin);
            }
        }
        */

        function newGame() {
            // Reset game state
            currentFrame = 1;
            currentBall = 1;
            gameOver = false;
            frames = [];
            for (let i = 0; i < 10; i++) {
                frames.push({
                    rolls: [],
                    score: null,
                    isStrike: false,
                    isSpare: false
                });
            }

            resetPins();
            resetBall();
            updateUI();
            updateScorecard();

            // Only show notification if game was already in progress
            if (currentFrame > 1 || frames[0].rolls.length > 0) {
                showNotification('New Game Started!');
            }
        }

        function setupElectronIPC() {
            // Load players from localStorage
            const playersData = localStorage.getItem('bowlingPlayers');
            window.bowlingPlayers = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#FF6B35' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('bowlingCurrentPlayer') || '0');

            updatePlayerDisplay();
            updateBallColor();

            // Hide Next Player button if only 1 player
            if (window.bowlingPlayers.length === 1) {
                document.getElementById('nextPlayerBtn').style.display = 'none';
            }

            // Welcome message - let player know they can start immediately
            const player = window.bowlingPlayers[window.currentPlayerIndex];
            updateBumperVisibility(); // Set initial bumper state
            setTimeout(() => {
                showNotification(`${player.name} - Ready to Bowl! üé≥`);
            }, 500);

            // Listen for shot data
            window.electronAPI.onShotData((shotData) => {
                console.log('üì° Shot received:', shotData);

                let speed = shotData.ball_speed || 0;
                const hla = shotData.hla || 0;
                const sidespin = shotData.side_spin || 0;

                // Apply power boost if player has it enabled and shot is weak
                const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];
                if (currentPlayer && currentPlayer.powerMultiplier && speed > 0 && speed < 70) {
                    const originalSpeed = speed;
                    speed = speed * currentPlayer.powerMultiplier;
                    console.log(`‚ö° Power Boost: ${originalSpeed.toFixed(1)} mph ‚Üí ${speed.toFixed(1)} mph (${currentPlayer.powerMultiplier}x)`);
                }

                if (speed > 0) {
                    // Accept both putter and iron shots for bowling
                    rollBall(speed, hla, sidespin);
                }
            });
        }

        function updatePlayerDisplay() {
            if (!window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const player = window.bowlingPlayers[window.currentPlayerIndex];
            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }
        }

        function nextPlayer() {
            if (!window.bowlingPlayers || window.bowlingPlayers.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.bowlingPlayers.length;
            localStorage.setItem('bowlingCurrentPlayer', window.currentPlayerIndex.toString());

            updatePlayerDisplay();
            updateBallColor();
            updateBumperVisibility(); // Update bumper visibility for new player
            newGame(); // Start new game for next player
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updatePhysics(deltaTime);
            updateAimingArrow();
            updateAdjacentBalls(); // Animate adjacent lane balls

            // Update camera for follow view
            if (currentView === 'follow') {
                updateCameraPosition();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

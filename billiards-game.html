<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billiards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 13px;
            background: rgba(0,0,0,0.7);
            padding: 12px;
            border-radius: 8px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            color: white;
            z-index: 100;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #aimLine {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 0, 0.5);
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        button {
            padding: 8px 12px;
            font-size: 13px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="playerInfo">Player: <span id="playerName">Player 1</span></div>
        <div>Power: <span id="powerDisplay">50</span>%</div>
        <div>Balls Potted: <span id="ballsPotted">0</span></div>
    </div>

    <div id="controls">
        <label>Power: <input type="range" id="powerSlider" min="1" max="100" value="50"></label>
        <button id="hitButton">Hit Ball</button>
        <button id="resetButton">Reset Rack</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="preload.js"></script>
    <script>
        let scene, camera, renderer;
        let table, cueBall;
        let balls = [];
        let ballsInMotion = false;
        let playerName = 'Player 1';
        let ballsPotted = 0;
        let cueDirection = new THREE.Vector3(-1, 0, 0);  // Shoot toward rack (up the table, negative X)
        let power = 50;
        let lastTime = performance.now();

        // Physics constants (from research papers)
        const BALL_RADIUS = 0.028575; // 57.15mm diameter = 28.575mm radius
        const TABLE_LENGTH = 2.54; // 8 foot table = 2.54m (runs vertically in our view)
        const TABLE_WIDTH = 1.27; // 4 foot width = 1.27m (runs horizontally in our view)
        const BALL_MASS = 0.170; // 170g = 0.170kg (6 oz)
        const BALL_INERTIA = (2/5) * BALL_MASS * BALL_RADIUS * BALL_RADIUS; // I = (2/5)MRÂ²

        // Friction coefficients (from Petit/Alciatore papers)
        const SLIDING_FRICTION = 0.2; // f: coefficient of sliding friction (ball-cloth)
        const ROLLING_RESISTANCE = 0.01; // fc: coefficient of rolling resistance
        const SPIN_FRICTION = 0.05; // fz: z-spin friction parameter
        const COLLISION_FRICTION = 0.15; // fi: friction during ball-ball collision

        // Restitution (from papers: ~0.93 for pool balls)
        const COR_BALL_BALL = 0.93; // N: coefficient of restitution for ball-ball
        const COR_CUSHION = 0.80; // Cushion is slightly less elastic

        const GRAVITY = 9.81; // m/sÂ²

        // Pockets (6 pockets: 4 corners + 2 middle)
        const pockets = [
            { x: -TABLE_LENGTH/2, z: -TABLE_WIDTH/2 }, // Bottom left
            { x: TABLE_LENGTH/2, z: -TABLE_WIDTH/2 },  // Bottom right
            { x: -TABLE_LENGTH/2, z: TABLE_WIDTH/2 },  // Top left
            { x: TABLE_LENGTH/2, z: TABLE_WIDTH/2 },   // Top right
            { x: 0, z: -TABLE_WIDTH/2 },               // Bottom middle
            { x: 0, z: TABLE_WIDTH/2 }                 // Top middle
        ];
        const POCKET_RADIUS = 0.06;

        // Load player from localStorage
        const storedPlayer = localStorage.getItem('billiardsPlayer');
        if (storedPlayer) {
            const playerData = JSON.parse(storedPlayer);
            playerName = playerData.name;
            document.getElementById('playerName').textContent = playerName;
        }

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 1.5);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 5, 0);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Pool table
            const tableGeometry = new THREE.BoxGeometry(TABLE_LENGTH, 0.1, TABLE_WIDTH);
            const tableMaterial = new THREE.MeshStandardMaterial({ color: 0x0a6e0a });
            table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.y = -0.05;
            table.receiveShadow = true;
            scene.add(table);

            // Table rails
            createRails();

            // Create cue ball
            createCueBall();

            // Rack the balls (triangle formation)
            rackBalls();

            // Controls
            document.getElementById('powerSlider').addEventListener('input', (e) => {
                power = parseInt(e.target.value);
                document.getElementById('powerDisplay').textContent = power;
            });

            document.getElementById('hitButton').addEventListener('click', hitBall);
            document.getElementById('resetButton').addEventListener('click', resetGame);

            // GSPro IPC Integration
            if (window.electronAPI) {
                window.electronAPI.onShotData((shotData) => {
                    console.log('Billiards received shot data:', shotData);
                    if (!ballsInMotion) {
                        // Convert ball speed (mph) to power (0-100)
                        const calculatedPower = Math.min((shotData.ballSpeed / 100) * 100, 100);
                        power = calculatedPower;
                        document.getElementById('powerSlider').value = power;
                        document.getElementById('powerDisplay').textContent = Math.round(power);

                        // Auto-hit after receiving putter data
                        setTimeout(() => hitBall(), 100);
                    }
                });
            }

            window.addEventListener('resize', onWindowResize);
        }

        function createRails() {
            const railMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const railHeight = 0.05;
            const railWidth = 0.05;

            // Long rails (left and right)
            const longRailGeometry = new THREE.BoxGeometry(TABLE_LENGTH + 0.1, railHeight, railWidth);

            const leftRail = new THREE.Mesh(longRailGeometry, railMaterial);
            leftRail.position.set(0, 0, -TABLE_WIDTH/2 - railWidth/2);
            scene.add(leftRail);

            const rightRail = new THREE.Mesh(longRailGeometry, railMaterial);
            rightRail.position.set(0, 0, TABLE_WIDTH/2 + railWidth/2);
            scene.add(rightRail);

            // Short rails (top and bottom)
            const shortRailGeometry = new THREE.BoxGeometry(railWidth, railHeight, TABLE_WIDTH + 0.1);

            const topRail = new THREE.Mesh(shortRailGeometry, railMaterial);
            topRail.position.set(-TABLE_LENGTH/2 - railWidth/2, 0, 0);
            scene.add(topRail);

            const bottomRail = new THREE.Mesh(shortRailGeometry, railMaterial);
            bottomRail.position.set(TABLE_LENGTH/2 + railWidth/2, 0, 0);
            scene.add(bottomRail);
        }

        function createCueBall() {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            cueBall = new THREE.Mesh(ballGeometry, ballMaterial);
            // Head spot - where you break from (near the bottom end of table)
            // Place at 75% down the table length (closer to bottom)
            cueBall.position.set(TABLE_LENGTH * 0.25, BALL_RADIUS, 0);
            cueBall.castShadow = true;
            cueBall.velocity = new THREE.Vector3(0, 0, 0);
            cueBall.spin = new THREE.Vector3(0, 0, 0); // Angular velocity (omega)
            cueBall.sliding = false; // Track if ball is sliding vs rolling
            cueBall.collisionCooldown = 0; // Prevent multiple collisions per frame
            scene.add(cueBall);
        }

        function createBall(color, isStriped = false, number = 0) {
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);

            if (isStriped) {
                // Create striped ball - white base with colored stripe
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');

                // White base
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, 1024, 512);

                // Colored stripe in middle (equator)
                const colorHex = '#' + color.toString(16).padStart(6, '0');
                ctx.fillStyle = colorHex;
                ctx.fillRect(0, 170, 1024, 172);  // Horizontal stripe around equator

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                const ballMaterial = new THREE.MeshStandardMaterial({ map: texture });
                const mesh = new THREE.Mesh(ballGeometry, ballMaterial);

                // Rotate so stripe is visible from top view
                mesh.rotation.x = Math.PI / 2;

                return mesh;
            } else {
                // Solid ball
                const ballMaterial = new THREE.MeshStandardMaterial({ color: color });
                return new THREE.Mesh(ballGeometry, ballMaterial);
            }
        }

        function rackBalls() {
            // Clear existing balls
            balls.forEach(ball => scene.remove(ball));
            balls = [];

            // 8-ball rack rules:
            // - 8-ball in center (position 5)
            // - One corner stripe, other corner solid
            // - Stripes and solids ALTERNATE along the sides

            // Rack layout (positions 1-15):
            //       1
            //      2 3
            //     4 5 6
            //    7 8 9 10
            //  11 12 13 14 15

            // Side edges that must alternate:
            // Left edge: 1,2,4,7,11
            // Right edge: 1,3,6,10,15

            // Configuration based on mockup image (top to bottom, left to right):
            const ballConfig = [
                { num: 1, color: 0xFFD700, striped: false },    // 1: Apex - Yellow solid
                { num: 15, color: 0x8B0000, striped: true },    // 2: White stripe
                { num: 4, color: 0x800080, striped: false },    // 3: Purple solid
                { num: 3, color: 0xFF0000, striped: false },    // 4: Red solid
                { num: 8, color: 0x000000, striped: false },    // 5: CENTER - 8 BALL (black)
                { num: 14, color: 0x006400, striped: true },    // 6: White stripe
                { num: 5, color: 0xFF6600, striped: false },    // 7: Orange solid
                { num: 12, color: 0x800080, striped: true },    // 8: White stripe
                { num: 2, color: 0x0000FF, striped: false },    // 9: Blue solid
                { num: 11, color: 0xFF0000, striped: true },    // 10: White stripe
                { num: 9, color: 0xFFD700, striped: true },     // 11: Yellow stripe
                { num: 10, color: 0x0000FF, striped: true },    // 12: White stripe
                { num: 6, color: 0x006400, striped: false },    // 13: Green solid
                { num: 13, color: 0xFF6600, striped: true },    // 14: White stripe
                { num: 7, color: 0x8B0000, striped: false }     // 15: Maroon/Red solid
            ];

            // Rack triangle at foot spot (top of table in our view)
            // Apex points toward the cue ball (down, toward positive X)
            const footSpotX = -TABLE_LENGTH * 0.25;  // Foot spot is 1/4 from top

            // Ball spacing in rack: diameter + small gap for tight rack
            const ballDiameter = BALL_RADIUS * 2;
            const spacing = ballDiameter * 1.001; // Just 0.1% gap, nearly touching

            // Standard 8-ball rack positions (triangle apex points DOWN toward cue ball)
            // Row numbers increase from apex (closest to cue ball) to base (farthest)
            const rackPositions = [
                [0, 2],   // Row 1: 1 ball (apex) - closest to cue ball
                [1, 1.5], [1, 2.5],   // Row 2: 2 balls
                [2, 1], [2, 2], [2, 3],   // Row 3: 3 balls (8-ball in center)
                [3, 0.5], [3, 1.5], [3, 2.5], [3, 3.5],   // Row 4: 4 balls
                [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]    // Row 5: 5 balls - farthest (base)
            ];

            for (let i = 0; i < 15; i++) {
                const config = ballConfig[i];
                const pos = rackPositions[i];

                // Reverse direction: apex is toward cue ball (positive X)
                // Row spacing adjusted by sqrt(3)/2 for equilateral triangle
                const rowSpacing = spacing * 0.866; // sin(60Â°) = sqrt(3)/2 â‰ˆ 0.866
                const x = footSpotX + (4 - pos[0]) * rowSpacing;
                const z = (pos[1] - 2) * spacing;  // Center on Z axis

                const ball = createBall(config.color, config.striped, config.num);
                ball.position.set(x, BALL_RADIUS, z);
                ball.castShadow = true;
                ball.velocity = new THREE.Vector3(0, 0, 0);
                ball.spin = new THREE.Vector3(0, 0, 0); // Angular velocity
                ball.sliding = false; // Track if ball is sliding vs rolling
                ball.active = true;
                ball.number = config.num;
                ball.collisionCooldown = 0; // Prevent multiple collisions per frame
                scene.add(ball);
                balls.push(ball);
            }
        }

        function hitBall() {
            if (ballsInMotion) return;

            // Apply force to cue ball based on power and direction
            const force = power / 10; // Scale power to reasonable velocity
            cueBall.velocity.x = cueDirection.x * force;
            cueBall.velocity.z = cueDirection.z * force;

            console.log(`ðŸŽ± HIT BALL: Power=${power}% | Force=${force} | Velocity=(${cueBall.velocity.x.toFixed(3)}, ${cueBall.velocity.z.toFixed(3)})`);
            console.log(`   Cue ball position: (${cueBall.position.x.toFixed(3)}, ${cueBall.position.z.toFixed(3)})`);
            console.log(`   Ball radius: ${BALL_RADIUS} | Min collision distance: ${(BALL_RADIUS * 2).toFixed(4)}`);

            ballsInMotion = true;
        }

        function updatePhysics(deltaTime) {
            let anyBallMoving = false;

            // Decrement collision cooldowns
            if (cueBall.collisionCooldown > 0) cueBall.collisionCooldown -= deltaTime;
            balls.forEach(ball => {
                if (ball.collisionCooldown > 0) ball.collisionCooldown -= deltaTime;
            });

            // Update cue ball
            if (cueBall.velocity.length() > 0.01 || cueBall.spin.length() > 0.01) {
                anyBallMoving = true;
                updateBallMotion(cueBall, deltaTime);

                // Wall collisions
                handleWallCollision(cueBall);

                // Check if cue ball fell in pocket
                if (checkPocket(cueBall)) {
                    cueBall.position.set(TABLE_LENGTH * 0.25, BALL_RADIUS, 0);
                    cueBall.velocity.set(0, 0, 0);
                    cueBall.spin.set(0, 0, 0);
                }
            } else {
                cueBall.velocity.set(0, 0, 0);
                cueBall.spin.set(0, 0, 0);
            }

            // Update other balls
            balls.forEach((ball, i) => {
                if (!ball.active) return;

                if (ball.velocity.length() > 0.01 || ball.spin.length() > 0.01) {
                    anyBallMoving = true;
                    updateBallMotion(ball, deltaTime);

                    // Wall collisions
                    handleWallCollision(ball);

                    // Check if ball fell in pocket
                    if (checkPocket(ball)) {
                        ball.active = false;
                        ball.visible = false;
                        ballsPotted++;
                        document.getElementById('ballsPotted').textContent = ballsPotted;
                    }
                } else {
                    ball.velocity.set(0, 0, 0);
                    ball.spin.set(0, 0, 0);
                }
            });

            // Handle collisions in a separate pass after all motion updates
            // Ball-to-ball collisions with cue ball
            balls.forEach(ball => {
                if (ball.active) {
                    checkBallCollision(cueBall, ball);
                }
            });

            // Ball-to-ball collisions between numbered balls
            for (let i = 0; i < balls.length; i++) {
                if (!balls[i].active) continue;
                for (let j = i + 1; j < balls.length; j++) {
                    if (balls[j].active) {
                        checkBallCollision(balls[i], balls[j]);
                    }
                }
            }

            ballsInMotion = anyBallMoving;
        }

        // Update ball motion using research-based physics (Petit/Alciatore)
        function updateBallMotion(ball, dt) {
            // Calculate relative surface velocity WE = W + z Ã— (R * Î©)
            // In 2D: WE = (vx, vz) + (-R*Ï‰z, R*Ï‰x) where Ï‰ is horizontal component
            const WE = new THREE.Vector3(
                ball.velocity.x - BALL_RADIUS * ball.spin.z,
                0,
                ball.velocity.z + BALL_RADIUS * ball.spin.x
            );
            const WE_magnitude = Math.sqrt(WE.x * WE.x + WE.z * WE.z);

            // Check if ball is sliding or rolling
            ball.sliding = WE_magnitude > 0.001;

            if (ball.sliding) {
                // SLIDING MOTION (Section 7.3 from Petit)
                // Ball experiences sliding friction

                // Calculate sliding direction
                const WE_norm = WE_magnitude > 0 ? WE.clone().multiplyScalar(1 / WE_magnitude) : new THREE.Vector3(0, 0, 0);

                // Apply sliding friction to velocity: dW/dt = -f*g*WE/||WE||
                const friction_decel = SLIDING_FRICTION * GRAVITY * dt;
                ball.velocity.x -= friction_decel * WE_norm.x;
                ball.velocity.z -= friction_decel * WE_norm.z;

                // Apply torque from friction to spin: dÎ©/dt = (5/2R) * z Ã— (friction force)
                // This increases spin in direction opposite to sliding
                const spin_change = (5 / (2 * BALL_RADIUS)) * friction_decel;
                ball.spin.x += spin_change * WE_norm.z;
                ball.spin.z -= spin_change * WE_norm.x;

                // Calculate rolling velocity: Wc = (5/7)(W - (2R/5) z Ã— Î©)
                const Wc_x = (5/7) * (ball.velocity.x + (2/5) * BALL_RADIUS * ball.spin.z);
                const Wc_z = (5/7) * (ball.velocity.z - (2/5) * BALL_RADIUS * ball.spin.x);

                // Check if we've transitioned to rolling (WE â‰ˆ 0)
                // This happens when W = Wc
                const v_diff_x = ball.velocity.x - Wc_x;
                const v_diff_z = ball.velocity.z - Wc_z;
                const v_diff_mag = Math.sqrt(v_diff_x * v_diff_x + v_diff_z * v_diff_z);

                if (v_diff_mag < friction_decel) {
                    // Snap to rolling condition
                    ball.velocity.x = Wc_x;
                    ball.velocity.z = Wc_z;
                    ball.spin.x = -ball.velocity.z / BALL_RADIUS;
                    ball.spin.z = ball.velocity.x / BALL_RADIUS;
                    ball.sliding = false;
                }
            } else {
                // ROLLING MOTION (Section 7.4 from Petit)
                // Ball rolling without sliding: W = -z Ã— (R*Î©)
                // Apply rolling resistance

                const speed = Math.sqrt(ball.velocity.x * ball.velocity.x + ball.velocity.z * ball.velocity.z);
                if (speed > 0.001) {
                    const roll_decel = ROLLING_RESISTANCE * GRAVITY * dt;
                    const new_speed = Math.max(0, speed - roll_decel);
                    const speed_ratio = new_speed / speed;

                    ball.velocity.x *= speed_ratio;
                    ball.velocity.z *= speed_ratio;

                    // Maintain rolling condition: Î© = z Ã— W / R
                    ball.spin.x = -ball.velocity.z / BALL_RADIUS;
                    ball.spin.z = ball.velocity.x / BALL_RADIUS;
                } else {
                    ball.velocity.set(0, 0, 0);
                    ball.spin.x = 0;
                    ball.spin.z = 0;
                }
            }

            // Apply spin friction to vertical spin (z-spin, Section 7.5 from Petit)
            // dÎ©y/dt = -(fz/R) * g * Î©y/||Î©y||
            if (Math.abs(ball.spin.y) > 0.001) {
                const spin_y_sign = ball.spin.y > 0 ? 1 : -1;
                const spin_y_decel = (SPIN_FRICTION / BALL_RADIUS) * GRAVITY * dt;
                const new_spin_y = Math.abs(ball.spin.y) - spin_y_decel;
                ball.spin.y = Math.max(0, new_spin_y) * spin_y_sign;
            }

            // Update position
            ball.position.x += ball.velocity.x * dt;
            ball.position.z += ball.velocity.z * dt;
        }

        function handleWallCollision(ball) {
            const maxX = TABLE_LENGTH/2 - BALL_RADIUS;
            const maxZ = TABLE_WIDTH/2 - BALL_RADIUS;

            // Cushion collision (similar to ball-ball but with M'/M = 0)
            let collided = false;
            let nx = 0, nz = 0;

            if (ball.position.x < -maxX) {
                ball.position.x = -maxX;
                nx = 1; nz = 0;
                collided = true;
            } else if (ball.position.x > maxX) {
                ball.position.x = maxX;
                nx = -1; nz = 0;
                collided = true;
            }

            if (ball.position.z < -maxZ) {
                ball.position.z = -maxZ;
                nx = 0; nz = 1;
                collided = true;
            } else if (ball.position.z > maxZ) {
                ball.position.z = maxZ;
                nx = 0; nz = -1;
                collided = true;
            }

            if (collided) {
                // Apply cushion collision physics (Petit equations with M'/M = 0)
                const dvn = ball.velocity.x * nx + ball.velocity.z * nz;

                if (dvn < 0) { // Ball moving into cushion
                    // Normal component: reflect with restitution
                    const v_normal = dvn * (1 + COR_CUSHION);
                    ball.velocity.x -= v_normal * nx;
                    ball.velocity.z -= v_normal * nz;

                    // Tangential component: reduce due to friction
                    const v_tangent_x = ball.velocity.x - (ball.velocity.x * nx + ball.velocity.z * nz) * nx;
                    const v_tangent_z = ball.velocity.z - (ball.velocity.x * nx + ball.velocity.z * nz) * nz;

                    // Apply friction to tangential velocity (cushion friction ~0.3-0.5)
                    const cushion_friction = 0.4;
                    ball.velocity.x = ball.velocity.x - cushion_friction * v_tangent_x;
                    ball.velocity.z = ball.velocity.z - cushion_friction * v_tangent_z;

                    // Spin is affected by cushion collision
                    // English (side spin) can affect bounce angle
                    const spin_effect = 0.2;
                    ball.velocity.x += spin_effect * ball.spin.y * nz;
                    ball.velocity.z -= spin_effect * ball.spin.y * nx;

                    ball.sliding = true;
                }
            }
        }

        // Ball-ball collision using simplified but accurate physics
        function checkBallCollision(ball1, ball2) {
            if (!ball2.active) return;

            const dx = ball2.position.x - ball1.position.x;
            const dz = ball2.position.z - ball1.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            const minDistance = BALL_RADIUS * 2;

            // Debug: Log when balls are close
            if (distance < minDistance + 0.01) {
                const ball1Name = ball1 === cueBall ? "CUE" : `BALL${ball1.number}`;
                const ball2Name = `BALL${ball2.number}`;
                console.log(`ðŸ” PROXIMITY: ${ball1Name} <-> ${ball2Name} | dist=${distance.toFixed(4)}m | minDist=${minDistance.toFixed(4)}m | cooldown1=${ball1.collisionCooldown.toFixed(3)}s | cooldown2=${ball2.collisionCooldown.toFixed(3)}s`);
            }

            // Check cooldown to prevent re-collision
            if (ball1.collisionCooldown > 0 || ball2.collisionCooldown > 0) {
                if (distance < minDistance) {
                    console.log(`â¸ï¸  COOLDOWN SKIP: Balls overlapping but in cooldown`);
                }
                return;
            }

            if (distance < minDistance && distance > 0.001) {
                const ball1Name = ball1 === cueBall ? "CUE" : `BALL${ball1.number}`;
                const ball2Name = `BALL${ball2.number}`;

                console.log(`ðŸ’¥ COLLISION START: ${ball1Name} <-> ${ball2Name}`);
                console.log(`   Distance: ${distance.toFixed(4)}m | Overlap: ${(minDistance - distance).toFixed(4)}m`);
                console.log(`   Ball1 vel: (${ball1.velocity.x.toFixed(3)}, ${ball1.velocity.z.toFixed(3)})`);
                console.log(`   Ball2 vel: (${ball2.velocity.x.toFixed(3)}, ${ball2.velocity.z.toFixed(3)})`);

                // Normal vector from ball1 to ball2
                const nx = dx / distance;
                const nz = dz / distance;

                // Tangent vector (perpendicular to normal)
                const tx = -nz;
                const tz = nx;

                // Relative velocity
                const dvx = ball1.velocity.x - ball2.velocity.x;
                const dvz = ball1.velocity.z - ball2.velocity.z;

                // Relative velocity in normal direction
                const dvn = dvx * nx + dvz * nz;

                console.log(`   Relative vel normal: ${dvn.toFixed(3)} (${dvn >= 0 ? 'SEPARATING' : 'APPROACHING'})`);

                // Don't resolve if separating
                if (dvn >= 0) {
                    console.log(`   âš ï¸  SKIPPED: Balls already separating`);
                    return;
                }

                // Relative velocity in tangent direction
                const dvt = dvx * tx + dvz * tz;

                // Apply collision with COR = 0.93 for normal component
                // For equal masses: v1_new = v2_old, v2_new = v1_old (with restitution)
                const impulse_normal = -(1 + COR_BALL_BALL) * dvn / 2;

                // Apply smaller impulse to tangent (friction during collision)
                const impulse_tangent = -dvt * 0.15; // Friction reduces tangent velocity

                console.log(`   Impulse normal: ${impulse_normal.toFixed(3)} | tangent: ${impulse_tangent.toFixed(3)}`);

                // Update velocities
                ball1.velocity.x += impulse_normal * nx + impulse_tangent * tx;
                ball1.velocity.z += impulse_normal * nz + impulse_tangent * tz;

                ball2.velocity.x -= impulse_normal * nx + impulse_tangent * tx;
                ball2.velocity.z -= impulse_normal * nz + impulse_tangent * tz;

                console.log(`   Ball1 vel after: (${ball1.velocity.x.toFixed(3)}, ${ball1.velocity.z.toFixed(3)})`);
                console.log(`   Ball2 vel after: (${ball2.velocity.x.toFixed(3)}, ${ball2.velocity.z.toFixed(3)})`);

                // Simplified spin transfer (throw effect)
                // Tangential impulse creates spin
                const spin_transfer = impulse_tangent / (BALL_RADIUS * 5);
                ball1.spin.y += spin_transfer;
                ball2.spin.y -= spin_transfer;

                // Separate balls to prevent overlap (critical for stability)
                const overlap = minDistance - distance;
                if (overlap > 0) {
                    const separation = (overlap / 2) + 0.001;
                    console.log(`   Separating by: ${separation.toFixed(4)}m in direction (${nx.toFixed(3)}, ${nz.toFixed(3)})`);
                    ball1.position.x -= separation * nx;
                    ball1.position.z -= separation * nz;
                    ball2.position.x += separation * nx;
                    ball2.position.z += separation * nz;
                }

                // Mark balls as sliding after collision
                ball1.sliding = true;
                ball2.sliding = true;

                // Set collision cooldown to prevent immediate re-collision
                ball1.collisionCooldown = 0.05; // 50ms cooldown
                ball2.collisionCooldown = 0.05;

                console.log(`âœ… COLLISION COMPLETE: Cooldown set to 0.05s`);
            }
        }

        function checkPocket(ball) {
            for (const pocket of pockets) {
                const dx = ball.position.x - pocket.x;
                const dz = ball.position.z - pocket.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < POCKET_RADIUS) {
                    return true;
                }
            }
            return false;
        }

        function resetGame() {
            cueBall.position.set(TABLE_LENGTH * 0.25, BALL_RADIUS, 0);
            cueBall.velocity.set(0, 0, 0);
            cueBall.spin.set(0, 0, 0);
            cueBall.sliding = false;
            ballsPotted = 0;
            document.getElementById('ballsPotted').textContent = ballsPotted;
            rackBalls();
            ballsInMotion = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updatePhysics(deltaTime);

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

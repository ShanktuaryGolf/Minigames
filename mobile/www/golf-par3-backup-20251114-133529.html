<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Par 3 Golf Hole</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #87CEEB;
        }

        #canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 13px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin: 4px 0;
            font-size: 13px;
            transition: all 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>⛳ Par 3 - Hole 1</h3>

        <div class="stat-section">
            <div class="stat-row">
                <span class="stat-label">Distance to Pin:</span>
                <span class="stat-value" id="distanceToPin">130 yds</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Lie:</span>
                <span class="stat-value" id="lieType">Tee</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Strokes:</span>
                <span class="stat-value" id="strokes">0</span>
            </div>
        </div>

        <div class="stat-section" id="shotDetails" style="display: none;">
            <h3 style="font-size: 14px; margin: 0 0 8px 0; color: #FFD700;">Last Shot</h3>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="shotSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Launch Angle:</span>
                <span class="stat-value" id="shotVLA">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Side Angle:</span>
                <span class="stat-value" id="shotHLA">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Carry:</span>
                <span class="stat-value" id="shotCarry">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Roll:</span>
                <span class="stat-value" id="shotRoll">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total:</span>
                <span class="stat-value" id="shotTotal">--</span>
            </div>
        </div>

        <div class="stat-section" id="demoShot">
            <h3 style="font-size: 14px; margin: 0 0 8px 0; color: #FFD700;">Demo Shot (D Key)</h3>
            <div class="stat-row">
                <span class="stat-label">Speed:</span>
                <input type="range" id="demoSpeed" min="0" max="212" value="75" style="width: 100px;">
                <span class="stat-value" id="demoSpeedVal">75 mph</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Launch:</span>
                <input type="range" id="demoVLA" min="0" max="45" value="18" style="width: 100px;">
                <span class="stat-value" id="demoVLAVal">18°</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Direction:</span>
                <input type="range" id="demoHLA" min="-180" max="180" value="0" style="width: 100px;">
                <span class="stat-value" id="demoHLAVal">0°</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Spin:</span>
                <input type="range" id="demoTotalSpin" min="0" max="10000" value="5500" step="100" style="width: 100px;">
                <span class="stat-value" id="demoTotalSpinVal">5500 rpm</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Spin Axis:</span>
                <input type="range" id="demoSpinAxis" min="-45" max="45" value="0" step="1" style="width: 100px;">
                <span class="stat-value" id="demoSpinAxisVal">0°</span>
            </div>
        </div>

        <button id="viewBtn">Change View</button>
        <button id="gridBtn">Toggle Grid</button>
        <button id="resetBtn">Reset Hole</button>

        <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
            <label style="display: flex; align-items: center; cursor: pointer;">
                <input type="checkbox" id="lowSpeedToggle" style="margin-right: 8px;">
                <span>Low Speed Practice</span>
            </label>
        </div>

        <div style="margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px;">
            <div style="font-weight: bold; margin-bottom: 5px;">Aim Adjustment</div>
            <div style="font-size: 24px; color: #FFD700; text-align: center;" id="aimDisplay">0°</div>
            <div style="font-size: 11px; color: #aaa; text-align: center; margin-top: 5px;">
                ← Left | → Right | ↑ Reset
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let ball, flagstick, hole, cup;
        let terrain, teebox, green, bunker;
        let ballInFlight = false;
        let strokes = 0;

        // Ball state
        let ballPosition = new THREE.Vector3();
        let ballVelocity = new THREE.Vector3();
        let ballSpin = { totalSpin: 0, spinAxis: 0 }; // totalSpin in rpm, spinAxis in degrees

        // Course layout (in meters, 1 yard = 0.9144 meters)
        const TEE_POSITION = new THREE.Vector3(0, 3, 0); // Elevated 3m
        const PIN_POSITION = new THREE.Vector3(0, 0, -118.872); // 130 yards = 118.872m
        const BUNKER_LEFT_POSITION = new THREE.Vector3(-16, -0.3, -118.872); // Left of green, well outside 10m radius
        const BUNKER_RIGHT_POSITION = new THREE.Vector3(16, -0.3, -118.872); // Right of green, well outside 10m radius

        // Physics constants - from TrajectoryCalculatorGolf-v2.xlsx (keeping Excel formulas)
        const GRAVITY = 32.174; // ft/s² (Excel uses imperial)
        const BALL_MASS_OZ = 1.62; // oz
        const BALL_MASS_SLUGS = BALL_MASS_OZ / 514.78; // Convert oz to slugs
        const BALL_CIRC = 5.277; // inches
        const BALL_RADIUS_FT = (BALL_CIRC / (2 * Math.PI)) / 12; // Convert to feet
        const BALL_RADIUS = BALL_RADIUS_FT * 0.3048; // Convert to meters for THREE.js

        // Air density (slug/ft³)
        const AIR_DENSITY_SLUGS_DEFAULT = 0.0748;

        // Magnus constant from Excel (D4)
        const MAGNUS_CONST = 0.00568249207;

        // Drag constant formula from Excel: 0.07182*rho*(5.125/mass)*(circ/9.125)^2
        function getDragConstant(airDensitySlugs) {
            return 0.07182 * airDensitySlugs * (5.125 / BALL_MASS_OZ) * Math.pow(BALL_CIRC / 9.125, 2);
        }

        const DRAG_CONST = getDragConstant(AIR_DENSITY_SLUGS_DEFAULT);

        // Lookup table for lift and drag coefficients based on speed and spin rate
        // From golf-flight-sim-3d project (empirical data)
        // Rows: speed squared (m²/s²), Columns: spin rate (rpm)
        const COEFF_LUT = [
            [{lift: -0.11, drag: 0.52}, {lift: -0.06, drag: 0.39}, {lift: 0.06, drag: 0.36}, {lift: 0.35, drag: 0.42}, {lift: 0.39, drag: 0.40}, {lift: 0.41, drag: 0.48}, {lift: 0.49, drag: 0.52}],
            [{lift:  0.00, drag: 0.33}, {lift:  0.12, drag: 0.25}, {lift: 0.18, drag: 0.28}, {lift: 0.33, drag: 0.36}, {lift: 0.36, drag: 0.38}, {lift: 0.38, drag: 0.43}, {lift: 0.45, drag: 0.45}],
            [{lift:  0.06, drag: 0.22}, {lift:  0.17, drag: 0.24}, {lift: 0.24, drag: 0.27}, {lift: 0.29, drag: 0.31}, {lift: 0.33, drag: 0.34}, {lift: 0.34, drag: 0.37}, {lift: 0.39, drag: 0.39}],
            [{lift:  0.07, drag: 0.23}, {lift:  0.14, drag: 0.23}, {lift: 0.19, drag: 0.25}, {lift: 0.24, drag: 0.28}, {lift: 0.28, drag: 0.30}, {lift: 0.31, drag: 0.33}, {lift: 0.35, drag: 0.36}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.13, drag: 0.24}, {lift: 0.16, drag: 0.25}, {lift: 0.20, drag: 0.27}, {lift: 0.24, drag: 0.28}, {lift: 0.27, drag: 0.30}, {lift: 0.31, drag: 0.34}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.12, drag: 0.24}, {lift: 0.15, drag: 0.25}, {lift: 0.18, drag: 0.26}, {lift: 0.21, drag: 0.26}, {lift: 0.24, drag: 0.29}, {lift: 0.28, drag: 0.32}],
            [{lift:  0.08, drag: 0.25}, {lift:  0.12, drag: 0.25}, {lift: 0.14, drag: 0.25}, {lift: 0.17, drag: 0.26}, {lift: 0.19, drag: 0.26}, {lift: 0.22, drag: 0.28}, {lift: 0.26, drag: 0.29}],
            [{lift:  0.08, drag: 0.25}, {lift:  0.12, drag: 0.25}, {lift: 0.14, drag: 0.25}, {lift: 0.16, drag: 0.26}, {lift: 0.18, drag: 0.26}, {lift: 0.20, drag: 0.28}, {lift: 0.23, drag: 0.29}],
            [{lift:  0.07, drag: 0.25}, {lift:  0.11, drag: 0.25}, {lift: 0.13, drag: 0.25}, {lift: 0.15, drag: 0.26}, {lift: 0.17, drag: 0.26}, {lift: 0.18, drag: 0.27}, {lift: 0.22, drag: 0.28}],
            [{lift:  0.07, drag: 0.24}, {lift:  0.11, drag: 0.24}, {lift: 0.13, drag: 0.25}, {lift: 0.15, drag: 0.26}, {lift: 0.16, drag: 0.26}, {lift: 0.17, drag: 0.27}, {lift: 0.20, drag: 0.27}]
        ];

        function getLiftDragCoefficients(speedSquared, spinRate) {
            let row, col;

            // Determine row based on speed squared (m²/s²)
            if (speedSquared > 7249.0) row = 9;
            else if (speedSquared > 5939.0) row = 8;
            else if (speedSquared > 4698.0) row = 7;
            else if (speedSquared > 3588.0) row = 6;
            else if (speedSquared > 2654.0) row = 5;
            else if (speedSquared > 1874.0) row = 4;
            else if (speedSquared > 1226.0) row = 3;
            else if (speedSquared > 705.0) row = 2;
            else if (speedSquared > 338.0) row = 1;
            else row = 0;

            // Determine column based on spin rate (rpm)
            if (spinRate > 5478.0) col = 6;
            else if (spinRate > 4223.0) col = 5;
            else if (spinRate > 3283.0) col = 4;
            else if (spinRate > 2340.0) col = 3;
            else if (spinRate > 1433.0) col = 2;
            else if (spinRate > 500.0) col = 1;
            else col = 0;

            return COEFF_LUT[row][col];
        }

        // Lie conditions - calibrated to match FlightScope rollout (~8-10 yards)
        const LIE_TYPES = {
            TEE: { name: 'Tee', friction: 15.0, rollFactor: 0.9, bounceRetention: 0.3, color: 0x2d5a3d },
            FAIRWAY: { name: 'Fairway', friction: 15.0, rollFactor: 0.7, bounceRetention: 0.3, color: 0x4a9d5f },
            LIGHT_ROUGH: { name: 'Light Rough', friction: 25.0, rollFactor: 0.4, bounceRetention: 0.2, color: 0x3a7d44 },
            HEAVY_ROUGH: { name: 'Heavy Rough', friction: 40.0, rollFactor: 0.2, bounceRetention: 0.15, color: 0x2d5a28 },
            BUNKER: { name: 'Bunker', friction: 50.0, rollFactor: 0.1, bounceRetention: 0.1, color: 0xddc998 },
            GREEN: { name: 'Green', friction: 8.0, rollFactor: 0.95, bounceRetention: 0.3, color: 0x4a9d5f }
        };

        let currentLie = LIE_TYPES.TEE;

        // Tree collision data
        let trees = [];

        // Shot tracking
        let shotStartPos = new THREE.Vector3();
        let maxHeight = 0;
        let carryDistance = 0;
        let landingPos = new THREE.Vector3();
        let hasLanded = false;
        let lastTime = performance.now();
        let debugMode = false; // Debug camera mode

        // Camera system
        let currentView = 'behind-ball';
        let savedView = 'behind-ball';

        // Ball tracer
        let tracer = null;
        let tracerPositions = [];
        const MAX_TRACER_POINTS = 200;

        // Raycaster for terrain collision
        let raycaster = new THREE.Raycaster();

        // Grid visualization
        let gridLines = null;
        let showGrid = false;

        // Shot direction adjustment
        let aimAdjustment = 0; // Degrees to add to HLA
        let baseDirection = 0; // Base direction (0 = toward pin, updated after each shot)

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            camera.lookAt(0, 0, -60);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            createCourse();
            createBall();
            createTracer();

            // Create trees AFTER terrain is fully in scene
            // Use setTimeout to ensure terrain mesh is ready for raycasting
            setTimeout(() => {
                createTreeLine();
            }, 100);

            // Set initial camera view after ball is created
            updateCameraPosition(false);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('resetBtn').addEventListener('click', resetHole);
            document.getElementById('viewBtn').addEventListener('click', cycleView);
            document.getElementById('gridBtn').addEventListener('click', toggleGrid);

            // Demo shot controls
            setupDemoShotControls();

            // Listen for shot data from Electron IPC (if available)
            if (window.api) {
                window.api.onShotData(handleShotFromElectron);
            }

            // Test shot for development
            setTimeout(() => {
                if (!window.api) {
                    console.log('Running in standalone mode - use demo shot with D key');
                }
            }, 1000);

            // Add keyboard shortcuts
            const cameraSpeed = 2;

            window.addEventListener('keydown', (e) => {
                // Arrow keys - Adjust aim direction (1 degree increments)
                if (e.key === 'ArrowLeft') {
                    aimAdjustment -= 1; // Rotate 1 degree left
                    updateAimIndicator();
                    console.log(`Aim adjusted: ${aimAdjustment}° (Left)`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowRight') {
                    aimAdjustment += 1; // Rotate 1 degree right
                    updateAimIndicator();
                    console.log(`Aim adjusted: ${aimAdjustment}° (Right)`);
                    e.preventDefault();
                }
                if (e.key === 'ArrowUp') {
                    aimAdjustment = 0; // Reset to straight
                    updateAimIndicator();
                    console.log('Aim reset to 0°');
                    e.preventDefault();
                }

                // D key - Demo shot
                if (e.key === 'd' || e.key === 'D') {
                    // Use demo shot controls
                    const speed = parseFloat(document.getElementById('demoSpeed').value);
                    const vla = parseFloat(document.getElementById('demoVLA').value);
                    const hla = parseFloat(document.getElementById('demoHLA').value);
                    const totalSpin = parseFloat(document.getElementById('demoTotalSpin').value);
                    const spinAxis = parseFloat(document.getElementById('demoSpinAxis').value);

                    handleShot({
                        detail: {
                            speed: speed,
                            vla: vla,
                            hla: hla,
                            total_spin: totalSpin,
                            spin_axis: spinAxis
                        }
                    });
                }

                // F key - Toggle free camera mode
                if (e.key === 'f' || e.key === 'F') {
                    debugMode = !debugMode;
                    console.log('Debug camera mode:', debugMode ? 'ON' : 'OFF');
                }

                // Arrow keys and WASD for camera movement (when in debug mode)
                if (debugMode) {
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        camera.position.z -= cameraSpeed;
                    }
                    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                        camera.position.z += cameraSpeed;
                    }
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        camera.position.x -= cameraSpeed;
                    }
                    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        camera.position.x += cameraSpeed;
                    }
                    if (e.key === 'q' || e.key === 'Q') {
                        camera.position.y += cameraSpeed;
                    }
                    if (e.key === 'e' || e.key === 'E') {
                        camera.position.y -= cameraSpeed;
                    }

                    // Look at center of green
                    camera.lookAt(PIN_POSITION);
                }
            });
        }

        function createCourse() {
            // Main terrain (fairway and rough) - large enough to fill view with high detail
            const terrainGeometry = new THREE.PlaneGeometry(200, 300, 100, 150);
            const vertices = terrainGeometry.attributes.position.array;

            // Create elevation - elevated tee, gradual slope down to green with natural features
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 1];

                let height = 0;

                // Tee area (elevated)
                if (z > -10 && z < 10) {
                    height = 3 - Math.abs(z) * 0.3;
                }
                // Slope from tee to fairway
                else if (z >= -30 && z <= -10) {
                    height = 3 - (Math.abs(z) - 10) * 0.1;
                }
                // Fairway (slight downslope with natural undulations)
                else if (z > -110 && z <= -30) {
                    height = 1 - ((Math.abs(z) - 30) / 80) * 1.5;

                    // Multiple layers of natural undulations for organic look
                    height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                    height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                    height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                    // Random-looking hills using multiple frequencies
                    height += Math.sin(x * 0.7) * Math.cos(z * 0.1) * 0.35;
                    height += Math.cos(x * 0.12 + z * 0.18) * 0.25;

                    // Irregular mounds on the sides (rough areas)
                    if (Math.abs(x) > 12) {
                        const distFromFairway = Math.abs(x) - 12;
                        // Create irregular mounding
                        height += Math.sin(z * 0.4 + x * 0.2) * distFromFairway * 0.15;
                        height += Math.cos(x * 0.6 - z * 0.15) * (distFromFairway * 0.1);
                        height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                        // Add some dramatic mounds in rough
                        const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                        if (moundNoise > 0.3) {
                            height += moundNoise * 0.8;
                        }
                    }
                }
                // Approach to green with protective mounding
                else if (z > -125 && z <= -110) {
                    height = -0.2;

                    // Greenside mounds (irregular and natural)
                    const distToGreen = Math.sqrt(Math.pow(x, 2) + Math.pow(z + 118.872, 2));
                    if (distToGreen > 10 && distToGreen < 16) {
                        // Create raised mounding around green with irregular pattern
                        const angle = Math.atan2(x, z + 118.872);
                        const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5; // Vary by position
                        height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                        height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                        height += Math.sin(x * 1.1) * Math.cos((z + 118.872) * 0.9) * 0.5;
                    }

                    // Natural undulations around green
                    height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                    height += Math.cos(x * 0.8 - z * 0.4) * 0.25;
                }
                // Green area (subtle undulation, not completely flat)
                else {
                    const distToPin = Math.sqrt(Math.pow(x, 2) + Math.pow(z + 118.872, 2));

                    if (distToPin < 10) {
                        // Green itself with very subtle breaks
                        height = -0.2 + Math.sin(x * 0.5) * 0.05 + Math.cos((z + 118.872) * 0.4) * 0.05;
                    } else {
                        // Beyond green
                        height = -0.2;
                    }
                }

                vertices[i + 2] = height;
            }

            terrainGeometry.computeVertexNormals();

            // Apply vertex colors based on fairway/rough zones with organic transitions
            const colors = [];
            const positions = terrainGeometry.attributes.position;

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // Remember geometry is rotated

                let color = new THREE.Color();

                // Add complex noise to edge boundaries for very organic look
                const noise1 = Math.sin(z * 0.6 + x * 0.2) * 1.2;
                const noise2 = Math.cos(z * 0.35 - x * 0.15) * 0.9;
                const noise3 = Math.sin(z * 0.8 + x * 0.5) * 0.6;
                const totalNoise = noise1 + noise2 + noise3;

                const fairwayEdge = 12 + totalNoise;
                const roughEdge = 20 + totalNoise * 0.7;

                // Fairway - center corridor with natural edges
                if (Math.abs(x) < fairwayEdge) {
                    // Slight color variation in fairway
                    const variation = (Math.sin(x * 0.2 + z * 0.1) * 0.5 + 0.5) * 0.05;
                    color.setHex(0x4a9d5f);
                    color.r += variation;
                    color.g += variation;
                }
                // Light rough (with natural transition)
                else if (Math.abs(x) >= fairwayEdge && Math.abs(x) < roughEdge) {
                    // Blend between fairway and light rough
                    const blend = (Math.abs(x) - fairwayEdge) / (roughEdge - fairwayEdge);
                    const fairwayColor = new THREE.Color(0x4a9d5f);
                    const lightRoughColor = new THREE.Color(0x3a7d44);
                    color.lerpColors(fairwayColor, lightRoughColor, blend);
                }
                // Heavy rough (beyond edges)
                else {
                    // Transition to heavy rough
                    const distIntoRough = Math.min((Math.abs(x) - roughEdge) / 10, 1);
                    const lightRoughColor = new THREE.Color(0x3a7d44);
                    const heavyRoughColor = new THREE.Color(0x2d5a28);
                    color.lerpColors(lightRoughColor, heavyRoughColor, distIntoRough);
                }

                colors.push(color.r, color.g, color.b);
            }

            terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const terrainMaterial = new THREE.MeshLambertMaterial({
                vertexColors: true,
                side: THREE.DoubleSide
            });
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // Tee box (darker, elevated platform)
            const teeGeometry = new THREE.BoxGeometry(6, 0.2, 8);
            const teeMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5a3d });
            teebox = new THREE.Mesh(teeGeometry, teeMaterial);
            teebox.position.set(0, 3, 0);
            teebox.receiveShadow = true;
            scene.add(teebox);

            // Green (very smooth, brighter color to distinguish from fairway)
            const greenGeometry = new THREE.CircleGeometry(10, 32);
            const greenMaterial = new THREE.MeshLambertMaterial({ color: 0x5cb574 }); // Brighter green
            green = new THREE.Mesh(greenGeometry, greenMaterial);
            green.rotation.x = -Math.PI / 2;
            green.position.set(0, -0.15, -118.872);
            green.receiveShadow = true;
            scene.add(green);

            // Left bunker (kidney bean shape - larger)
            const bunkerLeftShape = new THREE.Shape();
            bunkerLeftShape.moveTo(0, 0);
            bunkerLeftShape.bezierCurveTo(1.5, 0, 2.5, 0.8, 2.8, 2);
            bunkerLeftShape.bezierCurveTo(3, 3, 2.5, 4.5, 1.5, 5);
            bunkerLeftShape.bezierCurveTo(0.5, 5.3, -0.5, 5, -1.2, 4);
            bunkerLeftShape.bezierCurveTo(-1.8, 3.2, -2, 2.5, -1.5, 1.8);
            bunkerLeftShape.bezierCurveTo(-1, 1.2, -0.3, 1.3, 0.2, 1.8);
            bunkerLeftShape.bezierCurveTo(0.6, 2.2, 0.5, 2.8, 0, 2.8);
            bunkerLeftShape.bezierCurveTo(-0.5, 2.8, -0.8, 2.3, -0.8, 1.8);
            bunkerLeftShape.bezierCurveTo(-0.8, 1, -0.3, 0.3, 0, 0);

            const bunkerLeftGeometry = new THREE.ShapeGeometry(bunkerLeftShape);
            const bunkerMaterial = new THREE.MeshLambertMaterial({ color: 0xddc998 });
            const bunkerLeft = new THREE.Mesh(bunkerLeftGeometry, bunkerMaterial);
            bunkerLeft.rotation.x = -Math.PI / 2;
            bunkerLeft.rotation.z = -Math.PI / 2; // Orient along green
            bunkerLeft.position.set(BUNKER_LEFT_POSITION.x, -0.19, BUNKER_LEFT_POSITION.z);
            bunkerLeft.receiveShadow = true;
            scene.add(bunkerLeft);

            // Right bunker (kidney bean shape - mirrored and smaller than left)
            const bunkerRightShape = new THREE.Shape();
            bunkerRightShape.moveTo(0, 0);
            bunkerRightShape.bezierCurveTo(1.2, 0, 2, 0.6, 2.2, 1.5);
            bunkerRightShape.bezierCurveTo(2.4, 2.3, 2, 3.5, 1.2, 3.8);
            bunkerRightShape.bezierCurveTo(0.4, 4, -0.3, 3.8, -0.8, 3);
            bunkerRightShape.bezierCurveTo(-1.3, 2.4, -1.5, 1.8, -1.1, 1.3);
            bunkerRightShape.bezierCurveTo(-0.7, 0.9, -0.2, 1, 0.1, 1.3);
            bunkerRightShape.bezierCurveTo(0.4, 1.6, 0.3, 2.1, 0, 2.1);
            bunkerRightShape.bezierCurveTo(-0.3, 2.1, -0.5, 1.7, -0.5, 1.3);
            bunkerRightShape.bezierCurveTo(-0.5, 0.7, -0.2, 0.2, 0, 0);

            const bunkerRightGeometry = new THREE.ShapeGeometry(bunkerRightShape);
            const bunkerRight = new THREE.Mesh(bunkerRightGeometry, bunkerMaterial);
            bunkerRight.rotation.x = -Math.PI / 2;
            bunkerRight.rotation.z = Math.PI / 2; // Orient along green like left bunker
            bunkerRight.position.set(BUNKER_RIGHT_POSITION.x, -0.19, BUNKER_RIGHT_POSITION.z);
            bunkerRight.receiveShadow = true;
            scene.add(bunkerRight);

            // Cup (hole)
            const cupGeometry = new THREE.CylinderGeometry(0.054, 0.054, 0.1, 16); // 4.25 inch diameter
            const cupMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            cup = new THREE.Mesh(cupGeometry, cupMaterial);
            cup.position.set(PIN_POSITION.x, -0.2, PIN_POSITION.z);
            scene.add(cup);

            // Flagstick
            const poleGeometry = new THREE.CylinderGeometry(0.01, 0.01, 2.1, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1.05;

            const flagGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const flagMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.15, 1.9, 0);

            flagstick = new THREE.Group();
            flagstick.add(pole);
            flagstick.add(flag);
            flagstick.position.copy(PIN_POSITION);
            flagstick.position.y = -0.2;
            scene.add(flagstick);

            // Tee markers
            createTeeMarker(-1, 3.15, 3, 0xff0000);
            createTeeMarker(1, 3.15, 3, 0xff0000);
        }

        function createTreeLine() {
            console.log('Creating trees with raycasting...');
            let treeCount = 0;

            // Left side trees
            for (let i = 0; i < 30; i++) {
                const z = -10 - i * 8 + (Math.random() - 0.5) * 4;
                const x = -25 - Math.random() * 15;
                const height = 8 + Math.random() * 6;
                const groundY = getGroundHeightRaycast(x, z);
                createTree(x, groundY, z, height);
                treeCount++;
            }

            // Right side trees
            for (let i = 0; i < 30; i++) {
                const z = -10 - i * 8 + (Math.random() - 0.5) * 4;
                const x = 25 + Math.random() * 15;
                const height = 8 + Math.random() * 6;
                const groundY = getGroundHeightRaycast(x, z);
                createTree(x, groundY, z, height);
                treeCount++;
            }

            // Behind green trees
            for (let i = 0; i < 12; i++) {
                const x = -30 + i * 5 + (Math.random() - 0.5) * 3;
                const z = -130 - Math.random() * 10;
                const height = 10 + Math.random() * 5;
                const groundY = getGroundHeightRaycast(x, z);
                createTree(x, groundY, z, height);
                treeCount++;
            }

            console.log(`Total trees created: ${treeCount}`);
        }

        function createTree(x, y, z, height) {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkHeight = height * 0.4;
            const trunkRadius = 0.3 + Math.random() * 0.2;

            // Store tree data for collision detection
            trees.push({
                position: { x, y, z },
                radius: trunkRadius * 1.5,
                height: height
            });

            // Create trunk - cylinder origin is at center, so offset by half height
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2; // Offset so bottom of cylinder is at y=0 in group space
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Foliage (3 layers for depth)
            const foliageColors = [0x2d5016, 0x3a6b1f, 0x4a7d28];
            const foliageHeight = height * 0.6;

            for (let i = 0; i < 3; i++) {
                const coneHeight = foliageHeight * (1 - i * 0.15);
                const coneRadius = (height * 0.35) * (1 - i * 0.2);
                const foliageGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 8);
                const foliageMaterial = new THREE.MeshLambertMaterial({
                    color: foliageColors[i],
                    flatShading: true
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + (i * coneHeight * 0.4);
                foliage.castShadow = true;
                foliage.receiveShadow = true;
                treeGroup.add(foliage);
            }

            // Position the entire tree group at the ground height
            treeGroup.position.set(x, y, z);
            scene.add(treeGroup);
        }

        function createTeeMarker(x, y, z, color) {
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshLambertMaterial({ color });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(x, y, z);
            marker.castShadow = true;
            scene.add(marker);
        }

        function createBall() {
            const geometry = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.1
            });
            ball = new THREE.Mesh(geometry, material);
            ball.castShadow = true;
            ball.receiveShadow = true;
            resetBallPosition();
            scene.add(ball);
        }

        function createTracer() {
            // Create line geometry for tracer
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(MAX_TRACER_POINTS * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Glowing tracer material
            const material = new THREE.LineBasicMaterial({
                color: 0xFFFFFF,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });

            tracer = new THREE.Line(geometry, material);
            tracer.frustumCulled = false;
            scene.add(tracer);
        }

        function updateTracer() {
            if (!ballInFlight) {
                // Clear tracer when ball is not in flight
                tracerPositions = [];
                const positions = tracer.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i++) {
                    positions[i] = 0;
                }
                tracer.geometry.attributes.position.needsUpdate = true;
                tracer.geometry.setDrawRange(0, 0);
                return;
            }

            // Add current ball position to tracer
            tracerPositions.push(ballPosition.clone());

            // Keep only last MAX_TRACER_POINTS positions
            if (tracerPositions.length > MAX_TRACER_POINTS) {
                tracerPositions.shift();
            }

            // Update line geometry
            const positions = tracer.geometry.attributes.position.array;
            for (let i = 0; i < tracerPositions.length; i++) {
                positions[i * 3] = tracerPositions[i].x;
                positions[i * 3 + 1] = tracerPositions[i].y;
                positions[i * 3 + 2] = tracerPositions[i].z;
            }

            tracer.geometry.attributes.position.needsUpdate = true;
            tracer.geometry.setDrawRange(0, tracerPositions.length);
        }

        function resetBallPosition() {
            ballPosition.copy(TEE_POSITION);

            // Tee box is at y=3 with height 0.2, so surface is at 3 + 0.2/2 = 3.1
            const teeBoxSurfaceHeight = 3.1;
            // Add tee height (~1 inch = 0.0254m) plus ball radius
            ballPosition.y = teeBoxSurfaceHeight + BALL_RADIUS + 0.025;

            console.log(`Reset ball: Tee surface=${teeBoxSurfaceHeight.toFixed(3)}, Ball radius=${BALL_RADIUS.toFixed(3)}, Final Y=${ballPosition.y.toFixed(3)}`);

            ball.position.copy(ballPosition);
            ballVelocity.set(0, 0, 0);
            currentLie = LIE_TYPES.TEE;
            updateUI();
        }

        function handleShotFromElectron(data) {
            handleShot({ detail: data });
        }

        function handleShot(event) {
            if (ballInFlight) return;

            let { speed, vla, hla, total_spin, spin_axis } = event.detail;

            // Apply base direction and aim adjustment
            hla = hla + baseDirection + aimAdjustment;

            // Apply low speed modifier if enabled
            const lowSpeedEnabled = document.getElementById('lowSpeedToggle').checked;
            if (lowSpeedEnabled) {
                speed = speed * 0.5; // Reduce speed to 50%
                total_spin = total_spin * 0.5;
            }

            // Convert spin axis to radians and calculate backspin/sidespin components
            const spinAxisRad = spin_axis * Math.PI / 180;
            const backspin = total_spin * Math.cos(spinAxisRad);
            const sidespin = total_spin * Math.sin(spinAxisRad);

            // Convert to SI units
            const speedMS = speed * 0.44704; // mph to m/s
            const vlaRad = vla * Math.PI / 180;
            const hlaRad = hla * Math.PI / 180;

            console.log(`Shot fired: HLA=${hla.toFixed(1)}° (base + ${aimAdjustment}° adjustment)`);
            console.log(`Spin: ${total_spin.toFixed(0)} rpm @ ${spin_axis.toFixed(1)}° axis → Backspin: ${backspin.toFixed(0)} rpm, Sidespin: ${sidespin.toFixed(0)} rpm`);

            // Calculate velocity vector
            ballVelocity.set(
                speedMS * Math.sin(hlaRad) * Math.cos(vlaRad),
                speedMS * Math.sin(vlaRad),
                -speedMS * Math.cos(hlaRad) * Math.cos(vlaRad)
            );

            ballSpin.totalSpin = total_spin;
            ballSpin.spinAxis = spin_axis;

            ballInFlight = true;
            shotStartPos.copy(ballPosition);
            maxHeight = ballPosition.y;
            hasLanded = false;
            strokes++;

            // Update shot details
            document.getElementById('shotSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('shotVLA').textContent = vla.toFixed(1) + '°';
            document.getElementById('shotHLA').textContent = hla.toFixed(1) + '°';
            document.getElementById('shotDetails').style.display = 'block';

            updateUI();
        }

        function updateBallPhysics(deltaTime) {
            if (!ballInFlight) return;

            // Convert velocity from m/s to ft/s for Excel formulas
            // THREE.js: X=left/right, Y=up/down, Z=forward/back (negative = forward)
            // Excel: X=left/right, Y=forward/back, Z=up/down
            const vxFtS = ballVelocity.x * 3.28084;      // X stays X (lateral)
            const vyFtS = -ballVelocity.z * 3.28084;     // -Z becomes Y (forward is positive)
            const vzFtS = ballVelocity.y * 3.28084;      // Y becomes Z (vertical)

            const speed = Math.sqrt(vxFtS * vxFtS + vyFtS * vyFtS + vzFtS * vzFtS);

            // Debug on first frame
            if (ballPosition.y > 3 && ballPosition.y < 3.1) {
                console.log(`Physics: Speed=${speed.toFixed(1)} ft/s, Drag const=${DRAG_CONST.toFixed(6)}, Magnus const=${MAGNUS_CONST.toFixed(6)}`);
            }

            // Convert spin from RPM to rad/s, then to components
            const spinAxisRad = ballSpin.spinAxis * Math.PI / 180;
            const totalSpinRadS = ballSpin.totalSpin * Math.PI / 30; // RPM to rad/s

            // Spin components (Excel formula from D11-D13)
            // wx, wy, wz in rad/s
            const wx = totalSpinRadS * Math.cos(spinAxisRad);  // Backspin component
            const wy = -totalSpinRadS * Math.sin(spinAxisRad); // Sidespin component
            const wz = 0;

            // Drag force (Excel formula from W32-Y32)
            // Drag = -const * Cd * speed * velocity_component
            let dragAccelX = 0, dragAccelY = 0, dragAccelZ = 0;
            if (speed > 0.1) {
                // Tuning Cd to match FlightScope expected carry distance
                // Excel R32 shows ~0.152, but needs adjustment for our integration method
                const Cd = 0.52;
                const dragFactor = -DRAG_CONST * Cd * speed;
                dragAccelX = dragFactor * vxFtS;
                dragAccelY = dragFactor * vyFtS;
                dragAccelZ = dragFactor * vzFtS;
            }

            // Magnus force (Excel formula from AA32-AC32)
            // F_magnus = MAGNUS_CONST * (liftCoeff / omega) * speed * (w × v)
            let magnusAccelX = 0, magnusAccelY = 0, magnusAccelZ = 0;
            if (speed > 0.1 && totalSpinRadS > 1) {
                // Cross product: w × v (in ft/s coordinate system)
                const crossX = wy * vzFtS - wz * vyFtS;
                const crossY = wz * vxFtS - wx * vzFtS;
                const crossZ = wx * vyFtS - wy * vxFtS;

                // Lift coefficient: ClAmp * S^0.4 (from Excel column T)
                const S = totalSpinRadS / speed; // Spin parameter (omega/v)
                const ClAmp = 0.217; // From Excel G5
                const liftCoeff = ClAmp * Math.pow(S, 0.4);

                // Magnus formula: const * (liftCoeff/omega) * speed * (w × v)
                const magnusFactor = MAGNUS_CONST * (liftCoeff / totalSpinRadS) * speed;
                magnusAccelX = magnusFactor * crossX;
                magnusAccelY = magnusFactor * crossY;
                magnusAccelZ = magnusFactor * crossZ;

                // Debug on first frame
                if (ballPosition.y > 3 && ballPosition.y < 3.2) {
                    console.log(`Magnus debug: S=${S.toFixed(4)}, liftCoeff=${liftCoeff.toFixed(6)}, crossZ=${crossZ.toFixed(1)}, magnusFactor=${magnusFactor.toFixed(8)}, magnusZ=${magnusAccelZ.toFixed(2)} ft/s²`);
                }
            }

            // Total acceleration (ft/s²)
            const totalAccelX = dragAccelX + magnusAccelX;
            const totalAccelY = dragAccelY + magnusAccelY;
            const totalAccelZ = dragAccelZ + magnusAccelZ - GRAVITY; // Gravity acts downward

            // Debug on first frame
            if (ballPosition.y > 3 && ballPosition.y < 3.1 && ballPosition.z > -1) {
                console.log(`Position: (${ballPosition.x.toFixed(1)}, ${ballPosition.y.toFixed(1)}, ${ballPosition.z.toFixed(1)})`);
                console.log(`Velocity m/s: (${ballVelocity.x.toFixed(1)}, ${ballVelocity.y.toFixed(1)}, ${ballVelocity.z.toFixed(1)})`);
                console.log(`Drag accel ft/s²: (${dragAccelX.toFixed(2)}, ${dragAccelY.toFixed(2)}, ${dragAccelZ.toFixed(2)})`);
                console.log(`Magnus accel ft/s²: (${magnusAccelX.toFixed(2)}, ${magnusAccelY.toFixed(2)}, ${magnusAccelZ.toFixed(2)})`);
                console.log(`Total accel ft/s²: (${totalAccelX.toFixed(2)}, ${totalAccelY.toFixed(2)}, ${totalAccelZ.toFixed(2)})`);
            }

            // Update velocity (convert acceleration back to m/s²)
            // Excel coordinates: X=lateral, Y=forward, Z=vertical
            // THREE.js coordinates: X=lateral, Y=vertical, Z=forward (negative is forward)
            ballVelocity.x += (totalAccelX / 3.28084) * deltaTime;  // X to X (lateral)
            ballVelocity.z += -(totalAccelY / 3.28084) * deltaTime; // Y to -Z (forward, sign flip!)
            ballVelocity.y += (totalAccelZ / 3.28084) * deltaTime;  // Z to Y (vertical)

            // Spin decay (4% per second)
            ballSpin.totalSpin *= Math.exp(-deltaTime / 24.5);

            // Update position
            const movement = ballVelocity.clone().multiplyScalar(deltaTime);
            ballPosition.add(movement);

            // Track max height
            if (ballPosition.y > maxHeight) {
                maxHeight = ballPosition.y;
            }

            // Tree collision check
            checkTreeCollision();

            // Ground collision using raycasting
            const groundY = getGroundHeightRaycast(ballPosition.x, ballPosition.z);

            // Ground collision - only when descending (like home run derby)
            if (ballPosition.y - BALL_RADIUS <= groundY && ballVelocity.y < 0) {
                ballPosition.y = groundY + BALL_RADIUS;

                // Calculate carry distance on first landing
                if (!hasLanded) {
                    hasLanded = true;
                    landingPos.copy(ballPosition);

                    // Straight-line distance from tee to landing position
                    carryDistance = Math.sqrt(
                        Math.pow(landingPos.x - shotStartPos.x, 2) +
                        Math.pow(landingPos.z - shotStartPos.z, 2)
                    ) * 1.09361; // Convert meters to yards

                    document.getElementById('shotCarry').textContent = carryDistance.toFixed(1) + ' yds';
                }

                // Determine lie type
                currentLie = getLieType(ballPosition.x, ballPosition.z);

                // Bounce
                if (Math.abs(ballVelocity.y) > 0.5) {
                    ballVelocity.y = -ballVelocity.y * currentLie.bounceRetention;
                    // Reduce horizontal velocity to match expected roll distance
                    ballVelocity.x *= 0.55;
                    ballVelocity.z *= 0.55;
                } else {
                    ballVelocity.y = 0;

                    // Rolling friction - simple deceleration model
                    const horizontalSpeed = Math.sqrt(ballVelocity.x * ballVelocity.x + ballVelocity.z * ballVelocity.z);
                    if (horizontalSpeed > 0.05) {
                        // Simple friction: decelerate based on lie type
                        const frictionDecel = currentLie.friction * 8.0; // m/s² deceleration
                        const newSpeed = Math.max(0, horizontalSpeed - frictionDecel * deltaTime);
                        const scale = newSpeed / horizontalSpeed;

                        ballVelocity.x *= scale;
                        ballVelocity.z *= scale;
                        ballVelocity.y = 0; // Keep on ground
                    } else {
                        ballVelocity.x = 0;
                        ballVelocity.z = 0;
                        ballInFlight = false;

                        // Calculate new base direction (toward pin from current position)
                        const dx = PIN_POSITION.x - ballPosition.x;
                        const dz = PIN_POSITION.z - ballPosition.z;
                        baseDirection = Math.atan2(dx, -dz) * 180 / Math.PI;

                        // Reset aim adjustment to 0 (but keep base direction)
                        aimAdjustment = 0;
                        updateAimIndicator();
                        console.log(`Ball stopped - new base direction: ${baseDirection.toFixed(1)}°, aim reset to 0°`);

                        // Update total distance and rollout
                        const totalDist = Math.sqrt(
                            Math.pow(ballPosition.x - shotStartPos.x, 2) +
                            Math.pow(ballPosition.z - shotStartPos.z, 2)
                        ) * 1.09361;
                        document.getElementById('shotTotal').textContent = totalDist.toFixed(1) + ' yds';

                        // Calculate rollout (total - carry)
                        const rollDist = totalDist - carryDistance;
                        document.getElementById('shotRoll').textContent = rollDist.toFixed(1) + ' yds';

                        // Check if in hole
                        checkHole();
                    }
                }
            }

            ball.position.copy(ballPosition);
            updateUI();
        }

        function getGroundHeightRaycast(x, z) {
            // Cast a ray downward from high above the ball position
            const rayOrigin = new THREE.Vector3(x, 100, z);
            const rayDirection = new THREE.Vector3(0, -1, 0);

            raycaster.set(rayOrigin, rayDirection);

            // Check terrain, green, and teebox meshes
            const objectsToCheck = [terrain, green, teebox];
            const intersects = raycaster.intersectObjects(objectsToCheck, false);

            if (intersects.length > 0) {
                return intersects[0].point.y;
            }

            // Fallback to calculated height if no intersection
            // This happens when position is outside terrain bounds
            return getGroundHeight(x, z);
        }

        function getGroundHeight(x, z) {
            let height = 0;

            // Tee area (elevated)
            if (z > -10 && z < 10) {
                height = 3 - Math.abs(z) * 0.3;
            }
            // Slope from tee to fairway
            else if (z >= -30 && z <= -10) {
                height = 3 - (Math.abs(z) - 10) * 0.1;
            }
            // Fairway (slight downslope with natural undulations)
            else if (z > -110 && z <= -30) {
                height = 1 - ((Math.abs(z) - 30) / 80) * 1.5;

                // Natural undulations across the fairway
                height += Math.sin(x * 0.3 + z * 0.15) * 0.5;
                height += Math.cos(x * 0.5 - z * 0.2) * 0.4;
                height += Math.sin(x * 0.15 + z * 0.25) * 0.3;

                // Random-looking hills using multiple frequencies
                height += Math.sin(x * 0.7) * Math.cos(z * 0.1) * 0.35;
                height += Math.cos(x * 0.12 + z * 0.18) * 0.25;

                // Irregular mounds on the sides (rough areas)
                if (Math.abs(x) > 12) {
                    const distFromFairway = Math.abs(x) - 12;
                    // Create irregular mounding
                    height += Math.sin(z * 0.4 + x * 0.2) * distFromFairway * 0.15;
                    height += Math.cos(x * 0.6 - z * 0.15) * (distFromFairway * 0.1);
                    height += Math.sin(x * 0.9 + z * 0.3) * 0.6;

                    // Add some dramatic mounds in rough
                    const moundNoise = Math.sin(x * 1.2) * Math.cos(z * 0.35);
                    if (moundNoise > 0.3) {
                        height += moundNoise * 0.8;
                    }
                }
            }
            // Approach to green with protective mounding
            else if (z > -125 && z <= -110) {
                height = -0.2;

                // Greenside mounds (irregular and natural)
                const distToGreen = Math.sqrt(Math.pow(x, 2) + Math.pow(z + 118.872, 2));
                if (distToGreen > 10 && distToGreen < 16) {
                    // Create raised mounding around green with irregular pattern
                    const angle = Math.atan2(x, z + 118.872);
                    const moundIntensity = Math.sin(angle * 3.5) * 0.5 + 0.5; // Vary by position
                    height += Math.sin((distToGreen - 10) * 1.2) * 1.2 * moundIntensity;
                    height += Math.cos(angle * 2.3 + distToGreen) * 0.6;
                    height += Math.sin(x * 1.1) * Math.cos((z + 118.872) * 0.9) * 0.5;
                }

                // Natural undulations around green
                height += Math.sin(x * 0.5 + z * 0.3) * 0.3;
                height += Math.cos(x * 0.8 - z * 0.4) * 0.25;
            }
            // Green area (subtle undulation, not completely flat)
            else {
                const distToPin = Math.sqrt(Math.pow(x, 2) + Math.pow(z + 118.872, 2));

                if (distToPin < 10) {
                    // Green itself with very subtle breaks
                    height = -0.2 + Math.sin(x * 0.5) * 0.05 + Math.cos((z + 118.872) * 0.4) * 0.05;
                } else {
                    // Beyond green
                    height = -0.2;
                }
            }

            // Override for specific features
            // Tee box (flat platform)
            if (z > -4 && z < 4 && Math.abs(x) < 3) {
                return 3;
            }

            // Green (relatively flat)
            const distToGreen = Math.sqrt(
                Math.pow(x - PIN_POSITION.x, 2) +
                Math.pow(z - PIN_POSITION.z, 2)
            );
            if (distToGreen < 10) {
                return -0.15; // Slightly raised from calculation
            }

            // Bunkers (depressed)
            const distToLeftBunker = Math.sqrt(
                Math.pow(x - BUNKER_LEFT_POSITION.x, 2) +
                Math.pow(z - BUNKER_LEFT_POSITION.z, 2)
            );
            if (distToLeftBunker < 4) {
                return -0.3;
            }

            const distToRightBunker = Math.sqrt(
                Math.pow(x - BUNKER_RIGHT_POSITION.x, 2) +
                Math.pow(z - BUNKER_RIGHT_POSITION.z, 2)
            );
            if (distToRightBunker < 3.5) {
                return -0.3;
            }

            return height;
        }

        function getLieType(x, z) {
            // Check tee
            if (z > -4 && z < 4 && Math.abs(x) < 3) {
                return LIE_TYPES.TEE;
            }

            // Check green
            const distToGreen = Math.sqrt(
                Math.pow(x - PIN_POSITION.x, 2) +
                Math.pow(z - PIN_POSITION.z, 2)
            );
            if (distToGreen < 10) {
                return LIE_TYPES.GREEN;
            }

            // Check left bunker
            const distToLeftBunker = Math.sqrt(
                Math.pow(x - BUNKER_LEFT_POSITION.x, 2) +
                Math.pow(z - BUNKER_LEFT_POSITION.z, 2)
            );
            if (distToLeftBunker < 4) {
                return LIE_TYPES.BUNKER;
            }

            // Check right bunker
            const distToRightBunker = Math.sqrt(
                Math.pow(x - BUNKER_RIGHT_POSITION.x, 2) +
                Math.pow(z - BUNKER_RIGHT_POSITION.z, 2)
            );
            if (distToRightBunker < 3.5) {
                return LIE_TYPES.BUNKER;
            }

            // Check fairway vs rough
            if (Math.abs(x) < 12) {
                return LIE_TYPES.FAIRWAY; // Center corridor
            } else if (Math.abs(x) >= 12 && Math.abs(x) < 20) {
                return LIE_TYPES.LIGHT_ROUGH; // First cut
            } else {
                return LIE_TYPES.HEAVY_ROUGH; // Deep rough
            }
        }

        function checkTreeCollision() {
            for (let tree of trees) {
                // Check horizontal distance to tree
                const dx = ballPosition.x - tree.position.x;
                const dz = ballPosition.z - tree.position.z;
                const horizontalDist = Math.sqrt(dx * dx + dz * dz);

                // Check if ball is within tree collision radius and height
                if (horizontalDist < tree.radius + BALL_RADIUS &&
                    ballPosition.y >= tree.position.y &&
                    ballPosition.y <= tree.position.y + tree.height) {

                    // Ball hit tree - bounce off
                    const normal = new THREE.Vector2(dx, dz).normalize();

                    // Reflect velocity
                    const dot = ballVelocity.x * normal.x + ballVelocity.z * normal.y;
                    ballVelocity.x = (ballVelocity.x - 2 * dot * normal.x) * 0.5; // 50% energy loss
                    ballVelocity.z = (ballVelocity.z - 2 * dot * normal.y) * 0.5;
                    ballVelocity.y *= 0.7; // Reduce vertical velocity

                    // Push ball outside collision radius
                    const pushDist = tree.radius + BALL_RADIUS - horizontalDist;
                    ballPosition.x += normal.x * pushDist;
                    ballPosition.z += normal.y * pushDist;

                    console.log('Ball hit tree!');
                    break;
                }
            }
        }

        function checkHole() {
            const distToCup = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );

            if (distToCup < 0.054) { // Cup radius
                alert(`Hole in ${strokes}! ${strokes === 1 ? 'ACE!' : strokes === 3 ? 'Par' : strokes < 3 ? 'Birdie!' : 'Bogey'}`);
                setTimeout(resetHole, 2000);
            }
        }

        function updateUI() {
            const distToPinM = Math.sqrt(
                Math.pow(ballPosition.x - PIN_POSITION.x, 2) +
                Math.pow(ballPosition.z - PIN_POSITION.z, 2)
            );
            const distToPinYards = distToPinM * 1.09361;

            document.getElementById('distanceToPin').textContent = Math.round(distToPinYards) + ' yds';
            document.getElementById('lieType').textContent = currentLie.name;
            document.getElementById('strokes').textContent = strokes;
        }

        function resetHole() {
            strokes = 0;
            ballInFlight = false;
            resetBallPosition();
            document.getElementById('shotDetails').style.display = 'none';
        }

        function updateCameraPosition(autoRevert = true) {
            // Skip automatic camera if in debug mode
            if (debugMode) {
                console.log('Debug mode active, skipping camera update');
                return;
            }

            console.log(`updateCameraPosition called: view=${currentView}, autoRevert=${autoRevert}, ballInFlight=${ballInFlight}`);

            switch (currentView) {
                case 'behind-ball':
                    // Behind ball view that rotates with aim adjustment from base direction
                    const totalAim = baseDirection + aimAdjustment;
                    const aimRad = -totalAim * Math.PI / 180; // Negative to fix rotation direction
                    const distance = 3;
                    const height = 1.7;

                    // Calculate camera position behind ball based on aim
                    const camX = ballPosition.x + distance * Math.sin(aimRad);
                    const camZ = ballPosition.z + distance * Math.cos(aimRad);

                    camera.position.set(camX, ballPosition.y + height, camZ);

                    // Look in the direction of aim
                    const lookX = ballPosition.x - distance * Math.sin(aimRad);
                    const lookZ = ballPosition.z - distance * Math.cos(aimRad);
                    camera.lookAt(lookX, ballPosition.y, lookZ);
                    break;

                case 'tee-box':
                    // Behind ball view at eye level (like standing on tee box)
                    camera.position.set(
                        ballPosition.x,
                        ballPosition.y + 1.7,  // Eye level height (~5'7")
                        ballPosition.z + 3     // Close behind ball
                    );
                    camera.lookAt(PIN_POSITION.x, PIN_POSITION.y, PIN_POSITION.z);
                    break;

                case 'auto-follow':
                case 'follow':
                    if (ballInFlight) {
                        // Follow ball during flight
                        camera.position.set(
                            ballPosition.x - 8,
                            ballPosition.y + 6,
                            ballPosition.z + 12
                        );
                        camera.lookAt(ballPosition);
                    } else {
                        // No ball in flight - show overview
                        camera.position.set(0, 25, -60);
                        camera.lookAt(0, 0, -60);
                    }
                    break;

                case 'green':
                    // Green-side view looking back at fairway
                    camera.position.set(
                        PIN_POSITION.x,
                        2,
                        PIN_POSITION.z - 15
                    );
                    camera.lookAt(PIN_POSITION.x, 0, PIN_POSITION.z + 20);
                    break;

                case 'overhead':
                    // Bird's eye view of entire hole
                    camera.position.set(0, 80, -60);
                    camera.lookAt(0, 0, -60);
                    break;

                case 'drone':
                    // Elevated side view
                    camera.position.set(-40, 35, -60);
                    camera.lookAt(0, 0, -60);
                    break;
            }
        }

        function cycleView() {
            const views = ['behind-ball', 'tee-box', 'auto-follow', 'follow', 'green', 'overhead', 'drone'];
            const currentIndex = views.indexOf(currentView);
            const previousView = currentView;
            currentView = views[(currentIndex + 1) % views.length];

            console.log(`Camera view changed: ${previousView} -> ${currentView}`);

            // Save the view in case auto-follow needs to revert
            if (currentView !== 'auto-follow') {
                savedView = currentView;
            }

            // Don't auto-revert when manually cycling views
            updateCameraPosition(false);

            // Show camera view notification
            const viewNames = {
                'behind-ball': 'Behind Ball (Aim)',
                'tee-box': 'Tee Box View',
                'auto-follow': 'Auto Follow',
                'follow': 'Manual Follow',
                'green': 'Green View',
                'overhead': 'Overhead',
                'drone': 'Drone View'
            };
            showNotification(`Camera: ${viewNames[currentView]}`);
        }

        function showNotification(message) {
            // Remove existing notification if any
            const existing = document.getElementById('cameraNotification');
            if (existing) {
                existing.remove();
            }

            // Create notification
            const notification = document.createElement('div');
            notification.id = 'cameraNotification';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                pointer-events: none;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Fade out and remove
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updateCamera() {
            // Only update camera for views that need continuous updates
            if (currentView === 'auto-follow' || currentView === 'follow' || currentView === 'tee-box' || currentView === 'behind-ball') {
                updateCameraPosition(true);
            }
            // Other views (green, overhead, drone) are static and don't need frame updates
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updateBallPhysics(deltaTime);
            updateTracer();
            updateCamera();

            renderer.render(scene, camera);
        }

        function setupDemoShotControls() {
            // Update displayed values when sliders change
            document.getElementById('demoSpeed').addEventListener('input', (e) => {
                document.getElementById('demoSpeedVal').textContent = e.target.value + ' mph';
            });
            document.getElementById('demoVLA').addEventListener('input', (e) => {
                document.getElementById('demoVLAVal').textContent = e.target.value + '°';
            });
            document.getElementById('demoHLA').addEventListener('input', (e) => {
                document.getElementById('demoHLAVal').textContent = e.target.value + '°';
            });
            document.getElementById('demoTotalSpin').addEventListener('input', (e) => {
                document.getElementById('demoTotalSpinVal').textContent = e.target.value + ' rpm';
            });
            document.getElementById('demoSpinAxis').addEventListener('input', (e) => {
                document.getElementById('demoSpinAxisVal').textContent = e.target.value + '°';
            });
        }

        function toggleGrid() {
            showGrid = !showGrid;

            if (showGrid) {
                createGrid();
            } else {
                if (gridLines) {
                    scene.remove(gridLines);
                    gridLines = null;
                }
            }
        }

        function updateAimIndicator() {
            const display = document.getElementById('aimDisplay');
            display.textContent = aimAdjustment + '°';

            // Color code the display
            if (aimAdjustment === 0) {
                display.style.color = '#FFD700'; // Gold for straight
            } else if (aimAdjustment < 0) {
                display.style.color = '#4AF'; // Blue for left
            } else {
                display.style.color = '#F84'; // Orange for right
            }
        }

        function createGrid() {
            // Remove existing grid if any
            if (gridLines) {
                scene.remove(gridLines);
            }

            const group = new THREE.Group();

            // Grid on fairway (center section)
            const fairwayGrid = new THREE.GridHelper(50, 25, 0x888888, 0x444444);
            fairwayGrid.position.y = 0.05; // Slightly above terrain
            fairwayGrid.position.z = -60; // Center of fairway
            group.add(fairwayGrid);

            // Grid on green
            const greenGrid = new THREE.GridHelper(20, 20, 0x88FF88, 0x44AA44);
            greenGrid.position.y = -0.1; // On green surface
            greenGrid.position.z = PIN_POSITION.z;
            group.add(greenGrid);

            // Grid on tee box
            const teeGrid = new THREE.GridHelper(8, 8, 0xFFFFFF, 0xCCCCCC);
            teeGrid.position.y = 3.05; // On tee box surface
            teeGrid.position.z = 0;
            group.add(teeGrid);

            gridLines = group;
            scene.add(gridLines);

            console.log('Grid enabled');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home Run Derby</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        
        #canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            opacity: 0.5;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
            text-align: center;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        #controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            flex: 1;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        #controls button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        #controls button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }

        .stat-section.collapsed {
            max-height: 0 !important;
            padding: 0 10px;
            margin: 0;
            opacity: 0;
        }

        .collapse-toggle {
            background: rgba(76, 175, 80, 0.3) !important;
            border: 2px solid #4CAF50 !important;
            padding: 6px 10px !important;
            margin-bottom: 8px;
            font-size: 12px !important;
            width: 100%;
            text-align: center;
        }

        .collapse-toggle:hover {
            background: rgba(76, 175, 80, 0.5) !important;
        }
        
        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #fff;
            font-weight: bold;
            font-size: 13px;
        }
        
        .club-display {
            color: #4CAF50;
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }
        
        #liveIndicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #f44336;
            border-radius: 50%;
            margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        #liveIndicator.connected {
            background: #4CAF50;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        
        #minimap {
            display: none; /* Hidden */
        }

        .distance-marker {
            position: absolute;
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #shotTrajectory {
            display: none; /* Hidden */
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="hud" style="display: none;">
        <svg id="crosshair" viewBox="0 0 40 40">
            <circle cx="20" cy="20" r="18" fill="none" stroke="white" stroke-width="1"/>
            <line x1="20" y1="5" x2="20" y2="15" stroke="white" stroke-width="1"/>
            <line x1="20" y1="25" x2="20" y2="35" stroke="white" stroke-width="1"/>
            <line x1="5" y1="20" x2="15" y2="20" stroke="white" stroke-width="1"/>
            <line x1="25" y1="20" x2="35" y2="20" stroke="white" stroke-width="1"/>
        </svg>
    </div>
    
    
    <div id="controls">
        <div id="playerIndicator" style="background: rgba(251, 191, 36, 0.3); padding: 8px; border-radius: 4px; margin-bottom: 10px; text-align: center; border: 2px solid #fbbf24;">
            <strong style="color: #fbbf24; font-size: 11px;">Current Player:</strong>
            <div id="currentPlayerName" style="font-size: 15px; margin-top: 3px; font-weight: bold;">Player 1</div>
        </div>

        <!-- Mode Toggle (Collapseable) -->
        <button class="collapse-toggle" onclick="toggleSection('modeSection')">
            ðŸŽ® Game Modes <span id="modeSectionArrow">â–¼</span>
        </button>
        <div id="modeSection" style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px;">
            <button id="practiceModeBtn" onclick="setPracticeMode()" style="width: 100%; background: #4CAF50;">Practice</button>
            <button id="derbyModeBtn" onclick="setDerbyMode()" style="width: 100%; background: rgba(76, 175, 80, 0.3);">Derby</button>
            <button id="baseballModeBtn" onclick="setBaseballMode()" style="width: 100%; background: rgba(76, 175, 80, 0.3);">Baseball</button>
        </div>

        <!-- Derby Stats (hidden by default) -->
        <div id="derbyStats" class="stat-section" style="display: none; background: rgba(220, 38, 38, 0.1); border: 2px solid #dc2626;">
            <h4 style="color: #dc2626; margin-bottom: 8px; text-align: center; font-size: 14px;">âš¾ Derby Stats</h4>
            <div class="stat-row">
                <span class="stat-label">Strikes:</span>
                <span class="stat-value" style="color: #dc2626; font-size: 16px;" id="derbyStrikes">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Home Runs:</span>
                <span class="stat-value" style="color: #4CAF50;" id="derbyHomeRuns">0</span>
            </div>
            <div class="stat-row" style="flex-direction: column; align-items: flex-start;">
                <span class="stat-label" style="margin-bottom: 5px;">Longest Drive:</span>
                <span class="stat-value" style="color: #FFD700; font-size: 14px;" id="derbyLongestDrive">0 yds</span>
                <span style="color: #aaa; font-size: 12px; margin-top: 2px;" id="derbyLongestDrivePlayer">None</span>
            </div>
        </div>

        <!-- Baseball Stats (hidden by default) -->
        <div id="baseballStats" class="stat-section" style="display: none; background: rgba(37, 99, 235, 0.1); border: 2px solid #2563eb;">
            <h4 style="color: #2563eb; margin-bottom: 8px; text-align: center; font-size: 14px;">âš¾ Baseball Game</h4>
            <div class="stat-row">
                <span class="stat-label">Inning:</span>
                <span class="stat-value" style="color: #2563eb;" id="baseballInning">Top 1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Outs:</span>
                <span class="stat-value" style="color: #dc2626;" id="baseballOuts">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Score:</span>
                <span class="stat-value" style="color: #4CAF50;" id="baseballScore">Away 0 - Home 0</span>
            </div>
            <div style="margin-top: 10px; text-align: center;">
                <div style="color: #aaa; font-size: 10px; margin-bottom: 5px;">Bases:</div>
                <div style="position: relative; width: 60px; height: 60px; margin: 0 auto;">
                    <!-- Second Base (top) -->
                    <div id="base2" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%) rotate(45deg); width: 15px; height: 15px; background: #333; border: 1px solid #666;">
                    </div>
                    <!-- Third Base (left) -->
                    <div id="base3" style="position: absolute; top: 50%; left: 0; transform: translateY(-50%) rotate(45deg); width: 15px; height: 15px; background: #333; border: 1px solid #666;">
                    </div>
                    <!-- First Base (right) -->
                    <div id="base1" style="position: absolute; top: 50%; right: 0; transform: translateY(-50%) rotate(45deg); width: 15px; height: 15px; background: #333; border: 1px solid #666;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Utility Controls (Collapseable) -->
        <button class="collapse-toggle" onclick="toggleSection('utilitySection')">
            ðŸ”§ Controls <span id="utilitySectionArrow">â–¼</span>
        </button>
        <div id="utilitySection" style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px;">
            <button id="connectBtn" style="width: 100%;">Connect Live</button>
            <button id="viewBtn" onclick="cycleView()" style="width: 100%;">Change View</button>
            <button id="nextPlayerBtn" onclick="nextPlayer()" style="width: 100%; background: rgba(251, 191, 36, 0.3); border-color: #fbbf24;">Next Player â†’</button>
            <button onclick="exportSessionCSV()" style="width: 100%; background: rgba(34, 197, 94, 0.3); border-color: #22c55e;">ðŸ“Š Export CSV</button>
        </div>

        <!-- New Game Button (hidden by default) -->
        <div class="button-group" id="newGameSection" style="display: none;">
            <button onclick="restartGame()" style="background: #dc2626; font-size: 14px; padding: 10px;">ðŸŽ® New Game</button>
        </div>

        <!-- DEBUG PANEL - Hidden by default, controlled by DEBUG_MODE constant in script -->
        <div id="debugSection" style="display: none;">
            <button class="collapse-toggle" onclick="toggleDebugPanel()" style="background: rgba(255, 152, 0, 0.3) !important; border-color: #ff9800 !important;">
                <span id="debugIcon">â–¼</span> Debug Test Shot
            </button>

            <div id="debugPanel" class="stat-section">
            <div class="stat-row">
                <span class="stat-label">Ball Speed (mph):</span>
                <input type="number" id="debugSpeed" value="155" style="width: 80px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
            </div>
            <div class="stat-row">
                <span class="stat-label">Launch Angle (Â°):</span>
                <input type="number" id="debugVLA" value="12" step="0.1" style="width: 80px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
            </div>
            <div class="stat-row">
                <span class="stat-label">Side Angle (Â°):</span>
                <input type="number" id="debugHLA" value="0" step="0.1" style="width: 80px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
            </div>
            <div class="stat-row">
                <span class="stat-label">Back Spin (rpm):</span>
                <input type="number" id="debugBackSpin" value="2850" style="width: 80px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
            </div>
            <div class="stat-row">
                <span class="stat-label">Side Spin (rpm):</span>
                <input type="number" id="debugSideSpin" value="0" style="width: 80px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px;">
            </div>
            <button onclick="launchDebugShot()" style="width: 100%; margin-top: 10px; background: #ff9800 !important;">
                ðŸš€ Launch Test Shot
            </button>
            </div>
        </div>
        <!-- END DEBUG PANEL -->

        <button class="collapse-toggle" onclick="toggleStats()">
            <span id="collapseIcon">â–¼</span> Shot Details
        </button>

        <div id="shotInfo" class="stat-section">
            <div class="club-display" id="clubType">Driver</div>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="ballSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Launch Angle:</span>
                <span class="stat-value" id="launchAngle">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Side Angle:</span>
                <span class="stat-value" id="sideAngle">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Back Spin:</span>
                <span class="stat-value" id="backSpin">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Side Spin:</span>
                <span class="stat-value" id="sideSpin">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Spin:</span>
                <span class="stat-value" id="totalSpin">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Spin Axis:</span>
                <span class="stat-value" id="spinAxisTilt">--</span>
            </div>
        </div>
        
        <div id="resultInfo" class="stat-section" style="display: none;">
            <div class="stat-row">
                <span class="stat-label">Carry Distance:</span>
                <span class="stat-value" id="carryDistance">0</span> yds
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Distance:</span>
                <span class="stat-value" id="totalDistance">0</span> yds
            </div>
            <div class="stat-row">
                <span class="stat-label">Apex Height:</span>
                <span class="stat-value" id="apexHeight">0</span> ft
            </div>
            <div class="stat-row">
                <span class="stat-label">Flight Time:</span>
                <span class="stat-value" id="flightTime">0</span> sec
            </div>
        </div>
    </div>
    
    <canvas id="minimap"></canvas>
    <canvas id="shotTrajectory"></canvas>
    <script src="./three.min.js"></script>
    <script>
        // ==========================================
        // DEBUG MODE - Set to true to enable debug test shot panel
        // ==========================================
        const DEBUG_MODE = false; // Change to 'true' to show debug controls

        // Global variables
        let scene, camera, renderer;
        let balls = [];
        let sessionShots = []; // Track all shots for CSV export
        let isLiveMode = false;
        let currentView = 'first-person'; // 'first-person', 'auto-follow', 'follow', 'overhead'
        let savedView = 'first-person'; // Store the view before auto-follow
        let ws = null;
        let messageCount = 0;

        // Environmental conditions
        let wind = { speed: 5, direction: 45 }; // mph and degrees
        let temperature = 72; // Fahrenheit
        let humidity = 65; // Percentage

        // Derby Mode variables
        let isDerbyMode = false;
        let derbyStrikes = 0;
        let derbyHomeRuns = 0;
        let derbyGameOver = false;
        let derbyLongestDrive = { distance: 0, playerName: 'None' }; // Track longest drive with player name
        const MAX_STRIKES = 10;

        // Baseball Mode variables
        let isBaseballMode = false;
        let baseballGame = {
            inning: 1,
            topOfInning: true,  // true = away batting, false = home batting
            outs: 0,
            score: { away: 0, home: 0 },
            bases: { first: null, second: null, third: null },  // null = empty, or player name
            atBat: 'Away Team',
            gameOver: false
        };

        // Helper function to convert number to ordinal (1st, 2nd, 3rd, etc.)
        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }
        
        // Demo shot data
        const demoShots = [
            {speed: 155.5, vla: 12.5, hla: -2.3, backSpin: 2850, sideSpin: -320, totalSpin: 2868, spinAxis: 6.4, club: "DR"},
            {speed: 148.2, vla: 14.2, hla: 1.8, backSpin: 3200, sideSpin: 150, totalSpin: 3203, spinAxis: 2.7, club: "DR"},
            {speed: 135.6, vla: 16.8, hla: -4.5, backSpin: 4500, sideSpin: -650, totalSpin: 4547, spinAxis: 8.2, club: "I5"},
            {speed: 125.3, vla: 19.2, hla: 0.5, backSpin: 5800, sideSpin: 80, totalSpin: 5801, spinAxis: 0.8, club: "I7"},
            {speed: 95.8, vla: 25.5, hla: -1.2, backSpin: 7200, sideSpin: -180, totalSpin: 7202, spinAxis: 1.4, club: "PW"}
        ];

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();

            // Urban sky with city atmosphere
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 0, 256);
            gradient.addColorStop(0, '#4A90E2');      // Bright blue at top
            gradient.addColorStop(0.4, '#87CEEB');    // Sky blue
            gradient.addColorStop(0.7, '#B8D4E8');    // Lighter blue
            gradient.addColorStop(1, '#E8F4F8');      // Almost white at horizon
            context.fillStyle = gradient;
            context.fillRect(0, 0, 1, 256);

            const skyTexture = new THREE.CanvasTexture(canvas);
            scene.background = skyTexture;
            scene.fog = new THREE.Fog(0xB8D4E8, 200, 800); // Closer fog for urban feel

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                2000
            );
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Enhanced lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xFDB813, 1.2);
            sunLight.position.set(100, 150, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -500;
            sunLight.shadow.camera.right = 500;
            sunLight.shadow.camera.top = 500;
            sunLight.shadow.camera.bottom = -500;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1500;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Create detailed environment
            createEnvironment();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            // Setup IPC connection (if running in Electron)
            if (window.electronAPI) {
                console.log('âœ“ Running in Electron - IPC available');
                setupElectronIPC();
                // Hide connect button since connection is automatic
                document.getElementById('connectBtn').style.display = 'none';
            } else {
                console.log('âš  Not running in Electron - WebSocket fallback');
                document.getElementById('connectBtn').addEventListener('click', toggleLiveMode);
            }
            document.getElementById('viewBtn').addEventListener('click', cycleView);
            
            // Update weather display
            updateWeatherDisplay();
            
            // Start minimap and trajectory canvas
            initMinimap();
            initTrajectoryDisplay();

            // Update connection status
            updateConnectionStatus('Disconnected', 'Ready to connect');
        }

        function createEnvironment() {
            // Baseball field dimensions in feet, converted to meters (1 foot = 0.3048 meters)
            const dimensions = {
                left: 325 * 0.3048,           // 99.06 meters
                leftCenter: 370 * 0.3048,     // 112.78 meters
                center: 405 * 0.3048,         // 123.44 meters
                rightCenter: 375 * 0.3048,    // 114.30 meters
                right: 325 * 0.3048           // 99.06 meters
            };

            // Detailed grass texture
            const grassTexture = createGrassTexture();
            const grassMaterial = new THREE.MeshLambertMaterial({
                map: grassTexture,
                color: 0x2a5a2a // Darker green for baseball field
            });

            // Outfield grass (large circular area)
            const outfieldGeometry = new THREE.CircleGeometry(150, 64);
            const outfield = new THREE.Mesh(outfieldGeometry, grassMaterial);
            outfield.rotation.x = -Math.PI / 2;
            outfield.receiveShadow = true;
            scene.add(outfield);

            // Infield dirt - proper baseball diamond shape
            // Create a square rotated 45 degrees for the infield dirt
            const dirtMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });

            // Dirt area extends beyond the basepaths
            const dirtSize = 90; // Covers the 90-foot diamond plus extra
            const dirtShape = new THREE.Shape();

            // Create diamond shape for infield dirt
            const dirtRadius = 50; // Larger radius to encompass all bases
            dirtShape.moveTo(0, dirtRadius); // Home plate direction
            dirtShape.lineTo(dirtRadius, 0); // First base direction
            dirtShape.lineTo(0, -dirtRadius); // Second base direction
            dirtShape.lineTo(-dirtRadius, 0); // Third base direction
            dirtShape.lineTo(0, dirtRadius); // Back to home

            const dirtGeometry = new THREE.ShapeGeometry(dirtShape);
            const infield = new THREE.Mesh(dirtGeometry, dirtMaterial);
            infield.rotation.x = -Math.PI / 2;
            infield.rotation.z = Math.PI / 4; // Rotate 45 degrees to align with bases
            infield.position.y = 0.01;
            infield.receiveShadow = true;
            scene.add(infield);

            // Home plate
            createHomePlate();

            // Pitcher's mound
            createPitchersMound();

            // Base paths
            createBasePaths();

            // Foul lines
            createFoulLines();

            // Outfield walls with proper dimensions
            createOutfieldWalls(dimensions);

            // Seating
            createSeating();

            // Scoreboard
            createScoreboard();

            // City skyline (distant)
            createCitySkyline();

            // Stadium lights
            createStadiumLights();

            // Outfield advertisements
            // Ads integrated into wall geometry below
        }

        function createHomePlate() {
            // Home plate pentagonal shape
            const plateShape = new THREE.Shape();
            plateShape.moveTo(0, 0);
            plateShape.lineTo(0.215, 0.215);
            plateShape.lineTo(0, 0.43);
            plateShape.lineTo(-0.215, 0.215);
            plateShape.lineTo(0, 0);

            const plateGeometry = new THREE.ShapeGeometry(plateShape);
            const plateMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.2
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.rotation.x = -Math.PI / 2;
            plate.position.set(0, 0.02, 0);
            scene.add(plate);
        }

        function createPitchersMound() {
            // Pitcher's mound - MLB spec: 60 feet 6 inches = 60.5 feet = 18.44 meters from home plate
            const moundDistance = 18.44;
            const moundGeometry = new THREE.CylinderGeometry(2.74, 2.74, 0.3, 32);
            const moundMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
            const mound = new THREE.Mesh(moundGeometry, moundMaterial);
            mound.position.set(0, 0.15, -moundDistance);
            mound.castShadow = true;
            mound.receiveShadow = true;
            scene.add(mound);

            // Pitcher's rubber
            const rubberGeometry = new THREE.BoxGeometry(0.6, 0.05, 0.15);
            const rubberMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const rubber = new THREE.Mesh(rubberGeometry, rubberMaterial);
            rubber.position.set(0, 0.32, -moundDistance);
            scene.add(rubber);
        }

        function createBasePaths() {
            // MLB Official Rules:
            // - 90-foot square between bases
            // - Home to second base: 127 feet, 3-3/8 inches = 127.28125 feet = 38.795 meters
            // - This creates a perfect 45-degree diamond

            const baseDist = 27.432; // 90 feet exactly in meters
            const homeToSecond = 38.795; // 127'3-3/8" in meters

            const baseGeometry = new THREE.BoxGeometry(0.38, 0.1, 0.38);
            const baseMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.2
            });

            // First base - 90 feet down first base line (45 degrees from home)
            const firstBase = new THREE.Mesh(baseGeometry, baseMaterial);
            firstBase.position.set(baseDist, 0.05, -baseDist);
            firstBase.castShadow = true;
            scene.add(firstBase);

            // Second base - 127'3-3/8" from home plate (straight out from home)
            const secondBase = new THREE.Mesh(baseGeometry, baseMaterial);
            secondBase.position.set(0, 0.05, -homeToSecond);
            secondBase.castShadow = true;
            scene.add(secondBase);

            // Third base - 90 feet down third base line (45 degrees from home)
            const thirdBase = new THREE.Mesh(baseGeometry, baseMaterial);
            thirdBase.position.set(-baseDist, 0.05, -baseDist);
            thirdBase.castShadow = true;
            scene.add(thirdBase);
        }

        function createFoulLines() {
            const foulLineMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.3
            });

            // Left foul line
            const leftLineGeometry = new THREE.PlaneGeometry(0.2, 120);
            const leftLine = new THREE.Mesh(leftLineGeometry, foulLineMaterial);
            leftLine.rotation.x = -Math.PI / 2;
            leftLine.rotation.z = Math.PI / 4;
            leftLine.position.set(-42.4, 0.02, -42.4);
            scene.add(leftLine);

            // Right foul line
            const rightLineGeometry = new THREE.PlaneGeometry(0.2, 120);
            const rightLine = new THREE.Mesh(rightLineGeometry, foulLineMaterial);
            rightLine.rotation.x = -Math.PI / 2;
            rightLine.rotation.z = -Math.PI / 4;
            rightLine.position.set(42.4, 0.02, -42.4);
            scene.add(rightLine);
        }

        function createOutfieldWalls(dimensions) {
            // Wall heights in meters
            const littleGreenMonsterHeight = 19 * 0.3048;  // 5.79 meters
            const standardWallHeight = 9 * 0.3048;         // 2.74 meters

            // Create smooth curved wall using many small segments
            // This creates a continuous arc from left foul line to right foul line
            const wallMaterial = new THREE.MeshLambertMaterial({
                color: 0x2d5016, // Dark hunter green
                emissive: 0x1a3010,
                emissiveIntensity: 0.1,
                side: THREE.DoubleSide
            });

            // Key distance points for the wall
            const keyPoints = [
                { angle: 45, distance: dimensions.left, height: littleGreenMonsterHeight },      // Left field (325')
                { angle: 22.5, distance: dimensions.leftCenter, height: standardWallHeight },    // Left-Center (370')
                { angle: 0, distance: dimensions.center, height: standardWallHeight },           // Center (405')
                { angle: -22.5, distance: dimensions.rightCenter, height: standardWallHeight },  // Right-Center (375')
                { angle: -45, distance: dimensions.right, height: standardWallHeight }           // Right field (325')
            ];

            // Create smooth curve with many segments
            const curveSegments = 64; // More segments = smoother curve
            const points = [];

            for (let i = 0; i <= curveSegments; i++) {
                const t = i / curveSegments;
                const angle = 45 - (t * 90); // From 45Â° to -45Â°
                const angleRad = angle * Math.PI / 180;

                // Interpolate distance based on angle
                let distance, height;

                if (angle >= 22.5) {
                    // Between left field and left-center
                    const localT = (angle - 22.5) / 22.5;
                    distance = dimensions.left + (dimensions.leftCenter - dimensions.left) * (1 - localT);
                    height = littleGreenMonsterHeight + (standardWallHeight - littleGreenMonsterHeight) * (1 - localT);
                } else if (angle >= 0) {
                    // Between left-center and center
                    const localT = angle / 22.5;
                    distance = dimensions.leftCenter + (dimensions.center - dimensions.leftCenter) * (1 - localT);
                    height = standardWallHeight;
                } else if (angle >= -22.5) {
                    // Between center and right-center
                    const localT = (angle + 22.5) / 22.5;
                    distance = dimensions.center + (dimensions.rightCenter - dimensions.center) * (1 - localT);
                    height = standardWallHeight;
                } else {
                    // Between right-center and right field
                    const localT = (angle + 45) / 22.5;
                    distance = dimensions.rightCenter + (dimensions.right - dimensions.rightCenter) * (1 - localT);
                    height = standardWallHeight;
                }

                const x = Math.sin(angleRad) * distance;
                const z = -Math.cos(angleRad) * distance;

                points.push(new THREE.Vector3(x, 0, z));
                points.push(new THREE.Vector3(x, height, z));
            }

            // Create the wall geometry from the curve
            const wallGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const indices = [];

            for (let i = 0; i < curveSegments; i++) {
                const base = i * 2;
                // Create two triangles for each segment
                indices.push(base, base + 1, base + 2);
                indices.push(base + 1, base + 3, base + 2);
            }

            wallGeometry.setIndex(indices);
            wallGeometry.computeVertexNormals();

            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);

            // Add distance markers at key points
            const distanceMarkers = [
                { angle: 45, distance: dimensions.left, label: '325', height: littleGreenMonsterHeight },
                { angle: 22.5, distance: dimensions.leftCenter, label: '370', height: standardWallHeight },
                { angle: 0, distance: dimensions.center, label: '405', height: standardWallHeight },
                { angle: -22.5, distance: dimensions.rightCenter, label: '375', height: standardWallHeight },
                { angle: -45, distance: dimensions.right, label: '325', height: standardWallHeight }
            ];

            distanceMarkers.forEach(marker => {
                const angleRad = marker.angle * Math.PI / 180;
                const x = Math.sin(angleRad) * marker.distance;
                const z = -Math.cos(angleRad) * marker.distance;
                createDistanceMarker(marker.label, x, marker.height, z, angleRad);
            });

            // Add advertisements painted directly on the wall
            const ads = [
                { text: 'NOVA', angle: 0, yPos: 8 }
            ];

            ads.forEach(ad => {
                createWallAd(ad.text, ad.angle, ad.yPos, dimensions);
            });
        }

        function updateNovaBillboard(playerName) {
            // Update the NOVA billboard with current player name
            const canvas = window.novaBillboardCanvas;
            const ctx = canvas ? canvas.getContext('2d') : null;
            if (!ctx) return;

            // Blue gradient background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, 256);
            bgGradient.addColorStop(0, '#143787');
            bgGradient.addColorStop(1, '#1459F7');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, 1024, 256);

            // Load and draw the Nova logo image
            const img = new Image();
            img.src = 'Nova_byOpenLaunch.png';

            img.onload = function() {
                // Calculate scaling to fit within billboard with padding
                const padding = 40;
                const maxWidth = 1024 - (padding * 2);
                const maxHeight = 150; // Leave room for player name

                let scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;

                // Center the image at top
                const x = (1024 - scaledWidth) / 2;
                const y = 20;

                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);

                // Draw player name below logo
                if (playerName) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 4;
                    ctx.fillText(playerName, 512, 240);
                }

                if (window.novaBillboardTexture) {
                    window.novaBillboardTexture.needsUpdate = true;
                }
            };

            // If image already loaded, draw immediately
            if (img.complete) {
                img.onload();
            }
        }

        function createWallAd(text, angle, yPos, dimensions) {
            // Create billboard on support poles like the scoreboard
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Store canvas and texture globally for updates
            window.novaBillboardCanvas = canvas;

            // Blue gradient background
            const bgGradient = ctx.createLinearGradient(0, 0, 0, 256);
            bgGradient.addColorStop(0, '#143787');    // Dark blue at top
            bgGradient.addColorStop(1, '#1459F7');    // Bright blue at bottom

            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, 1024, 256);

            // Load and draw the Nova logo image
            const img = new Image();
            img.src = 'Nova_byOpenLaunch.png';

            const texture = new THREE.CanvasTexture(canvas);
            window.novaBillboardTexture = texture;

            img.onload = function() {
                // Calculate scaling to fit within billboard with padding
                const padding = 40;
                const maxWidth = 1024 - (padding * 2);
                const maxHeight = 256 - (padding * 2);

                let scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;

                // Center the image
                const x = (1024 - scaledWidth) / 2;
                const y = (256 - scaledHeight) / 2;

                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                texture.needsUpdate = true;
            };

            const material = new THREE.MeshLambertMaterial({
                map: texture,
                side: THREE.DoubleSide
            });

            const width = text === 'SHANKUARY GOLF' ? 40 : (text === 'NOVA' ? 25 : 25);
            const height = 7;
            const geometry = new THREE.PlaneGeometry(width, height);
            const billboard = new THREE.Mesh(geometry, material);

            // Calculate position behind the wall
            const angleRad = angle * Math.PI / 180;
            let distance;
            if (angle === -35) distance = dimensions.left * 1.05; // Push behind wall
            else if (angle === 0) distance = dimensions.center * 1.02;
            else if (angle === 35) distance = dimensions.right * 1.05;

            const x = Math.sin(angleRad) * distance;
            const z = -Math.cos(angleRad) * distance;

            billboard.position.set(x, yPos, z);
            billboard.rotation.y = -angleRad;
            billboard.castShadow = true;

            scene.add(billboard);

            // Add support poles
            const poleMaterial = new THREE.MeshLambertMaterial({
                color: 0x4a4a4a,
                emissive: 0x2a2a2a,
                emissiveIntensity: 0.1
            });

            const poleRadius = 0.3;
            const poleHeight = yPos - height/2; // Height from ground to bottom of billboard
            const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 16);

            // Left pole
            const leftPoleX = x + Math.cos(angleRad) * (width / 2 - 2);
            const leftPoleZ = z + Math.sin(angleRad) * (width / 2 - 2);
            const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
            leftPole.position.set(leftPoleX, poleHeight / 2, leftPoleZ);
            leftPole.castShadow = true;
            scene.add(leftPole);

            // Right pole
            const rightPoleX = x - Math.cos(angleRad) * (width / 2 - 2);
            const rightPoleZ = z - Math.sin(angleRad) * (width / 2 - 2);
            const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
            rightPole.position.set(rightPoleX, poleHeight / 2, rightPoleZ);
            rightPole.castShadow = true;
            scene.add(rightPole);
        }

        function createDistanceMarker(distance, x, y, z, angle) {
            // Create canvas for distance text
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Draw yellow background circle
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(128, 64, 60, 0, Math.PI * 2);
            ctx.fill();

            // Draw distance number
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(distance, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(3, 1.5);
            const marker = new THREE.Mesh(geometry, material);

            marker.position.set(x, y + 0.5, z);
            marker.rotation.y = angle; // Face toward home plate (not flipped)
            scene.add(marker);
        }

        function createSeating() {
            // No stadium seating - just open field view
            // Removed per user request
        }

        function updateScoreboardDisplay(carry, total, apex, playerName) {
            const ctx = window.scoreboardCtx;
            if (!ctx) return;

            // Clear with dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 1024, 256);

            // Draw player name at top if provided
            if (playerName) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 50px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(playerName, 512, 20);
            }

            // Draw main distance (total) in large text
            ctx.fillStyle = '#ffff00'; // Yellow LED-style text
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const totalFeet = total * 3; // Convert yards to feet
            ctx.fillText(totalFeet.toFixed(0) + ' FT', 512, playerName ? 130 : 100);

            // Draw carry and apex in smaller text below
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#00ff00'; // Green for carry
            ctx.textAlign = 'left';
            ctx.fillText('CARRY: ' + carry.toFixed(0) + ' YDS', 100, 220);

            ctx.fillStyle = '#ff8800'; // Orange for apex
            ctx.textAlign = 'right';
            ctx.fillText('APEX: ' + apex.toFixed(0) + ' FT', 924, 220);

            // Update texture
            if (window.scoreboardTexture) {
                window.scoreboardTexture.needsUpdate = true;
            }
        }

        function createScoreboard() {
            // Scoreboard in center field above NOVA billboard
            const dimensions = {
                center: 405 * 0.3048  // 123.44 meters
            };

            // Create canvas for scoreboard display
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            window.scoreboardCanvas = canvas;
            window.scoreboardCtx = canvas.getContext('2d');

            // Initial scoreboard display
            updateScoreboardDisplay(0, 0, 0, null);

            const texture = new THREE.CanvasTexture(canvas);
            window.scoreboardTexture = texture;

            const scoreboardGeometry = new THREE.BoxGeometry(35, 12, 1);
            const scoreboardMaterial = new THREE.MeshLambertMaterial({
                map: texture,
                emissive: 0x0a0a0a,
                emissiveIntensity: 0.1
            });
            const scoreboard = new THREE.Mesh(scoreboardGeometry, scoreboardMaterial);

            // Position above NOVA sign in center field
            const scoreboardHeight = 18;
            const scoreboardZ = -(dimensions.center * 0.98) + 0.5;
            scoreboard.position.set(0, scoreboardHeight, scoreboardZ);
            scoreboard.castShadow = true;
            scene.add(scoreboard);

            // Add support poles to anchor scoreboard to ground
            const poleMaterial = new THREE.MeshLambertMaterial({
                color: 0x4a4a4a,
                emissive: 0x2a2a2a,
                emissiveIntensity: 0.1
            });

            // Left pole
            const poleRadius = 0.4;
            const poleHeight = scoreboardHeight - 6; // Bottom of scoreboard is at height 12 (18 - 6)
            const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 16);

            const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
            leftPole.position.set(-15, poleHeight / 2, scoreboardZ);
            leftPole.castShadow = true;
            scene.add(leftPole);

            // Right pole
            const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
            rightPole.position.set(15, poleHeight / 2, scoreboardZ);
            rightPole.castShadow = true;
            scene.add(rightPole);
        }

        function createCitySkyline() {
            // Distant city buildings (far behind stadium, like Progressive Field backdrop)
            const buildingMaterial = new THREE.MeshLambertMaterial({
                color: 0x8a8a8a,
                emissive: 0x4a4a4a,
                emissiveIntensity: 0.1
            });

            const distantBuildings = [
                // Far background cityscape
                { x: -200, z: -400, width: 60, height: 120, depth: 60 },
                { x: -100, z: -420, width: 50, height: 150, depth: 50 },
                { x: 0, z: -450, width: 70, height: 180, depth: 70 },
                { x: 100, z: -420, width: 55, height: 140, depth: 55 },
                { x: 200, z: -400, width: 65, height: 110, depth: 65 },
                { x: -250, z: -380, width: 45, height: 90, depth: 45 },
                { x: 250, z: -380, width: 50, height: 100, depth: 50 }
            ];

            distantBuildings.forEach(bldg => {
                const buildingGeometry = new THREE.BoxGeometry(bldg.width, bldg.height, bldg.depth);
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                // Position so bottom of building is at ground level (y=0)
                // BoxGeometry centers at origin, so y = height/2 puts bottom at y=0
                building.position.set(bldg.x, bldg.height / 2, bldg.z);
                scene.add(building);
            });

            // Add Shanktuary Mini Games logo on face of tallest building
            const loader = new THREE.TextureLoader();
            loader.load('shanktuaryminigames-modified.png', (texture) => {
                const logoMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                // Logo is square, so use square geometry to maintain aspect ratio
                const logoGeometry = new THREE.PlaneGeometry(70, 70);
                const logo = new THREE.Mesh(logoGeometry, logoMaterial);

                // Position on front face of tallest building (x: 0, height: 180, z: -450)
                // Move higher on the building
                // Front face is at z: -450 + depth/2 = -450 + 35 = -415
                logo.position.set(0, 130, -415);
                // No rotation - flat against the building face

                scene.add(logo);
                console.log('âœ… Shanktuary Mini Games logo added to building face');
            });
        }

        function createStadiumLights() {
            // Stadium light towers like in Progressive Field
            const towerPositions = [
                { x: -120, z: 30 },   // Left field foul pole area
                { x: 120, z: 30 },    // Right field foul pole area
                { x: -80, z: -140 },  // Left-center field
                { x: 80, z: -140 }    // Right-center field
            ];

            towerPositions.forEach(pos => {
                // Tower pole
                const poleGeometry = new THREE.CylinderGeometry(1.5, 2, 50, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(pos.x, 25, pos.z);
                pole.castShadow = true;
                scene.add(pole);

                // Light bank at top
                const lightBankGeometry = new THREE.BoxGeometry(6, 3, 10);
                const lightBankMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00
                });
                const lightBank = new THREE.Mesh(lightBankGeometry, lightBankMaterial);
                lightBank.position.set(pos.x, 50, pos.z);
                scene.add(lightBank);

                // Actual point light for illumination
                const stadiumLight = new THREE.PointLight(0xffffff, 0.5, 200);
                stadiumLight.position.set(pos.x, 50, pos.z);
                scene.add(stadiumLight);
            });
        }


        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base green
            ctx.fillStyle = '#3a7d3a';
            ctx.fillRect(0, 0, 256, 256);
            
            // Add grass blade details
            ctx.strokeStyle = '#2d5a2d';
            ctx.lineWidth = 1;
            for (let i = 0; i < 1000; i++) {
                ctx.beginPath();
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.random() * 4 - 2, y + Math.random() * 8);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);
            return texture;
        }

        // Old golf driving range functions - no longer needed for baseball field
        // Kept here for reference if needed later

        function createBall(shotData) {
            // Check for swing and miss in Derby Mode
            if (isDerbyMode && !derbyGameOver && shotData.speed < 20) {
                recordStrike('Swing and Miss');
                return; // Don't create ball for swing and miss
            }

            // Check for swing and miss in Baseball Mode
            if (isBaseballMode && !baseballGame.gameOver && shotData.speed < 20) {
                recordOut();
                showNotification('âŒ SWING AND MISS - OUT! âŒ');
                updateBaseballDisplay();
                return; // Don't create ball for swing and miss
            }

            // Enhanced ball with dimples texture
            const ballGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.05,
                shininess: 100
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, 0.044, 0); // Start at tee height (1.75 inches)
            ball.castShadow = true;

            // Get current player's color for trail
            const currentPlayer = window.homeRunPlayers[window.currentPlayerIndex];
            ball.playerColor = currentPlayer.color;

            // Scale ball based on camera view for better visibility
            if (currentView === 'overhead') {
                ball.scale.set(5, 5, 5);
            }

            // Physics properties
            const velocityMagnitude = shotData.speed * 0.44704; // mph to m/s
            const launchRad = shotData.vla * Math.PI / 180;
            const sideRad = shotData.hla * Math.PI / 180;

            ball.velocity = new THREE.Vector3(
                velocityMagnitude * Math.sin(sideRad) * Math.cos(launchRad),
                velocityMagnitude * Math.sin(launchRad),
                -velocityMagnitude * Math.cos(sideRad) * Math.cos(launchRad)
            );

            console.log('ðŸ€ Ball created:');
            console.log('  Speed:', shotData.speed, 'mph â†’', velocityMagnitude.toFixed(2), 'm/s');
            console.log('  Launch angle:', shotData.vla, 'Â°');
            console.log('  Side angle:', shotData.hla, 'Â°');
            console.log('  Initial velocity:', ball.velocity);
            console.log('  Starting position:', ball.position);
            
            // Convert spin to vector (rad/s) - matches NOVA extension
            const spinAxis = 0; // Assuming spin axis is mostly backspin
            ball.spin = new THREE.Vector3(
                shotData.backSpin * (2 * Math.PI / 60),  // rad/s
                0,
                -(shotData.sideSpin || 0) * (2 * Math.PI / 60)  // rad/s
            );

            ball.ballSpeed = shotData.speed;
            ball.launchAngle = shotData.vla;
            ball.sideAngle = shotData.hla;
            ball.backSpin = shotData.backSpin;
            ball.sideSpin = shotData.sideSpin;
            ball.totalSpin = shotData.totalSpin;
            ball.spinAxis = shotData.spinAxis || 0;
            ball.playerName = currentPlayer.name;
            ball.trail = [];
            ball.maxTrailLength = 100; // Increased for better tracer
            ball.startTime = Date.now();
            ball.maxHeight = 0;
            ball.carryDistance = 0;
            ball.landed = false;
            ball.stopped = false;
            ball.landingTime = 0;

            ball.club = shotData.club;
            
            scene.add(ball);
            balls.push(ball);
            
            // Update UI and live display
            updateShotInfo(shotData);
            updateLiveDistance(0, 0, 0); // Reset live distance display
            document.getElementById('resultInfo').style.display = 'none';
            
            // Add club display to shot distance panel (if it exists)
            const shotDistancePanel = document.getElementById('shotDistance');
            if (shotDistancePanel) {
                const clubDisplay = document.createElement('div');
                clubDisplay.style.cssText = 'color: #4CAF50; font-weight: bold; margin-bottom: 10px;';
                clubDisplay.textContent = getClubName(shotData.club);
                const existingClubDisplay = shotDistancePanel.querySelector('div[style*="color: #4CAF50"]');
                if (existingClubDisplay) {
                    existingClubDisplay.textContent = getClubName(shotData.club);
                } else {
                    shotDistancePanel.insertBefore(clubDisplay, shotDistancePanel.children[1]);
                }
            }
            
            // Camera follow for non-first-person views
            if (currentView !== 'first-person') {
                updateCameraPosition();
            }
        }

        // GSA Golf Simulator Theory - Spin Axis Calculations
        function calculateSpinAxisTilt(sideSpinRPM, backSpinRPM) {
            // From GSA theory: ratio method for spin axis tilt
            if (backSpinRPM === 0) return 0;
            const ratio = Math.abs(sideSpinRPM) / backSpinRPM;
            const tiltDegrees = (ratio / 2) * 45;
            return tiltDegrees;
        }

        function calculateSpinAxisVector(backSpinRPM, sideSpinRPM) {
            // Calculate 3D spin axis from back and side spin components
            const totalSpin = Math.sqrt(backSpinRPM * backSpinRPM + sideSpinRPM * sideSpinRPM);
            if (totalSpin === 0) return new THREE.Vector3(0, 1, 0);

            // Normalize to unit vector
            const spinAxis = new THREE.Vector3(
                sideSpinRPM / totalSpin,
                backSpinRPM / totalSpin,
                0
            );

            return spinAxis.normalize();
        }

        function calculateMagnusForce(velocity, spinAxisRPM, backSpinRPM, sideSpinRPM, airDensity, ballRadius) {
            // GSA-based Magnus force calculation
            // Magnus force = (4/3) * Ï€ * rÂ³ * Ï * Ï‰ Ã— v
            const speed = velocity.length();
            if (speed < 0.1) return new THREE.Vector3(0, 0, 0);

            // Convert RPM to rad/s: Ï‰ = RPM Ã— 2Ï€ / 60
            const angularVelocity = (spinAxisRPM * 2 * Math.PI) / 60;

            // Spin axis vector
            const spinAxis = calculateSpinAxisVector(backSpinRPM, sideSpinRPM);

            // Magnus coefficient - REDUCED to prevent tornado spinning
            const magnusCoeff = 0.000002; // Much smaller coefficient for realistic ball flight

            // Calculate Magnus force perpendicular to both velocity and spin axis
            const velocityNorm = velocity.clone().normalize();
            const magnusDirection = new THREE.Vector3().crossVectors(spinAxis, velocityNorm);

            // Magnitude depends on speed and spin rate
            const magnusMagnitude = magnusCoeff * angularVelocity * speed;

            return magnusDirection.multiplyScalar(magnusMagnitude);
        }

        // Velocity-dependent scaling to match FlightScope data across all speeds
        function getScalingMultipliers(ballSpeedMph, sideAngleDeg = 0) {
            // Lookup table based on FlightScope calibration data (for 0Â° HLA)
            // [speed, distanceMultiplier, apexMultiplier]
            const calibrationPoints = [
                [70, 1.27, 1.94],
                [100, 1.45, 2.76],
                [150, 1.63, 3.39],
                [212, 1.51, 3.73]
            ];

            // Find the two points to interpolate between
            let baseMultipliers;
            if (ballSpeedMph <= calibrationPoints[0][0]) {
                baseMultipliers = { distance: calibrationPoints[0][1], apex: calibrationPoints[0][2] };
            } else if (ballSpeedMph >= calibrationPoints[calibrationPoints.length - 1][0]) {
                baseMultipliers = {
                    distance: calibrationPoints[calibrationPoints.length - 1][1],
                    apex: calibrationPoints[calibrationPoints.length - 1][2]
                };
            } else {
                // Linear interpolation
                for (let i = 0; i < calibrationPoints.length - 1; i++) {
                    const [speed1, dist1, apex1] = calibrationPoints[i];
                    const [speed2, dist2, apex2] = calibrationPoints[i + 1];

                    if (ballSpeedMph >= speed1 && ballSpeedMph <= speed2) {
                        const ratio = (ballSpeedMph - speed1) / (speed2 - speed1);
                        baseMultipliers = {
                            distance: dist1 + ratio * (dist2 - dist1),
                            apex: apex1 + ratio * (apex2 - apex1)
                        };
                        break;
                    }
                }
            }

            if (!baseMultipliers) {
                baseMultipliers = { distance: 1.63, apex: 3.39 };
            }

            // Adjust for horizontal launch angle
            // FlightScope shows HLA impact scales with velocity - use velocity-dependent boost
            const absHLA = Math.abs(sideAngleDeg);

            // HLA boost factors per degree at different velocities
            // [speed, boostPerDegree]
            const hlaCalibration = [
                [70, 0.010],   // 1.0% per degree
                [100, 0.005],  // 0.5% per degree
                [150, 0.012],  // 1.2% per degree
                [212, 0.044]   // 4.4% per degree
            ];

            // Interpolate HLA boost factor
            let hlaBoostPerDegree;
            if (ballSpeedMph <= hlaCalibration[0][0]) {
                hlaBoostPerDegree = hlaCalibration[0][1];
            } else if (ballSpeedMph >= hlaCalibration[hlaCalibration.length - 1][0]) {
                hlaBoostPerDegree = hlaCalibration[hlaCalibration.length - 1][1];
            } else {
                for (let i = 0; i < hlaCalibration.length - 1; i++) {
                    const [speed1, boost1] = hlaCalibration[i];
                    const [speed2, boost2] = hlaCalibration[i + 1];

                    if (ballSpeedMph >= speed1 && ballSpeedMph <= speed2) {
                        const ratio = (ballSpeedMph - speed1) / (speed2 - speed1);
                        hlaBoostPerDegree = boost1 + ratio * (boost2 - boost1);
                        break;
                    }
                }
            }

            const hlaBoost = 1 + (absHLA * hlaBoostPerDegree);

            return {
                distance: baseMultipliers.distance * hlaBoost,
                apex: baseMultipliers.apex * (1 - absHLA * 0.02) // Apex is lower with HLA
            };
        }

        function updateBalls(deltaTime) {
            const gravity = 9.81;
            const airDensity = getAirDensity(temperature, humidity);
            const ballRadius = 0.021335; // meters (1.68 inches standard)
            const ballMass = 0.04593; // kg (1.62 oz standard)
            const ballArea = Math.PI * ballRadius * ballRadius;

            // Enhanced drag coefficient with Reynolds number dependence
            const dragCoefficient = 0.47;

            balls = balls.filter(ball => {
                // Force landing if ball has been in air too long (prevent infinite flight)
                const flightTime = (Date.now() - ball.startTime) / 1000;
                if (!ball.landed && flightTime > 15) {
                    console.log('âš ï¸ Forcing ball to land after 15 seconds');
                    ball.position.y = 0.1;
                    ball.landed = true;
                    ball.landingTime = Date.now();
                    ball.velocity.y = 0;
                }

                // Check if ball has come to rest
                if (ball.landed) {
                    const groundSpeed = Math.sqrt(ball.velocity.x * ball.velocity.x + ball.velocity.z * ball.velocity.z);
                    const timeSinceLanding = (Date.now() - ball.landingTime) / 1000;

                    // Check if ball has come to rest (only stop when velocity is very low)
                    if (!ball.stopped && groundSpeed < 0.1) {
                        ball.stopped = true;
                        const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);

                        // Calculate total distance with separate forward and lateral components
                        const forwardMeters = Math.abs(ball.position.z);
                        const lateralMeters = Math.abs(ball.position.x);
                        const forwardYards = (forwardMeters / 0.9144) * multipliers.distance;
                        const lateralYards = (lateralMeters / 0.9144) * multipliers.distance;
                        const totalDistance = Math.sqrt(forwardYards * forwardYards + lateralYards * lateralYards);

                        // Update lateral distance (includes rollout)
                        ball.lateralDistance = lateralYards;

                        updateResultInfo(ball, totalDistance);
                    }

                    // Only exit physics loop if ball has actually stopped
                    if (ball.stopped) {
                        // Check shot result for Derby Mode
                        checkShotResult(ball);
                        return true;
                    }
                }

                // Physics calculations - using NOVA extension's proven McNally et al. model
                const v = ball.velocity.length();
                const w = ball.spin.length();

                // Simplified aerodynamic model - tuned Cd curve from FlightScope calibration (Par 3)
                if (v > 0.1) {
                    const S = w > 0.1 ? (ballRadius * w / v) : 0;

                    // Convert speed to mph for Cd lookup
                    const speedMPH = v * 2.237; // m/s to mph
                    let CD;

                    // FlightScope calibration points - same as Par 3 (8/10 tests passing)
                    if (speedMPH <= 55) {
                        CD = 0.70;
                    } else if (speedMPH <= 75) {
                        const t = (speedMPH - 55) / (75 - 55);
                        CD = 0.70 - t * (0.70 - 0.31);
                    } else if (speedMPH <= 100) {
                        const t = (speedMPH - 75) / (100 - 75);
                        CD = 0.31 - t * (0.31 - 0.22);
                    } else if (speedMPH <= 126) {
                        const t = (speedMPH - 100) / (126 - 100);
                        CD = 0.22 - t * (0.22 - 0.17);
                    } else if (speedMPH <= 150) {
                        const t = (speedMPH - 126) / (150 - 126);
                        CD = 0.17 - t * (0.17 - 0.10);
                    } else {
                        CD = 0.10;
                    }

                    const CL = 0.35 * S;  // Moderate lift for realistic apex
                    const CM = 0.0001 * S;  // Minimal spin decay

                    const q = 0.5 * airDensity * v * v;

                    // Lift force (Magnus effect)
                    if (w > 0.1) {
                        const cross = new THREE.Vector3().crossVectors(ball.velocity, ball.spin);
                        const crossMag = cross.length();
                        if (crossMag > 0.001) {
                            const liftDir = cross.normalize();
                            const lift = liftDir.multiplyScalar(CL * q * ballArea);
                            ball.velocity.add(lift.multiplyScalar(deltaTime / ballMass));
                        }
                    }

                    // Drag force
                    const drag = ball.velocity.clone().normalize().multiplyScalar(-CD * q * ballArea);
                    ball.velocity.add(drag.multiplyScalar(deltaTime / ballMass));

                    // Spin decay
                    if (w > 0.1) {
                        const d = 2 * ballRadius;
                        const I = (2/5) * ballMass * ballRadius * ballRadius;
                        const spinDecay = ball.spin.clone().normalize().multiplyScalar(-CM * q * d * ballArea / I);
                        ball.spin.add(spinDecay.multiplyScalar(deltaTime));

                        ball.backSpin = ball.spin.x * (60 / (2 * Math.PI));
                        ball.sideSpin = -ball.spin.z * (60 / (2 * Math.PI));
                        ball.totalSpin = ball.spin.length() * (60 / (2 * Math.PI));
                    }
                }

                // Gravity
                ball.velocity.y -= gravity * deltaTime;
                
                // Update position
                const oldPosition = ball.position.clone();
                ball.position.add(ball.velocity.clone().multiplyScalar(deltaTime));
                
                // Track max height
                if (ball.position.y > ball.maxHeight) {
                    ball.maxHeight = ball.position.y;
                }
                
                // Ground collision (ball radius is 0.1, so check if center is at or below 0.1)
                if (ball.position.y <= 0.1 && ball.velocity.y < 0) {  // Only collide if moving downward
                    if (!ball.landed) {
                        ball.landed = true;
                        ball.landingTime = Date.now();
                        // Calculate carry distance with separate forward and lateral components
                        // This matches FlightScope's measurement: lateral = carry Ã— sin(HLA)
                        const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);

                        // Scale forward and lateral distances separately
                        const forwardMeters = Math.abs(ball.position.z);
                        const lateralMeters = Math.abs(ball.position.x);
                        const forwardYards = (forwardMeters / 0.9144) * multipliers.distance;
                        const lateralYards = (lateralMeters / 0.9144) * multipliers.distance;

                        // Carry is the straight-line distance
                        ball.carryDistance = Math.sqrt(forwardYards * forwardYards + lateralYards * lateralYards);
                        ball.lateralDistance = lateralYards;

                        // Realistic bounce based on landing speed and spin - FlightScope calibrated (same as Par 3)
                        const landingSpeed = ball.velocity.length();
                        const landingSpeedMPH = landingSpeed * 2.237; // m/s to mph
                        const spinRate = ball.spin.length() * (60 / (2 * Math.PI)); // Convert to RPM

                        // Base bounce from landing speed (from Par 3 tuning)
                        let baseBounce;
                        if (landingSpeedMPH <= 30) {
                            baseBounce = 0.80;
                        } else if (landingSpeedMPH <= 40) {
                            const t = (landingSpeedMPH - 30) / (40 - 30);
                            baseBounce = 0.80 - t * (0.80 - 0.65);
                        } else if (landingSpeedMPH <= 60) {
                            const t = (landingSpeedMPH - 40) / (60 - 40);
                            baseBounce = 0.65 - t * (0.65 - 0.45);
                        } else if (landingSpeedMPH <= 80) {
                            const t = (landingSpeedMPH - 60) / (80 - 60);
                            baseBounce = 0.45 - t * (0.45 - 0.35);
                        } else {
                            baseBounce = 0.35;
                        }

                        // Spin adjustment (from Par 3 tuning)
                        let spinAdjustment;
                        if (spinRate >= 5500) {
                            spinAdjustment = -0.70;
                        } else if (spinRate >= 5000) {
                            const t = (spinRate - 5000) / (5500 - 5000);
                            spinAdjustment = -0.55 - t * (0.70 - 0.55);
                        } else if (spinRate >= 4000) {
                            const t = (spinRate - 4000) / (5000 - 4000);
                            spinAdjustment = -0.25 - t * (0.55 - 0.25);
                        } else if (spinRate >= 3000) {
                            const t = (spinRate - 3000) / (4000 - 3000);
                            spinAdjustment = 0.0 - t * 0.25;
                        } else if (spinRate >= 2000) {
                            const t = (spinRate - 2000) / (3000 - 2000);
                            spinAdjustment = 0.3 - t * 0.3;
                        } else if (spinRate >= 1000) {
                            const t = (spinRate - 1000) / (2000 - 1000);
                            spinAdjustment = 0.6 - t * 0.3;
                        } else {
                            spinAdjustment = 0.6;
                        }

                        const bounceFactor = Math.max(0.05, Math.min(0.95, baseBounce * (1 + spinAdjustment)));

                        ball.velocity.y *= -0.3; // Vertical bounce
                        ball.velocity.x *= bounceFactor;
                        ball.velocity.z *= bounceFactor;

                        // Reduce spin on bounce
                        ball.spin.multiplyScalar(0.5);
                    } else {
                        // Realistic rollout on grass
                        // Grass friction coefficient for golf ball rollout (ShotScope: 9 yards roll from 250.1 carry)
                        const grassFriction = 0.50; // Lower = more friction, stops faster
                        ball.velocity.x *= grassFriction;
                        ball.velocity.z *= grassFriction;

                        // Small bounces - less bouncy after first impact
                        if (Math.abs(ball.velocity.y) > 0.05) {
                            ball.velocity.y *= -0.2;
                        } else {
                            ball.velocity.y = 0;
                        }

                        // Gradually reduce spin during rollout
                        ball.spin.multiplyScalar(0.95);
                    }
                    ball.position.y = 0.1;
                }
                
                // Add trail
                if (ball.trail.length === 0 ||
                    ball.position.distanceTo(ball.trail[ball.trail.length - 1].position) > 0.5) {
                    const trailGeometry = new THREE.SphereGeometry(
                        currentView === 'overhead' ? 0.5 : 0.05,
                        8,
                        8
                    );

                    // Use player's color for trail
                    const color = new THREE.Color(ball.playerColor || '#ffcc00');

                    const trailMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const trailSphere = new THREE.Mesh(trailGeometry, trailMaterial);
                    trailSphere.position.copy(ball.position);
                    scene.add(trailSphere);
                    ball.trail.push(trailSphere);

                    if (ball.trail.length > ball.maxTrailLength) {
                        const removed = ball.trail.shift();
                        scene.remove(removed);
                    }
                }
                
                // Update trail opacity with fade effect
                ball.trail.forEach((trail, index) => {
                    const opacity = 0.5 + 0.5 * (index / ball.trail.length);
                    trail.material.opacity = opacity;
                });
                
                // Update displays
                updateMinimap(ball);
                updateTrajectoryDisplay(ball);
                
                // Update live distance display with velocity-dependent scaling
                const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);
                const currentCarry = ball.landed ? ball.carryDistance :
                    Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z) / 0.9144 * multipliers.distance;
                const currentTotal = Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z) / 0.9144 * multipliers.distance;
                const currentApex = ball.maxHeight * 3.28084 * multipliers.apex; // Convert to feet and scale to match FlightScope
                
                updateLiveDistance(currentCarry, currentTotal, currentApex);
                
                return true;
            });
        }

        function updateLiveDistance(carry, total, apex) {
            // Update scoreboard with all data including player name
            const playerName = window.currentPlayerName || null;
            updateScoreboardDisplay(carry, total, apex, playerName);
        }

        function getAirDensity(temp, humidity) {
            // Simplified air density calculation
            const tempK = (temp - 32) * 5/9 + 273.15; // Convert F to Kelvin
            const pressure = 101325; // Pa (sea level)
            const R = 287.05; // Gas constant
            return pressure / (R * tempK) * (1 - 0.0035 * humidity / 100);
        }

        function calculateWindEffect(height, ballSpeed) {
            // Wind increases with height
            const heightFactor = 1 + height / 100;
            const effectiveWind = wind.speed * heightFactor * 0.44704; // mph to m/s
            
            const windRad = wind.direction * Math.PI / 180;
            const windVector = new THREE.Vector3(
                effectiveWind * Math.sin(windRad),
                0,
                -effectiveWind * Math.cos(windRad)
            );
            
            // Wind effect decreases with ball speed
            const speedFactor = Math.max(0.1, 1 - ballSpeed / 100);
            return windVector.multiplyScalar(speedFactor * 0.1);
        }

        function updateCameraPosition(autoRevert = true) {
            switch (currentView) {
                case 'first-person':
                    // Home plate view - elevated to see walls better
                    camera.position.set(0, 2.5, 5);
                    camera.lookAt(0, 3, -80);
                    break;
                case 'auto-follow':
                case 'follow':
                    if (balls.length > 0) {
                        const ball = balls[balls.length - 1];
                        // Only follow if ball is in flight (not landed yet)
                        if (!ball.stopped) {
                            camera.position.set(
                                ball.position.x - 10,
                                ball.position.y + 8,
                                ball.position.z + 15
                            );
                            camera.lookAt(ball.position);
                        } else if (currentView === 'auto-follow' && autoRevert) {
                            // Ball has stopped, return to first-person (only during animation loop)
                            currentView = savedView;
                            updateCameraPosition();
                        } else {
                            // Manual view change or follow mode - show default position
                            camera.position.set(0, 20, 30);
                            camera.lookAt(0, 5, -80);
                        }
                    } else {
                        // No balls - elevated side view
                        camera.position.set(0, 20, 30);
                        camera.lookAt(0, 5, -80);
                    }
                    break;
                case 'overhead':
                    // High overhead view to see entire field (much higher)
                    camera.position.set(0, 120, 0);
                    camera.lookAt(0, 0, -100);
                    break;
            }
        }

        function cycleView() {
            const views = ['first-person', 'auto-follow', 'follow', 'overhead'];
            const currentIndex = views.indexOf(currentView);
            currentView = views[(currentIndex + 1) % views.length];

            // Save the view in case auto-follow needs to revert
            if (currentView !== 'auto-follow') {
                savedView = currentView;
            }

            // Don't auto-revert when manually cycling views
            updateCameraPosition(false);

            document.getElementById('crosshair').style.display =
                currentView === 'first-person' ? 'block' : 'none';

            // Update ball scale for overhead view
            balls.forEach(ball => {
                if (currentView === 'overhead') {
                    ball.scale.set(5, 5, 5);
                } else {
                    ball.scale.set(1, 1, 1);
                }
            });

            // Show camera view notification
            const viewNames = {
                'first-person': 'First Person',
                'auto-follow': 'Auto Follow',
                'follow': 'Manual Follow',
                'overhead': 'Overhead'
            };
            showNotification(`Camera: ${viewNames[currentView]}`);
        }

        function showNotification(message) {
            // Remove existing notification if any
            const existing = document.getElementById('cameraNotification');
            if (existing) existing.remove();

            // Create notification element
            const notification = document.createElement('div');
            notification.id = 'cameraNotification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            // Fade out and remove after 2 seconds
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function getClubName(code) {
            const clubNames = {
                'DR': 'Driver',
                'W3': '3 Wood',
                'W5': '5 Wood',
                'H3': '3 Hybrid',
                'H4': '4 Hybrid',
                'I2': '2 Iron',
                'I3': '3 Iron',
                'I4': '4 Iron',
                'I5': '5 Iron',
                'I6': '6 Iron',
                'I7': '7 Iron',
                'I8': '8 Iron',
                'I9': '9 Iron',
                'PW': 'Pitching Wedge',
                'GW': 'Gap Wedge',
                'SW': 'Sand Wedge',
                'LW': 'Lob Wedge',
                'PT': 'Putter'
            };
            return clubNames[code] || code;
        }

        function updateShotInfo(shotData) {
            document.getElementById('shotInfo').style.display = 'block';
            document.getElementById('clubType').textContent = getClubName(shotData.club);
            document.getElementById('ballSpeed').textContent = shotData.speed.toFixed(1) + ' mph';
            document.getElementById('launchAngle').textContent = shotData.vla.toFixed(1) + 'Â°';
            document.getElementById('sideAngle').textContent = shotData.hla.toFixed(1) + 'Â°';
            document.getElementById('backSpin').textContent = Math.round(shotData.backSpin) + ' rpm';
            document.getElementById('sideSpin').textContent = Math.round(shotData.sideSpin) + ' rpm';
            document.getElementById('totalSpin').textContent = Math.round(shotData.totalSpin || 0) + ' rpm';

            // Calculate and display spin axis tilt (GSA formula)
            const spinAxisTilt = calculateSpinAxisTilt(shotData.sideSpin, shotData.backSpin);
            document.getElementById('spinAxisTilt').textContent = spinAxisTilt.toFixed(1) + 'Â°';
        }

        function updateResultInfo(ball, totalDistance) {
            const flightTime = (Date.now() - ball.startTime) / 1000;
            const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);
            const apexFeet = ball.maxHeight * 3.28084 * multipliers.apex;

            document.getElementById('resultInfo').style.display = 'block';
            document.getElementById('carryDistance').textContent = ball.carryDistance.toFixed(1);
            document.getElementById('totalDistance').textContent = totalDistance.toFixed(1);
            document.getElementById('apexHeight').textContent = apexFeet.toFixed(1); // m to ft, velocity-scaled to match FlightScope
            document.getElementById('flightTime').textContent = flightTime.toFixed(1);

            // Add shot to session tracking for CSV export
            sessionShots.push({
                timestamp: new Date().toISOString(),
                player: ball.playerName || 'Unknown',
                ballSpeed: ball.ballSpeed || 0,
                launchAngle: ball.launchAngle || 0,
                sideAngle: ball.sideAngle || 0,
                totalSpin: ball.totalSpin || 0,
                spinAxis: ball.spinAxis || 0,
                carryDistance: ball.carryDistance,
                totalDistance: totalDistance,
                rollout: totalDistance - ball.carryDistance,
                lateralDistance: ball.lateralDistance || 0,
                apexHeight: apexFeet,
                flightTime: flightTime
            });
        }

        function updateConnectionStatus(status, message) {
            // Connection status widget removed - status now shown only in title
        }

        // Live data connection
        function updatePlayerDisplay() {
            if (!window.homeRunPlayers || window.homeRunPlayers.length === 0) return;

            const player = window.homeRunPlayers[window.currentPlayerIndex];
            window.currentPlayerName = player.name;

            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }

            // Update scoreboard with current player
            updateLiveDistance(0, 0, 0);
        }

        function nextPlayer() {
            if (!window.homeRunPlayers || window.homeRunPlayers.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.homeRunPlayers.length;
            localStorage.setItem('homeRunDerbyCurrentPlayer', window.currentPlayerIndex.toString());

            updatePlayerDisplay();
            console.log('Switched to player:', window.homeRunPlayers[window.currentPlayerIndex].name);
        }

        function toggleStats() {
            const shotInfo = document.getElementById('shotInfo');
            const resultInfo = document.getElementById('resultInfo');
            const icon = document.getElementById('collapseIcon');

            shotInfo.classList.toggle('collapsed');
            resultInfo.classList.toggle('collapsed');

            icon.textContent = shotInfo.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }

        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debugPanel');
            const icon = document.getElementById('debugIcon');

            debugPanel.classList.toggle('collapsed');
            icon.textContent = debugPanel.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }

        function exportSessionCSV() {
            if (sessionShots.length === 0) {
                alert('No shots recorded yet! Hit some balls first.');
                return;
            }

            // CSV headers
            const headers = [
                'Timestamp',
                'Player',
                'Ball Speed (mph)',
                'Launch Angle (Â°)',
                'Side Angle (Â°)',
                'Total Spin (rpm)',
                'Spin Axis (Â°)',
                'Carry (yds)',
                'Total (yds)',
                'Rollout (yds)',
                'Lateral (yds)',
                'Apex (ft)',
                'Flight Time (s)'
            ];

            // Build CSV content
            let csvContent = headers.join(',') + '\n';

            sessionShots.forEach(shot => {
                const row = [
                    shot.timestamp,
                    shot.player,
                    shot.ballSpeed.toFixed(1),
                    shot.launchAngle.toFixed(1),
                    shot.sideAngle.toFixed(1),
                    shot.totalSpin.toFixed(0),
                    shot.spinAxis.toFixed(1),
                    shot.carryDistance.toFixed(1),
                    shot.totalDistance.toFixed(1),
                    shot.rollout.toFixed(1),
                    shot.lateralDistance.toFixed(1),
                    shot.apexHeight.toFixed(1),
                    shot.flightTime.toFixed(1)
                ];
                csvContent += row.join(',') + '\n';
            });

            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            const dateStr = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.setAttribute('href', url);
            link.setAttribute('download', `home-run-derby-session-${dateStr}.csv`);
            link.style.visibility = 'hidden';

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`Exported ${sessionShots.length} shots to CSV`);
        }

        function launchDebugShot() {
            const speed = parseFloat(document.getElementById('debugSpeed').value);
            const vla = parseFloat(document.getElementById('debugVLA').value);
            const hla = parseFloat(document.getElementById('debugHLA').value);
            const backSpin = parseFloat(document.getElementById('debugBackSpin').value);
            const sideSpin = parseFloat(document.getElementById('debugSideSpin').value);

            // Calculate total spin and spin axis from backspin/sidespin
            const totalSpin = Math.sqrt(backSpin * backSpin + sideSpin * sideSpin);
            const spinAxis = Math.atan2(Math.abs(sideSpin), Math.abs(backSpin)) * 180 / Math.PI;

            const shotData = {
                speed: speed,
                vla: vla,
                hla: hla,
                backSpin: backSpin,
                sideSpin: sideSpin,
                totalSpin: totalSpin,
                spinAxis: spinAxis,
                club: 'DR'
            };

            console.log('ðŸ§ª Debug shot launched:', shotData);
            createBall(shotData);
        }

        function setupElectronIPC() {
            console.log('Setting up Electron IPC for Home Run Derby');

            // Load players from localStorage
            const playersData = localStorage.getItem('homeRunDerbyPlayers');
            window.homeRunPlayers = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#ff6b6b' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('homeRunDerbyCurrentPlayer') || '0');
            window.currentPlayerName = window.homeRunPlayers[window.currentPlayerIndex].name;

            console.log('Players:', window.homeRunPlayers);
            console.log('Current player:', window.currentPlayerName);

            // Update player display
            updatePlayerDisplay();

            // Hide Next Player button if only 1 player
            if (window.homeRunPlayers.length === 1) {
                document.getElementById('nextPlayerBtn').style.display = 'none';
            }

            // Listen for shot data from Electron main process
            window.electronAPI.onShotData((shotData) => {
                console.log('ðŸ“¡ Shot data received via IPC:', shotData);

                // Get current player's power multiplier
                const currentPlayer = window.homeRunPlayers[window.currentPlayerIndex];
                const powerMultiplier = currentPlayer.powerMultiplier || 1.0;

                // Apply power boost for weak shots
                let ballSpeed = shotData.ball_speed || 0;
                if (ballSpeed > 0 && ballSpeed < 70 && powerMultiplier > 1.0) {
                    console.log(`ðŸ‘¶ Power boost applied: ${ballSpeed.toFixed(1)} mph â†’ ${(ballSpeed * powerMultiplier).toFixed(1)} mph (${powerMultiplier}x)`);
                    ballSpeed *= powerMultiplier;
                }

                // Convert electron shot format to our format
                const homeRunShotData = {
                    speed: ballSpeed,  // Use boosted speed
                    vla: shotData.vla || 0,
                    hla: shotData.hla || 0,
                    backSpin: shotData.back_spin || 0,
                    sideSpin: shotData.side_spin || 0,
                    totalSpin: shotData.total_spin || 0,
                    spinAxis: shotData.spin_axis || 0,
                    club: 'DR'
                };

                // Only create ball if we have meaningful data
                if (homeRunShotData.speed > 0) {
                    console.log('Creating ball with data:', homeRunShotData);
                    createBall(homeRunShotData);
                } else {
                    console.log('âš  Ignoring shot - speed is 0');
                }
            });

            console.log('âœ“ Electron IPC setup complete');
        }

        function toggleLiveMode() {
            if (isLiveMode) {
                disconnectLive();
            } else {
                connectLive();
            }
        }

        function connectLive() {
            try {
                updateConnectionStatus('Connecting', 'Attempting to connect...');
                
                // Connect to the log monitor WebSocket server
                ws = new WebSocket('ws://192.168.1.7:8080');
                
                ws.onopen = () => {
                    console.log('Connected to GSPro log monitor');
                    isLiveMode = true;
                    document.getElementById('connectBtn').textContent = 'Disconnect';
                    document.getElementById('liveIndicator').classList.add('connected');
                    updateConnectionStatus('Connected', 'Receiving live data');
                };
                
                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        messageCount++;
                        updateConnectionStatus('Connected', 'Receiving data');
                        
                        console.log('Received message:', message);
                        
                        // Handle different message types
                        if (message.type === 'connection') {
                            console.log('Connection established:', message.message);
                        } else if (message.type === 'heartbeat') {
                            console.log('Heartbeat:', message.message);
                        } else if (message.message_type === 'HANDSHAKE' && message.data && message.data.BallData) {
                            // This is shot data from GSPro
                            const ballData = message.data.BallData;
                            const playerInfo = message.data.Player || message.player_info;

                            // Store current player name for scoreboard display
                            if (playerInfo && playerInfo.Name) {
                                window.currentPlayerName = playerInfo.Name;
                            }

                            console.log('Processing shot data:', ballData);
                            console.log('Player info:', playerInfo);
                            
                            // Convert GSPro data to our format
                            const shotData = {
                                speed: ballData.Speed || 0,
                                vla: ballData.VLA || 0,  // Vertical Launch Angle
                                hla: ballData.HLA || 0,  // Horizontal Launch Angle
                                backSpin: ballData.BackSpin || 0,
                                sideSpin: ballData.SideSpin || 0,
                                totalSpin: ballData.TotalSpin || 0,
                                spinAxis: ballData.SpinAxis || 0,
                                club: playerInfo?.Club || playerInfo?.club || 'DR'
                            };
                            
                            // Only create ball if we have meaningful data
                            if (shotData.speed > 0) {
                                console.log('Creating ball with data:', shotData);
                                createBall(shotData);
                            }
                        } else if (message.shot_summary) {
                            // Handle shot summary data directly
                            const summary = message.shot_summary;
                            const playerInfo = message.player_info || {};
                            const shotData = {
                                speed: summary.speed || 0,
                                vla: summary.vla || 0,
                                hla: summary.hla || 0,
                                backSpin: summary.back_spin || 0,
                                sideSpin: summary.side_spin || 0,
                                totalSpin: summary.total_spin || 0,
                                spinAxis: summary.spin_axis || 0,
                                club: playerInfo.Club || playerInfo.club || 'DR'
                            };
                            
                            if (shotData.speed > 0) {
                                console.log('Creating ball from shot summary:', shotData);
                                createBall(shotData);
                            }
                        } else if (message.Code === 201 && message.Player) {
                            // Store player info for next shot
                            console.log('Received player info:', message.Player);
                            window.lastPlayerInfo = message.Player;
                        }
                        
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                        console.log('Raw message:', event.data);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('Error', 'Connection failed');
                    alert('Failed to connect to GSPro log monitor. Make sure the log monitor script is running on ws://192.168.1.7:8080');
                    disconnectLive();
                };
                
                ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    disconnectLive();
                };
                
            } catch (error) {
                console.error('Failed to connect:', error);
                updateConnectionStatus('Error', 'Failed to connect');
                alert('Failed to connect to GSPro log monitor. Make sure the WebSocket server is running on ws://192.168.1.7:8080');
            }
        }

        function disconnectLive() {
            if (ws) {
                ws.close();
                ws = null;
            }
            isLiveMode = false;
            document.getElementById('connectBtn').textContent = 'Connect Live';
            document.getElementById('liveIndicator').classList.remove('connected');
            updateConnectionStatus('Disconnected', 'Not connected');
        }

        function launchDemoShot() {
            const shot = demoShots[Math.floor(Math.random() * demoShots.length)];
            createBall(shot);
        }

        function resetSimulation() {
            // Remove all balls and trails
            balls.forEach(ball => {
                scene.remove(ball);
                ball.trail.forEach(t => scene.remove(t));
            });
            balls = [];
            
            document.getElementById('shotInfo').style.display = 'none';
            document.getElementById('resultInfo').style.display = 'none';
            
            // Reset live distance display
            updateLiveDistance(0, 0, 0);
            
            // Clear canvases
            clearMinimap();
            clearTrajectoryDisplay();
        }

        // Weather system (simplified - no display)
        function updateWeatherDisplay() {
            // Internal weather for physics calculations only
        }

        function getWindArrow(degrees) {
            const arrows = ['â†‘', 'â†—', 'â†’', 'â†˜', 'â†“', 'â†™', 'â†', 'â†–'];
            const index = Math.round(degrees / 45) % 8;
            return arrows[index];
        }

        function randomizeWeather() {
            wind.speed = Math.random() * 20;
            wind.direction = Math.random() * 360;
            temperature = 60 + Math.random() * 30;
            humidity = 40 + Math.random() * 40;
            updateWeatherDisplay();
        }

        // Minimap
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            canvas.width = 200;
            canvas.height = 200;
            clearMinimap();
        }

        function clearMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 200, 200);
            
            // Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 200; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 200);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(200, i);
                ctx.stroke();
            }
            
            // Center point (tee)
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(98, 180, 4, 4);
        }

        function updateMinimap(ball) {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // Scale: 1 pixel = 2 yards
            const scale = 0.5;
            const centerX = 100;
            const centerY = 180;
            
            // Ball position
            const x = centerX + ball.position.x / 0.9144 * scale;
            const y = centerY + ball.position.z / 0.9144 * scale;
            
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Shot trajectory display
        function initTrajectoryDisplay() {
            const canvas = document.getElementById('shotTrajectory');
            canvas.width = 300;
            canvas.height = 150;
            clearTrajectoryDisplay();
        }

        function clearTrajectoryDisplay() {
            const canvas = document.getElementById('shotTrajectory');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 300, 150);
            
            // Axes
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, 130);
            ctx.lineTo(280, 130);
            ctx.moveTo(20, 130);
            ctx.lineTo(20, 20);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#FFF';
            ctx.font = '12px Arial';
            ctx.fillText('Distance (yds)', 120, 145);
            ctx.save();
            ctx.translate(10, 80);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Height (ft)', 0, 0);
            ctx.restore();
        }

        function updateTrajectoryDisplay(ball) {
            const canvas = document.getElementById('shotTrajectory');
            const ctx = canvas.getContext('2d');
            
            // Scale factors
            const xScale = 260 / 300; // pixels per yard
            const yScale = 100 / 150; // pixels per foot
            
            const x = 20 + (-ball.position.z / 0.9144) * xScale;
            const y = 130 - (ball.position.y * 3.28084) * yScale;
            
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(x - 1, y - 1, 2, 2);
        }

        // Collapseable Section Functions
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const arrow = document.getElementById(sectionId + 'Arrow');

            if (section.style.display === 'none' || section.style.display === '') {
                section.style.display = 'flex';
                if (arrow) arrow.textContent = 'â–¼';
            } else {
                section.style.display = 'none';
                if (arrow) arrow.textContent = 'â–¶';
            }
        }

        // Mode Functions
        function setPracticeMode() {
            isDerbyMode = false;
            isBaseballMode = false;
            document.getElementById('practiceModeBtn').style.background = '#4CAF50';
            document.getElementById('derbyModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('baseballModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('derbyStats').style.display = 'none';
            document.getElementById('baseballStats').style.display = 'none';
            document.getElementById('newGameSection').style.display = 'none';
            console.log('Practice Mode activated');
        }

        function setDerbyMode() {
            isDerbyMode = true;
            isBaseballMode = false;
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('derbyModeBtn').style.background = '#dc2626';
            document.getElementById('baseballModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('derbyStats').style.display = 'block';
            document.getElementById('baseballStats').style.display = 'none';

            // Load longest drive from localStorage
            const savedRecord = localStorage.getItem('homeRunDerbyLongestDrive');
            if (savedRecord) {
                derbyLongestDrive = JSON.parse(savedRecord);
            }

            // Start new game
            startNewGame();
            showNotification('âš¾ Derby Mode Started! 10 strikes and you\'re out!');
        }

        function setBaseballMode() {
            isDerbyMode = false;
            isBaseballMode = true;
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('derbyModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('baseballModeBtn').style.background = '#2563eb';
            document.getElementById('derbyStats').style.display = 'none';
            document.getElementById('baseballStats').style.display = 'block';

            // Start new baseball game
            startBaseballGame();
            showNotification('âš¾ Baseball Game Started!\nPlay ball!');
        }

        function startBaseballGame() {
            baseballGame = {
                inning: 1,
                topOfInning: true,
                outs: 0,
                score: { away: 0, home: 0 },
                bases: { first: null, second: null, third: null },
                atBat: 'Away Team',
                gameOver: false
            };
            updateBaseballDisplay();
            document.getElementById('newGameSection').style.display = 'none';
            console.log('Baseball game started');
        }

        function updateBaseballDisplay() {
            const inningText = baseballGame.topOfInning ?
                `Top ${getOrdinal(baseballGame.inning)}` :
                `Bottom ${getOrdinal(baseballGame.inning)}`;
            document.getElementById('baseballInning').textContent = inningText;
            document.getElementById('baseballOuts').textContent = baseballGame.outs;
            document.getElementById('baseballScore').textContent = `Away ${baseballGame.score.away} - Home ${baseballGame.score.home}`;

            // Update base indicators
            const base1 = document.getElementById('base1');
            const base2 = document.getElementById('base2');
            const base3 = document.getElementById('base3');

            base1.style.background = baseballGame.bases.first ? '#FFD700' : '#333';
            base2.style.background = baseballGame.bases.second ? '#FFD700' : '#333';
            base3.style.background = baseballGame.bases.third ? '#FFD700' : '#333';

            // Update scoreboard
            updateScoreboardBaseball();
        }

        function updateScoreboardBaseball() {
            if (!isBaseballMode) return;

            const ctx = window.scoreboardCtx;
            if (!ctx) return;

            // Clear with dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 1024, 256);

            // Draw inning at top
            const inningText = baseballGame.topOfInning ?
                `TOP ${getOrdinal(baseballGame.inning).toUpperCase()}` :
                `BOTTOM ${getOrdinal(baseballGame.inning).toUpperCase()}`;
            ctx.fillStyle = '#2563eb';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(inningText, 512, 10);

            // Draw score
            ctx.font = 'bold 70px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${baseballGame.score.away} - ${baseballGame.score.home}`, 512, 100);

            // Draw Away/Home labels
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = '#aaaaaa';
            ctx.textAlign = 'left';
            ctx.fillText('AWAY', 250, 100);
            ctx.textAlign = 'right';
            ctx.fillText('HOME', 774, 100);

            // Draw outs
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#dc2626';
            ctx.textAlign = 'center';
            ctx.fillText(`${baseballGame.outs} OUTS`, 512, 170);

            // Draw bases
            const baseSize = 25;
            const baseY = 220;
            const spacing = 35;

            // First base
            ctx.save();
            ctx.translate(400, baseY);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = baseballGame.bases.first ? '#FFD700' : '#444444';
            ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
            ctx.restore();

            // Second base
            ctx.save();
            ctx.translate(400 + spacing, baseY);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = baseballGame.bases.second ? '#FFD700' : '#444444';
            ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
            ctx.restore();

            // Third base
            ctx.save();
            ctx.translate(400 + spacing * 2, baseY);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = baseballGame.bases.third ? '#FFD700' : '#444444';
            ctx.fillRect(-baseSize / 2, -baseSize / 2, baseSize, baseSize);
            ctx.restore();

            // Base labels
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('1', 400, baseY + 30);
            ctx.fillText('2', 400 + spacing, baseY + 30);
            ctx.fillText('3', 400 + spacing * 2, baseY + 30);

            // Update texture
            if (window.scoreboardTexture) {
                window.scoreboardTexture.needsUpdate = true;
            }
        }

        function startNewGame() {
            // Reset game stats
            derbyStrikes = 0;
            derbyHomeRuns = 0;
            derbyGameOver = false;

            // Load longest drive from localStorage (don't reset it)
            const savedRecord = localStorage.getItem('homeRunDerbyLongestDrive');
            if (savedRecord) {
                derbyLongestDrive = JSON.parse(savedRecord);
            }

            // Update display
            updateDerbyDisplay();
            document.getElementById('newGameSection').style.display = 'none';

            console.log('New Derby game started - Strikes: 0, Home Runs: 0, Longest Drive:', derbyLongestDrive.distance, 'yds by', derbyLongestDrive.playerName);
        }

        function updateDerbyDisplay() {
            document.getElementById('derbyStrikes').textContent = `${derbyStrikes}/${MAX_STRIKES}`;
            document.getElementById('derbyHomeRuns').textContent = derbyHomeRuns;
            document.getElementById('derbyLongestDrive').textContent = `${derbyLongestDrive.distance.toFixed(0)} yds`;
            document.getElementById('derbyLongestDrivePlayer').textContent = derbyLongestDrive.playerName;

            // Update scoreboard to show strikes
            const playerName = window.currentPlayerName || null;
            updateScoreboardWithStrikes(playerName);
        }

        function updateScoreboardWithStrikes(playerName) {
            if (!isDerbyMode) return;

            const ctx = window.scoreboardCtx;
            if (!ctx) return;

            // Clear with dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 1024, 256);

            // Draw player name at top if provided
            if (playerName) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 45px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(playerName, 512, 10);
            }

            // Draw strikes in large text
            ctx.fillStyle = derbyStrikes >= MAX_STRIKES ? '#ff0000' : '#ffff00'; // Red if maxed out
            ctx.font = 'bold 65px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`STRIKES: ${derbyStrikes}/${MAX_STRIKES}`, 512, playerName ? 95 : 70);

            // Draw home runs below
            ctx.font = 'bold 45px Arial';
            ctx.fillStyle = '#00ff00'; // Green for home runs
            ctx.textAlign = 'center';
            ctx.fillText(`HOME RUNS: ${derbyHomeRuns}`, 512, playerName ? 150 : 125);

            // Draw longest drive at bottom
            ctx.font = 'bold 35px Arial';
            ctx.fillStyle = '#FFD700'; // Gold for record
            ctx.textAlign = 'center';
            ctx.fillText(`LONGEST: ${derbyLongestDrive.distance.toFixed(0)} YDS`, 300, playerName ? 210 : 185);

            // Draw record holder name
            ctx.font = 'bold 25px Arial';
            ctx.fillStyle = '#aaaaaa';
            ctx.fillText(derbyLongestDrive.playerName, 300, playerName ? 240 : 215);

            // Update texture
            if (window.scoreboardTexture) {
                window.scoreboardTexture.needsUpdate = true;
            }
        }

        function recordStrike(reason) {
            if (!isDerbyMode || derbyGameOver) return;

            derbyStrikes++;
            updateDerbyDisplay();

            showNotification(`âŒ STRIKE! ${reason}`);
            console.log(`Strike recorded: ${reason} (${derbyStrikes}/${MAX_STRIKES})`);

            if (derbyStrikes >= MAX_STRIKES) {
                gameOver();
            }
        }

        function recordHomeRun(distance) {
            if (!isDerbyMode || derbyGameOver) return;

            derbyHomeRuns++;

            // Check for new longest drive
            const currentPlayer = window.currentPlayerName || 'Player 1';
            if (distance > derbyLongestDrive.distance) {
                derbyLongestDrive = { distance: distance, playerName: currentPlayer };
                localStorage.setItem('homeRunDerbyLongestDrive', JSON.stringify(derbyLongestDrive));
                showNotification(`ðŸ† HOME RUN! NEW RECORD!\n${distance.toFixed(0)} yds by ${currentPlayer}! ðŸ†`);
                console.log(`NEW LONGEST DRIVE: ${distance.toFixed(0)} yds by ${currentPlayer}`);
            } else {
                showNotification(`âš¾ HOME RUN! ${distance.toFixed(0)} yds âš¾`);
            }

            updateDerbyDisplay();
            console.log(`Home run recorded! Total: ${derbyHomeRuns}, Distance: ${distance.toFixed(0)} yds`);
        }

        function gameOver() {
            derbyGameOver = true;
            document.getElementById('newGameSection').style.display = 'block';

            const message = `GAME OVER!\n\nHome Runs: ${derbyHomeRuns}\n\nLongest Drive:\n${derbyLongestDrive.distance.toFixed(0)} yds by ${derbyLongestDrive.playerName}`;
            showNotification(message, 5000);
            console.log('Derby game over:', { homeRuns: derbyHomeRuns, longestDrive: derbyLongestDrive });
        }

        function showNotification(message, duration = 2500) {
            const existing = document.getElementById('derbyNotification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'derbyNotification';
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 32px;
                font-weight: bold;
                z-index: 2000;
                box-shadow: 0 8px 16px rgba(0,0,0,0.5);
                text-align: center;
                border: 3px solid #4CAF50;
                white-space: pre-line;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, duration);
        }

        // Baseball Mode Functions
        function classifyHit(ball, totalDistanceYards, ballDistance, wallDistance, wallHeight) {
            // Calculate angle from home plate
            const angleDeg = Math.atan2(ball.position.x, -ball.position.z) * 180 / Math.PI;

            // Foul ball check (outside -45Â° to 45Â°)
            if (angleDeg > 45 || angleDeg < -45) {
                return { type: 'foul', distance: totalDistanceYards };
            }

            // Home run - ONLY if cleared the wall (distance AND height)
            if (ballDistance >= wallDistance && ball.maxHeight >= wallHeight) {
                return { type: 'homerun', distance: totalDistanceYards };
            }

            // Ground-rule double - hit the wall but didn't clear it
            if (ballDistance >= wallDistance * 0.95 && ball.maxHeight < wallHeight) {
                return { type: 'double', distance: totalDistanceYards, groundRule: true };
            }

            // Generate random number for outcome determination (0-100)
            const rand = Math.random() * 100;

            // Outs Range (< 75 yards): 85% out, 15% single
            if (totalDistanceYards < 75) {
                if (rand < 85) {
                    return { type: 'out', distance: totalDistanceYards };
                } else {
                    return { type: 'single', distance: totalDistanceYards };
                }
            }

            // Singles Range (75-125 yards): 15% out, 70% single, 15% double
            if (totalDistanceYards < 126) {
                if (rand < 15) {
                    return { type: 'out', distance: totalDistanceYards };
                } else if (rand < 85) { // 15 + 70
                    return { type: 'single', distance: totalDistanceYards };
                } else {
                    return { type: 'double', distance: totalDistanceYards };
                }
            }

            // Doubles Range (126-175 yards): 5% out, 20% single, 65% double, 10% triple
            if (totalDistanceYards < 176) {
                if (rand < 5) {
                    return { type: 'out', distance: totalDistanceYards };
                } else if (rand < 25) { // 5 + 20
                    return { type: 'single', distance: totalDistanceYards };
                } else if (rand < 90) { // 5 + 20 + 65
                    return { type: 'double', distance: totalDistanceYards };
                } else {
                    return { type: 'triple', distance: totalDistanceYards };
                }
            }

            // Triples Range (176+ yards, doesn't clear wall): 5% out, 5% single, 35% double, 55% triple
            if (rand < 5) {
                return { type: 'out', distance: totalDistanceYards };
            } else if (rand < 10) { // 5 + 5
                return { type: 'single', distance: totalDistanceYards };
            } else if (rand < 45) { // 5 + 5 + 35
                return { type: 'double', distance: totalDistanceYards };
            } else {
                return { type: 'triple', distance: totalDistanceYards };
            }
        }

        function advanceRunners(hitType) {
            const team = baseballGame.topOfInning ? 'away' : 'home';
            const batter = baseballGame.atBat;
            let runsScored = 0;

            console.log(`Advancing runners for ${hitType}, bases before:`, JSON.parse(JSON.stringify(baseballGame.bases)));

            if (hitType === 'homerun') {
                // Everyone scores including batter
                if (baseballGame.bases.third) runsScored++;
                if (baseballGame.bases.second) runsScored++;
                if (baseballGame.bases.first) runsScored++;
                runsScored++; // Batter scores
                baseballGame.bases = { first: null, second: null, third: null };
            } else if (hitType === 'triple') {
                // All runners score, batter to 3rd
                if (baseballGame.bases.third) runsScored++;
                if (baseballGame.bases.second) runsScored++;
                if (baseballGame.bases.first) runsScored++;
                baseballGame.bases = { first: null, second: null, third: batter };
            } else if (hitType === 'double') {
                // Runners on 3rd and 2nd score, runner on 1st to 3rd, batter to 2nd
                if (baseballGame.bases.third) runsScored++;
                if (baseballGame.bases.second) runsScored++;
                const runner1 = baseballGame.bases.first;
                baseballGame.bases = { first: null, second: batter, third: runner1 };
            } else if (hitType === 'single') {
                // Runner on 3rd scores, others advance 1 base
                if (baseballGame.bases.third) runsScored++;
                const runner2 = baseballGame.bases.second;
                const runner1 = baseballGame.bases.first;
                baseballGame.bases = { first: batter, second: runner1, third: runner2 };
            }

            // Add runs to score
            if (team === 'away') {
                baseballGame.score.away += runsScored;
            } else {
                baseballGame.score.home += runsScored;
            }

            console.log(`Runs scored: ${runsScored}, bases after:`, JSON.parse(JSON.stringify(baseballGame.bases)));
            console.log(`Score: Away ${baseballGame.score.away} - Home ${baseballGame.score.home}`);

            return runsScored;
        }

        function recordOut() {
            baseballGame.outs++;
            console.log(`Out recorded! Total outs: ${baseballGame.outs}`);

            if (baseballGame.outs >= 3) {
                changeSides();
            }
        }

        function changeSides() {
            console.log('Changing sides - 3 outs');
            baseballGame.outs = 0;
            baseballGame.bases = { first: null, second: null, third: null };

            if (baseballGame.topOfInning) {
                // Was top of inning, now bottom
                baseballGame.topOfInning = false;
                baseballGame.atBat = 'Home Team';
                showNotification(`Bottom ${getOrdinal(baseballGame.inning)}\nHome team batting`);
            } else {
                // Was bottom of inning, advance to next inning
                baseballGame.inning++;
                baseballGame.topOfInning = true;
                baseballGame.atBat = 'Away Team';

                if (baseballGame.inning > 9) {
                    endBaseballGame();
                } else {
                    showNotification(`Top ${getOrdinal(baseballGame.inning)}\nAway team batting`);
                }
            }

            updateBaseballDisplay();
        }

        function endBaseballGame() {
            baseballGame.gameOver = true;
            document.getElementById('newGameSection').style.display = 'block';

            const winner = baseballGame.score.away > baseballGame.score.home ? 'Away Team' :
                           baseballGame.score.home > baseballGame.score.away ? 'Home Team' : 'Tie';
            const message = `GAME OVER!\n\nFinal Score:\nAway ${baseballGame.score.away} - Home ${baseballGame.score.home}\n\n${winner === 'Tie' ? 'It\'s a tie!' : winner + ' Wins!'}`;
            showNotification(message, 5000);
            console.log('Baseball game over:', baseballGame);
        }

        function restartGame() {
            if (isDerbyMode) {
                startNewGame();
            } else if (isBaseballMode) {
                startBaseballGame();
            }
        }

        // Check if ball is a home run or foul
        function checkShotResult(ball) {
            if (isDerbyMode && !derbyGameOver) {
                // Derby Mode logic (existing code)
                checkShotResultDerby(ball);
            } else if (isBaseballMode && !baseballGame.gameOver) {
                // Baseball Mode logic
                checkShotResultBaseball(ball);
            }
        }

        function checkShotResultDerby(ball) {
            // Prevent duplicate checks
            if (ball.resultChecked) return;
            ball.resultChecked = true;

            // Get ball's final position
            const ballX = ball.position.x;
            const ballZ = ball.position.z;
            const ballY = ball.position.y;

            // Calculate total distance in yards (use the calibrated distance from the ball object)
            const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);
            const forwardMeters = Math.abs(ball.position.z);
            const lateralMeters = Math.abs(ball.position.x);
            const forwardYards = (forwardMeters / 0.9144) * multipliers.distance;
            const lateralYards = (lateralMeters / 0.9144) * multipliers.distance;
            const totalDistanceYards = Math.sqrt(forwardYards * forwardYards + lateralYards * lateralYards);

            console.log('Checking shot result - Position:', { x: ballX, z: ballZ, maxHeight: ball.maxHeight });
            console.log('Total distance:', totalDistanceYards.toFixed(1), 'yards');

            // Calculate angle from home plate (-45Â° to 45Â° is fair territory)
            const angleDeg = Math.atan2(ballX, -ballZ) * 180 / Math.PI;
            console.log('Ball angle from home plate:', angleDeg.toFixed(1), 'Â°');

            // Foul ball check (outside -45Â° to 45Â°)
            if (angleDeg > 45 || angleDeg < -45) {
                console.log('FOUL BALL - outside fair territory');
                recordStrike('Foul Ball');
                return;
            }

            // Get wall distance and height at this angle
            const distanceToWall = getWallDistanceAtAngle(angleDeg);
            const wallHeight = getWallHeightAtAngle(angleDeg);
            const ballDistance = Math.sqrt(ballX * ballX + ballZ * ballZ);

            console.log('Wall check - Ball distance:', ballDistance.toFixed(1), 'm, Wall distance:', distanceToWall.toFixed(1), 'm');
            console.log('Height check - Ball max height:', ball.maxHeight.toFixed(1), 'm, Wall height:', wallHeight.toFixed(1), 'm');

            // Check if ball cleared the wall (home run)
            if (ballDistance >= distanceToWall && ball.maxHeight >= wallHeight) {
                console.log('HOME RUN! Cleared the wall!');
                recordHomeRun(totalDistanceYards);
            } else {
                console.log('DID NOT CLEAR WALL');
                recordStrike('Did not clear wall');
            }
        }

        function checkShotResultBaseball(ball) {
            // Prevent duplicate checks
            if (ball.resultChecked) return;
            ball.resultChecked = true;

            // Get ball's final position
            const ballX = ball.position.x;
            const ballZ = ball.position.z;

            // Calculate total distance in yards
            const multipliers = getScalingMultipliers(ball.ballSpeed || 150, ball.sideAngle || 0);
            const forwardMeters = Math.abs(ball.position.z);
            const lateralMeters = Math.abs(ball.position.x);
            const forwardYards = (forwardMeters / 0.9144) * multipliers.distance;
            const lateralYards = (lateralMeters / 0.9144) * multipliers.distance;
            const totalDistanceYards = Math.sqrt(forwardYards * forwardYards + lateralYards * lateralYards);

            // Get wall distance and height
            const angleDeg = Math.atan2(ballX, -ballZ) * 180 / Math.PI;
            const distanceToWall = getWallDistanceAtAngle(angleDeg);
            const wallHeight = getWallHeightAtAngle(angleDeg);
            const ballDistance = Math.sqrt(ballX * ballX + ballZ * ballZ);

            // Classify the hit
            const hit = classifyHit(ball, totalDistanceYards, ballDistance, distanceToWall, wallHeight);

            console.log(`Baseball hit classified: ${hit.type} - ${hit.distance.toFixed(1)} yards`);

            // Handle the result
            if (hit.type === 'foul') {
                // Foul ball - counts as a strike in baseball (but not strike 3)
                showNotification(`âš¾ FOUL BALL âš¾\n${hit.distance.toFixed(0)} yards`);
            } else if (hit.type === 'out') {
                recordOut();
                showNotification(`âŒ OUT! âŒ\n${hit.distance.toFixed(0)} yards`);
                updateBaseballDisplay();
            } else {
                // It's a hit! Advance runners
                const runsScored = advanceRunners(hit.type);
                const hitName = hit.type.charAt(0).toUpperCase() + hit.type.slice(1);

                // Special message for ground-rule double
                let hitDisplay = hitName.toUpperCase();
                if (hit.groundRule) {
                    hitDisplay = 'GROUND-RULE DOUBLE';
                }

                let message = `âœ… ${hitDisplay}! âœ…\n${hit.distance.toFixed(0)} yards`;
                if (runsScored > 0) {
                    message += `\n${runsScored} run${runsScored > 1 ? 's' : ''} scored!`;
                }
                showNotification(message, 2500);
                updateBaseballDisplay();
            }
        }

        function getWallDistanceAtAngle(angleDeg) {
            // Wall distances from createOutfieldWalls
            const dimensions = {
                left: 325 * 0.3048,           // 99.06 meters at 45Â°
                leftCenter: 370 * 0.3048,     // 112.78 meters at 22.5Â°
                center: 405 * 0.3048,         // 123.44 meters at 0Â°
                rightCenter: 375 * 0.3048,    // 114.30 meters at -22.5Â°
                right: 325 * 0.3048           // 99.06 meters at -45Â°
            };

            // Interpolate distance based on angle
            if (angleDeg >= 22.5) {
                // Between left field and left-center
                const t = (angleDeg - 22.5) / 22.5;
                return dimensions.left + (dimensions.leftCenter - dimensions.left) * (1 - t);
            } else if (angleDeg >= 0) {
                // Between left-center and center
                const t = angleDeg / 22.5;
                return dimensions.leftCenter + (dimensions.center - dimensions.leftCenter) * (1 - t);
            } else if (angleDeg >= -22.5) {
                // Between center and right-center
                const t = (angleDeg + 22.5) / 22.5;
                return dimensions.center + (dimensions.rightCenter - dimensions.center) * (1 - t);
            } else {
                // Between right-center and right field
                const t = (angleDeg + 45) / 22.5;
                return dimensions.rightCenter + (dimensions.right - dimensions.rightCenter) * (1 - t);
            }
        }

        function getWallHeightAtAngle(angleDeg) {
            // Wall heights (in meters)
            const littleGreenMonster = 19 * 0.3048;  // 5.79 meters at left field (45Â°)
            const standardWall = 9 * 0.3048;         // 2.74 meters elsewhere

            // Left field has taller wall
            if (angleDeg >= 22.5) {
                const t = (angleDeg - 22.5) / 22.5;
                return littleGreenMonster + (standardWall - littleGreenMonster) * (1 - t);
            }
            return standardWall;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // Fixed timestep
            
            // Update physics
            updateBalls(deltaTime);
            
            // Update camera for follow modes
            if ((currentView === 'follow' || currentView === 'auto-follow') && balls.length > 0) {
                updateCameraPosition();
            }
            
            renderer.render(scene, camera);
        }

        // Initialize everything
        init();
        animate();

        // Show/hide debug panel based on DEBUG_MODE
        if (DEBUG_MODE) {
            document.getElementById('debugSection').style.display = 'block';
            console.log('ðŸ”§ DEBUG MODE ENABLED - Test shot controls visible');
        }

        // Load longest drive record on page load
        const savedRecord = localStorage.getItem('homeRunDerbyLongestDrive');
        if (savedRecord) {
            derbyLongestDrive = JSON.parse(savedRecord);
            console.log('Loaded longest drive from localStorage:', derbyLongestDrive.distance, 'yds by', derbyLongestDrive.playerName);
        } else {
            console.log('No longest drive record found');
        }

        // Randomize weather every 30 seconds
        setInterval(randomizeWeather, 30000);
    </script>
</body>
</html>
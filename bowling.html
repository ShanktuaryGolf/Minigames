<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bowling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Scorecard positioned at top center */
        #scorecardContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid #FF6B35;
            min-width: 600px;
        }

        #controls h3 {
            margin-top: 0;
            color: #FF6B35;
            font-size: 18px;
            text-align: center;
            margin-bottom: 10px;
        }

        #controls h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        #controls button {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 8px 12px;
            flex: 1;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        #controls button:hover {
            background: #ff8555;
            transform: translateY(-2px);
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            opacity: 0.8;
        }

        .stat-value {
            font-weight: bold;
            color: #FF6B35;
            font-size: 13px;
        }

        #playerIndicator {
            background: rgba(255, 107, 53, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
            border: 2px solid #FF6B35;
        }

        #currentPlayerName {
            font-size: 15px;
            margin-top: 3px;
            font-weight: bold;
        }

        /* Scorecard styling */
        #scorecard {
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }

        .frame-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .frame {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px;
            text-align: center;
            border-radius: 4px;
        }

        .frame.active {
            border-color: #FF6B35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .frame-number {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 2px;
        }

        .frame-rolls {
            display: flex;
            justify-content: center;
            gap: 2px;
            font-size: 12px;
            min-height: 20px;
        }

        .roll-box {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            font-weight: bold;
        }

        .frame-score {
            font-size: 14px;
            font-weight: bold;
            color: #FF6B35;
            margin-top: 4px;
            min-height: 18px;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-value {
            display: inline-block;
            min-width: 60px;
            text-align: right;
            color: #FF6B35;
            font-weight: bold;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>üé≥ Bowling</h3>

        <div id="playerIndicator">
            <strong style="color: #FF6B35;">Current Player:</strong>
            <div id="currentPlayerName">Player 1</div>
        </div>

        <!-- Test Shot Panel - Hidden -->
        <div class="stat-section" style="background: rgba(255, 165, 0, 0.1); border: 1px solid #FF6B35; display: none;">
            <button onclick="toggleTestPanel()" style="width: 100%; background: transparent; border: none; color: #FF6B35; cursor: pointer; padding: 0; margin-bottom: 10px; text-align: left; font-size: 16px; font-weight: bold;">
                <span id="testPanelToggle">‚ñº</span> üß™ Test Shot
            </button>

            <div id="testPanelContent">
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">Ball Speed (mph):</label>
                    <input type="number" id="testSpeed" value="12" min="1" max="30" step="0.5"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">HLA (degrees):</label>
                    <input type="number" id="testHLA" value="0" min="-10" max="10" step="0.5"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 13px;">Sidespin (rpm):</label>
                    <input type="number" id="testSidespin" value="0" min="-500" max="500" step="10"
                           style="width: 100%; padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px;">
                </div>
                <button onclick="sendTestShot()" style="width: 100%; padding: 10px; background: #FF6B35; border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">
                    üé≥ Bowl Test Shot
                </button>
            </div>
        </div>

        <!-- Current Frame Info -->
        <div class="stat-section" style="background: rgba(255, 107, 53, 0.1); border: 1px solid #FF6B35;">
            <h4 style="color: #FF6B35; text-align: center;">Current Frame</h4>
            <div class="stat-row">
                <span class="stat-label">Frame:</span>
                <span class="stat-value" id="currentFrameNum">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Ball:</span>
                <span class="stat-value" id="currentBallNum">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Score:</span>
                <span class="stat-value" id="totalScore">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Pins Down:</span>
                <span class="stat-value" id="pinsDown">0</span>
            </div>
        </div>

        <div class="button-group">
            <button id="viewBtn" onclick="cycleView()">Change View</button>
            <button id="resetBtn" onclick="resetBall()">Reset Ball</button>
        </div>
        <div class="button-group">
            <button id="nextPlayerBtn" onclick="nextPlayer()" style="background: rgba(255, 107, 53, 0.5);">Next Player ‚Üí</button>
        </div>
        <div class="button-group">
            <button onclick="newGame()" style="background: #4CAF50;">New Game</button>
        </div>

        <div class="stat-section" style="background: rgba(255, 107, 53, 0.1); border: 1px solid #FF6B35;">
            <h4 style="color: #FF6B35; text-align: center;">Aiming</h4>
            <div class="stat-row">
                <span class="stat-label">Mode:</span>
                <span class="stat-value" id="aimingModeDisplay" style="text-transform: capitalize;">Position</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Ball Position:</span>
                <span class="stat-value" id="ballPositionDisplay">0.00m</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Aim Angle:</span>
                <span class="stat-value" id="aimAngleDisplay">0.0¬∞</span>
            </div>
            <div style="text-align: center; font-size: 11px; opacity: 0.7; margin-top: 5px;">
                ‚Üê ‚Üí to adjust | Y to confirm
            </div>
        </div>

        <div id="shotInfo" class="stat-section">
            <h4 style="color: #FF6B35;">Last Shot</h4>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="ballSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Hook:</span>
                <span class="stat-value" id="hookAngle">--</span>
            </div>
        </div>
    </div>

    <!-- Scorecard at top center -->
    <div id="scorecardContainer">
        <h4 style="color: #FF6B35; margin-bottom: 10px; text-align: center; font-size: 18px;">üé≥ Scorecard</h4>
        <div class="frame-container" id="frameContainer">
            <!-- Frames will be generated here -->
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script src="./steam-network-adapter.js"></script>
    <script type="module">
        // Import Cannon.js physics engine
        import * as CANNON from './cannon-es.js';

        // Global variables
        let scene, camera, renderer;

        // Steam Multiplayer
        let networkAdapter = null;
        let isNetworkGame = false;
        let isNetworkHost = false;
        let localSteamId = null;
        let ball, ballBody;
        let currentView = 'follow'; // 'behind', 'side', 'follow'
        let savedView = 'follow'; // Save the view before switching to pin camera
        let pinCameraActive = false;
        let pins = [];
        let pinBodies = []; // Cannon.js physics bodies for pins
        let lane, leftGutter, rightGutter;
        let leftBumper, rightBumper; // Visual bumper indicators
        let leftBumperBody, rightBumperBody; // Physics bodies for bumpers

        // Cannon.js physics world
        let world;

        // Ball physics
        const ballRadius = 0.108; // Bowling ball radius in meters (8.5 inch diameter / 2)
        const gravity = 9.81;
        let friction = 0.02; // Very low friction for bowling lane (oiled surface)
        const restitution = 0.3; // Low bounciness for bowling ball

        // Ball state
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let ballSpin = new THREE.Vector3(0, 0, 0);
        let isMoving = false;
        let lastTime = performance.now();
        let adjacentBalls = []; // For adjacent lane animations

        // Lane dimensions (in meters)
        const laneLength = 18.288; // 60 feet
        const laneWidth = 1.067; // 3.5 feet (42 inches)
        const gutterWidth = 0.23; // 9 inches each side

        // Pin dimensions and positions
        const pinHeight = 0.381; // 15 inches
        const pinRadius = 0.06; // ~2.4 inches (at widest point)
        const pinSpacing = 0.305; // 12 inches center to center

        // Players
        window.bowlingPlayers = [];
        window.currentPlayerIndex = 0;

        // Bowling game state
        let currentFrame = 1;
        let currentBall = 1; // 1 or 2 (or 3 in 10th frame)
        let frames = []; // Array of frame objects
        let pinsStanding = 10;
        let pinsKnockedThisFrame = [];
        let gameOver = false;

        // Aiming system
        let aimAngle = 0; // Horizontal aim angle in degrees (-10 to +10)
        let ballPosition = 0; // Lateral position on lane in meters (-0.4 to +0.4)
        let aimingMode = 'position'; // 'position' or 'angle'
        let aimingArrow = null; // Visual aiming indicator
        let lastAimingMode = null;
        const tempUpVector = new THREE.Vector3();

        init();
        animate();

        function init() {
            // Initialize Cannon.js physics world
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0); // Earth gravity
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.broadphase.axisIndex = 2;
            world.allowSleep = true;
            world.sleepSpeedLimit = 0.15;
            world.sleepTimeLimit = 0.5;
            world.solver.iterations = 8;
            world.defaultContactMaterial.friction = 0.3;
            world.defaultContactMaterial.restitution = 0.4;

            // Create ground plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0, // Static body
                shape: groundShape,
                material: new CANNON.Material('ground')
            });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to be horizontal
            world.addBody(groundBody);

            // Set up contact materials for realistic friction
            const groundMaterial = new CANNON.Material('ground');
            const ballMaterial = new CANNON.Material('ball');
            const pinMaterial = new CANNON.Material('pin');

            // Ball-ground contact (wood lane)
            const ballGroundContact = new CANNON.ContactMaterial(ballMaterial, groundMaterial, {
                friction: 0.08, // Low friction for bowling lane
                restitution: 0.3
            });
            world.addContactMaterial(ballGroundContact);

            // Pin-ground contact
            const pinGroundContact = new CANNON.ContactMaterial(pinMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.3
            });
            world.addContactMaterial(pinGroundContact);

            // Ball-pin contact (very low restitution to prevent backward bouncing)
            const ballPinContact = new CANNON.ContactMaterial(ballMaterial, pinMaterial, {
                friction: 0.2,
                restitution: 0.1  // Very low bounce - ball should not bounce back
            });
            world.addContactMaterial(ballPinContact);

            // Pin-pin contact
            const pinPinContact = new CANNON.ContactMaterial(pinMaterial, pinMaterial, {
                friction: 0.3,
                restitution: 0.4
            });
            world.addContactMaterial(pinPinContact);

            // Initialize frames
            for (let i = 0; i < 10; i++) {
                frames.push({
                    rolls: [],
                    score: null,
                    isStrike: false,
                    isSpare: false
                });
            }

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); // Dark bowling alley

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            // Load Visual Offset from localStorage (for projector alignment)
            let visualOffsetX = 0;
            let visualOffsetY = 0;
            const savedOffsetX = localStorage.getItem('golfVisualOffsetX');
            const savedOffsetY = localStorage.getItem('golfVisualOffsetY');
            if (savedOffsetX) visualOffsetX = parseInt(savedOffsetX);
            if (savedOffsetY) visualOffsetY = parseInt(savedOffsetY);

            // Apply visual offset to camera
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                camera.setViewOffset(window.innerWidth, window.innerHeight, visualOffsetX, visualOffsetY, window.innerWidth, window.innerHeight);
            }

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.shadowMap.autoUpdate = false;
            renderer.shadowMap.needsUpdate = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Overhead lights (like bowling alley)
            for (let i = 0; i < 5; i++) {
                const light = new THREE.PointLight(0xffffee, 0.6, 20);
                light.position.set(0, 5, -laneLength/2 + i * laneLength/4);
                light.castShadow = i === 2;
                if (light.castShadow) {
                    light.shadow.mapSize.width = 512;
                    light.shadow.mapSize.height = 512;
                    light.shadow.bias = -0.0005;
                }
                scene.add(light);
            }

            createLane();
            createAdjacentLanes(); // Add side lanes for atmosphere
            createBowlingAlley(); // Add walls, ceiling, and decorations
            createBall();
            createPins();
            createScorecard();
            aimingArrow = createAimingArrow();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);

            // Check for Electron IPC
            if (window.electronAPI) {
                console.log('‚úì Running in Electron - IPC available');
                setupElectronIPC();
            } else {
                console.log('‚ö† Not running in Electron - standalone mode');
            }

            updateUI();
        }

        function onKeyDown(event) {
            // Only allow aiming when ball is not moving
            if (isMoving) return;

            const positionStep = 0.01; // Meters per keypress for ball position
            const maxPosition = 0.4; // Maximum lateral position (meters from center)
            const aimStep = 0.1; // Degrees per keypress for angle
            const maxAim = 10; // Maximum aim angle in degrees

            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Move ball to the left on the lane
                        ballPosition = Math.min(maxPosition, ballPosition + positionStep);
                        ball.position.x = ballPosition;
                        if (ballBody) ballBody.position.x = ballPosition;
                    } else {
                        // Adjust aim angle to the left
                        aimAngle = Math.min(maxAim, aimAngle + aimStep);
                    }
                    updateAimingArrow();
                    updateUI();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Move ball to the right on the lane
                        ballPosition = Math.max(-maxPosition, ballPosition - positionStep);
                        ball.position.x = ballPosition;
                        if (ballBody) ballBody.position.x = ballPosition;
                    } else {
                        // Adjust aim angle to the right
                        aimAngle = Math.max(-maxAim, aimAngle - aimStep);
                    }
                    updateAimingArrow();
                    updateUI();
                    break;
                case 'y':
                case 'Y':
                    event.preventDefault();
                    if (aimingMode === 'position') {
                        // Confirm position, switch to angle mode
                        aimingMode = 'angle';
                        updateUI();
                        showNotification('Position Locked - Now Aim Angle');
                    }
                    break;
            }
        }

        function createLane() {
            // Main bowling lane
            const laneGeometry = new THREE.BoxGeometry(laneWidth, 0.02, laneLength);
            const laneTexture = createLaneTexture();
            const laneMaterial = new THREE.MeshLambertMaterial({
                map: laneTexture
            });
            lane = new THREE.Mesh(laneGeometry, laneMaterial);
            lane.position.set(0, 0, -laneLength/2);
            lane.receiveShadow = true;
            scene.add(lane);

            // Left gutter
            const gutterGeometry = new THREE.BoxGeometry(gutterWidth, 0.05, laneLength);
            const gutterMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a3e });
            leftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftGutter.position.set(-laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            leftGutter.receiveShadow = true;
            scene.add(leftGutter);

            // Right gutter
            rightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightGutter.position.set(laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            rightGutter.receiveShadow = true;
            scene.add(rightGutter);

            // Approach area (behind the foul line)
            const approachGeometry = new THREE.BoxGeometry(laneWidth + gutterWidth * 2, 0.01, 4.572); // 15 feet
            const approachMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a4e });
            const approach = new THREE.Mesh(approachGeometry, approachMaterial);
            approach.position.set(0, -0.005, 2.286);
            approach.receiveShadow = true;
            scene.add(approach);

            // Left side carpet (beyond left gutter) - extends to wall
            // Calculate carpet width: from edge of gutter to wall
            const sideCarpetWidth = 8 - (laneWidth/2 + gutterWidth); // Distance from gutter edge to wall
            const leftCarpetTexture = createCarpetTexture();
            leftCarpetTexture.offset.set(Math.random(), Math.random()); // Random offset
            const leftCarpetGeometry = new THREE.PlaneGeometry(sideCarpetWidth, laneLength + 10);
            const leftCarpetMaterial = new THREE.MeshLambertMaterial({ map: leftCarpetTexture });
            const leftCarpet = new THREE.Mesh(leftCarpetGeometry, leftCarpetMaterial);
            leftCarpet.rotation.x = -Math.PI / 2;
            leftCarpet.position.set(-laneWidth/2 - gutterWidth - sideCarpetWidth/2, -0.01, -laneLength/2);
            leftCarpet.receiveShadow = true;
            scene.add(leftCarpet);

            // Right side carpet (beyond right gutter) - extends to wall
            const rightCarpetTexture = createCarpetTexture();
            rightCarpetTexture.offset.set(Math.random(), Math.random()); // Different random offset
            const rightCarpetGeometry = new THREE.PlaneGeometry(sideCarpetWidth, laneLength + 10);
            const rightCarpetMaterial = new THREE.MeshLambertMaterial({ map: rightCarpetTexture });
            const rightCarpet = new THREE.Mesh(rightCarpetGeometry, rightCarpetMaterial);
            rightCarpet.rotation.x = -Math.PI / 2;
            rightCarpet.position.set(laneWidth/2 + gutterWidth + sideCarpetWidth/2, -0.01, -laneLength/2);
            rightCarpet.receiveShadow = true;
            scene.add(rightCarpet);

            // Foul line
            const foulLineGeometry = new THREE.BoxGeometry(laneWidth, 0.03, 0.02);
            const foulLineMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const foulLine = new THREE.Mesh(foulLineGeometry, foulLineMaterial);
            foulLine.position.set(0, 0.015, 0);
            scene.add(foulLine);

            // Create bumpers (hidden by default)
            createBumpers();
        }

        function createBumpers() {
            const bumperHeight = 0.3; // 30cm high bumpers
            const bumperGeometry = new THREE.BoxGeometry(gutterWidth, bumperHeight, laneLength);
            const bumperMaterial = new THREE.MeshLambertMaterial({
                color: 0xff6600 // Orange color
            });

            // Left bumper (visual)
            leftBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            leftBumper.position.set(-laneWidth/2 - gutterWidth/2, bumperHeight/2, -laneLength/2);
            leftBumper.visible = false; // Hidden by default
            scene.add(leftBumper);

            // Left bumper (physics body)
            const leftBumperShape = new CANNON.Box(new CANNON.Vec3(gutterWidth/2, bumperHeight/2, laneLength/2));
            leftBumperBody = new CANNON.Body({
                mass: 0, // Static body
                shape: leftBumperShape,
                position: new CANNON.Vec3(-laneWidth/2 - gutterWidth/2, bumperHeight/2, -laneLength/2),
                material: new CANNON.Material({ restitution: 0.6, friction: 0.1 }) // Bouncy!
            });
            // Don't add to world yet - will be added when bumpers are enabled

            // Right bumper (visual)
            rightBumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            rightBumper.position.set(laneWidth/2 + gutterWidth/2, bumperHeight/2, -laneLength/2);
            rightBumper.visible = false; // Hidden by default
            scene.add(rightBumper);

            // Right bumper (physics body)
            const rightBumperShape = new CANNON.Box(new CANNON.Vec3(gutterWidth/2, bumperHeight/2, laneLength/2));
            rightBumperBody = new CANNON.Body({
                mass: 0, // Static body
                shape: rightBumperShape,
                position: new CANNON.Vec3(laneWidth/2 + gutterWidth/2, bumperHeight/2, -laneLength/2),
                material: new CANNON.Material({ restitution: 0.6, friction: 0.1 }) // Bouncy!
            });
            // Don't add to world yet - will be added when bumpers are enabled
        }

        function updateBumperVisibility() {
            // Make sure players and player data exist
            if (!window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];
            const bumpersEnabled = currentPlayer && currentPlayer.bumpers;

            // Update visual bumpers
            if (leftBumper && rightBumper) {
                leftBumper.visible = bumpersEnabled;
                rightBumper.visible = bumpersEnabled;
            }

            // Update physics bumpers - add/remove from world
            if (leftBumperBody && rightBumperBody && world) {
                if (bumpersEnabled) {
                    // Add bumper bodies to physics world if not already added
                    if (!world.bodies.includes(leftBumperBody)) {
                        world.addBody(leftBumperBody);
                    }
                    if (!world.bodies.includes(rightBumperBody)) {
                        world.addBody(rightBumperBody);
                    }
                } else {
                    // Remove bumper bodies from physics world
                    if (world.bodies.includes(leftBumperBody)) {
                        world.removeBody(leftBumperBody);
                    }
                    if (world.bodies.includes(rightBumperBody)) {
                        world.removeBody(rightBumperBody);
                    }
                }
            }

            // Also change gutter color based on bumper status
            if (leftGutter && rightGutter) {
                const gutterColor = bumpersEnabled ? 0xff6600 : 0x2a2a3e; // Orange when bumpers on, dark when off
                leftGutter.material.color.setHex(gutterColor);
                rightGutter.material.color.setHex(gutterColor);
            }
        }

        // Adjacent lanes for atmosphere
        function createAdjacentPins(xOffset) {
            const pinMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const pinSpacing = 0.305; // 12 inches
            const startZ = -laneLength + 1;

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col <= row; col++) {
                    const pinGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.38, 8);
                    const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                    const x = xOffset + (col - row / 2) * pinSpacing;
                    const z = startZ - row * pinSpacing;
                    pin.position.set(x, 0.19, z);
                    pin.castShadow = false;
                    pin.receiveShadow = false;
                    scene.add(pin);
                }
            }
        }

        function createAdjacentBall(xOffset) {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 16, 16);
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 100
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(xOffset, ballRadius, 0);
            ball.castShadow = false;
            ball.receiveShadow = false;
            scene.add(ball);

            adjacentBalls.push({
                mesh: ball,
                xOffset: xOffset,
                velocity: 0,
                isMoving: false,
                nextShotTime: Date.now() + Math.random() * 5000 + 3000, // Random delay 3-8 seconds
                lastPosition: 0,
                stuckTimer: 0
            });
        }

        function updateAdjacentBalls() {
            const currentTime = Date.now();

            adjacentBalls.forEach(ballData => {
                if (!ballData.isMoving && currentTime >= ballData.nextShotTime) {
                    // Start a new shot
                    ballData.isMoving = true;
                    ballData.velocity = 12 + Math.random() * 6; // Random speed 12-18 m/s (enough to reach end)
                    ballData.mesh.position.set(
                        ballData.xOffset + (Math.random() - 0.5) * 0.3, // Slight variation
                        ballRadius,
                        0
                    );
                }

                if (ballData.isMoving) {
                    // Move ball down lane
                    ballData.mesh.position.z -= ballData.velocity * 0.016;
                    ballData.velocity *= 0.99; // Slow down slightly

                    // Check if ball is stuck (hasn't moved much)
                    const positionChange = Math.abs(ballData.mesh.position.z - ballData.lastPosition);
                    if (positionChange < 0.01) {
                        // Ball is stuck or moving very slowly
                        ballData.stuckTimer += 16; // Add ~16ms (one frame)
                        if (ballData.stuckTimer > 1500) {
                            // Stuck for more than 1.5 seconds, reset
                            ballData.isMoving = false;
                            ballData.mesh.position.z = 0;
                            ballData.nextShotTime = currentTime + Math.random() * 8000 + 4000;
                            ballData.stuckTimer = 0;
                        }
                    } else {
                        // Ball is moving, reset stuck timer
                        ballData.stuckTimer = 0;
                    }
                    ballData.lastPosition = ballData.mesh.position.z;

                    // Reset when ball reaches end
                    if (ballData.mesh.position.z < -laneLength) {
                        ballData.isMoving = false;
                        ballData.mesh.position.z = 0;
                        ballData.nextShotTime = currentTime + Math.random() * 8000 + 4000; // Next shot in 4-12 seconds
                        ballData.stuckTimer = 0;
                    }
                }
            });
        }

        function createAdjacentLanes() {
            // Reuse same texture creation logic inline
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 512, 0);
            gradient.addColorStop(0, '#d4a373');
            gradient.addColorStop(0.5, '#c89968');
            gradient.addColorStop(1, '#d4a373');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const length = Math.random() * 100 + 50;
                ctx.strokeStyle = `rgba(139, 90, 43, ${Math.random() * 0.2})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + length, y);
                ctx.stroke();
            }
            const laneTexture = new THREE.CanvasTexture(canvas);

            const laneSpacing = laneWidth + gutterWidth * 2 + 1.5; // Space between lane centers

            // Left adjacent lane
            const leftLaneGeometry = new THREE.BoxGeometry(laneWidth, 0.02, laneLength);
            const leftLaneMaterial = new THREE.MeshLambertMaterial({ map: laneTexture });
            const leftLane = new THREE.Mesh(leftLaneGeometry, leftLaneMaterial);
            leftLane.position.set(-laneSpacing, 0, -laneLength/2);
            leftLane.receiveShadow = false;
            scene.add(leftLane);

            // Left lane gutters
            const gutterGeometry = new THREE.BoxGeometry(gutterWidth, 0.05, laneLength);
            const gutterMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a3e });

            const leftLaneLeftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftLaneLeftGutter.position.set(-laneSpacing - laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            leftLaneLeftGutter.receiveShadow = false;
            scene.add(leftLaneLeftGutter);

            const leftLaneRightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            leftLaneRightGutter.position.set(-laneSpacing + laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            leftLaneRightGutter.receiveShadow = false;
            scene.add(leftLaneRightGutter);

            // Right adjacent lane
            const rightLane = new THREE.Mesh(leftLaneGeometry, leftLaneMaterial);
            rightLane.position.set(laneSpacing, 0, -laneLength/2);
            rightLane.receiveShadow = false;
            scene.add(rightLane);

            // Right lane gutters
            const rightLaneLeftGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightLaneLeftGutter.position.set(laneSpacing - laneWidth/2 - gutterWidth/2, -0.015, -laneLength/2);
            rightLaneLeftGutter.receiveShadow = false;
            scene.add(rightLaneLeftGutter);

            const rightLaneRightGutter = new THREE.Mesh(gutterGeometry, gutterMaterial);
            rightLaneRightGutter.position.set(laneSpacing + laneWidth/2 + gutterWidth/2, -0.015, -laneLength/2);
            rightLaneRightGutter.receiveShadow = false;
            scene.add(rightLaneRightGutter);

            // Add pins for adjacent lanes
            createAdjacentPins(-laneSpacing);
            createAdjacentPins(laneSpacing);

            // Create animated balls for adjacent lanes
            createAdjacentBall(-laneSpacing);
            createAdjacentBall(laneSpacing);
        }

        function createBowlingAlley() {
            // Side walls - much wider spacing for open feel
            const wallHeight = 4;
            const wallThickness = 0.2;
            const wallDistance = 8; // Distance from lane center to walls (was ~1.5m, now 8m)

            // Create brick texture
            const brickTexture = createBrickTexture();
            const wallMaterial = new THREE.MeshLambertMaterial({
                map: brickTexture,
                side: THREE.DoubleSide
            });

            // Left wall (much farther out)
            const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, laneLength + 10);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.position.set(-wallDistance, wallHeight/2, -laneLength/2);
            leftWall.receiveShadow = false;
            scene.add(leftWall);

            // Right wall (much farther out)
            const rightWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            rightWall.position.set(wallDistance, wallHeight/2, -laneLength/2);
            rightWall.receiveShadow = false;
            scene.add(rightWall);

            // Back wall (behind pins) - wider
            const backWallGeometry = new THREE.BoxGeometry(wallDistance * 2, wallHeight, wallThickness);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, wallHeight/2, -laneLength - wallThickness/2);
            backWall.receiveShadow = false;
            scene.add(backWall);

            // Ceiling (acoustic tile look) - much wider
            const ceilingGeometry = new THREE.PlaneGeometry(wallDistance * 2, laneLength + 10);
            const ceilingMaterial = new THREE.MeshLambertMaterial({
                color: 0xd0d0d0, // Light gray ceiling tiles
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, wallHeight, -laneLength/2);
            ceiling.receiveShadow = false;
            scene.add(ceiling);

            // Floor extending beyond lane (carpet) - wider with retro pattern
            const floorGeometry = new THREE.PlaneGeometry(wallDistance * 2, 6);
            const carpetTexture = createCarpetTexture();
            const floorMaterial = new THREE.MeshLambertMaterial({
                map: carpetTexture
            });
            const backFloor = new THREE.Mesh(floorGeometry, floorMaterial);
            backFloor.rotation.x = -Math.PI / 2;
            backFloor.position.set(0, -0.01, -laneLength - 3);
            backFloor.receiveShadow = false;
            scene.add(backFloor);

            // Add seats behind the lane (spectator area)
            const seatMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            for (let i = -1; i <= 1; i++) {
                const seatGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.4);
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(i * 0.6, 0.15, 3);
                scene.add(seat);

                // Seat back
                const backGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.05);
                const seatBack = new THREE.Mesh(backGeometry, seatMaterial);
                seatBack.position.set(i * 0.6, 0.4, 3.2);
                scene.add(seatBack);
            }

            // Ball return (decorative)
            const ballReturnGeometry = new THREE.BoxGeometry(1.5, 0.3, 0.8);
            const ballReturnMaterial = new THREE.MeshLambertMaterial({ color: 0x4a4a5e });
            const ballReturn = new THREE.Mesh(ballReturnGeometry, ballReturnMaterial);
            ballReturn.position.set(-1.5, 0.15, 1.5);
            scene.add(ballReturn);

            // Add white baseboard trim along walls
            const baseboardMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const baseboardHeight = 0.15;
            const baseboardThickness = 0.05;

            // Left baseboard
            const baseboardGeometry = new THREE.BoxGeometry(baseboardThickness, baseboardHeight, laneLength + 10);
            const leftBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            leftBaseboard.position.set(-wallDistance + wallThickness/2, baseboardHeight/2, -laneLength/2);
            scene.add(leftBaseboard);

            // Right baseboard
            const rightBaseboard = new THREE.Mesh(baseboardGeometry, baseboardMaterial);
            rightBaseboard.position.set(wallDistance - wallThickness/2, baseboardHeight/2, -laneLength/2);
            scene.add(rightBaseboard);

            // Add some decorative neon strips on walls
            const neonMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6b35,
                emissive: 0xff6b35,
                emissiveIntensity: 0.5
            });

            // Neon strip on left wall
            const neonGeometry = new THREE.BoxGeometry(0.05, 0.1, laneLength);
            const leftNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            leftNeon.position.set(-laneWidth/2 - gutterWidth - 0.1, 2.5, -laneLength/2);
            scene.add(leftNeon);

            // Neon strip on right wall
            const rightNeon = new THREE.Mesh(neonGeometry, neonMaterial);
            rightNeon.position.set(laneWidth/2 + gutterWidth + 0.1, 2.5, -laneLength/2);
            scene.add(rightNeon);
        }

        function createCarpetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 512, 512);

            // Retro 90s bowling alley colors
            const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#ff6600', '#ff66ff', '#66ff66'];

            // Draw random geometric shapes
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 30 + 15;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const shapeType = Math.floor(Math.random() * 5);

                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 3;

                switch(shapeType) {
                    case 0: // Circle
                        ctx.beginPath();
                        ctx.arc(x, y, size/2, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 1: // Filled circle
                        ctx.beginPath();
                        ctx.arc(x, y, size/3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y - size/2);
                        ctx.lineTo(x - size/2, y + size/2);
                        ctx.lineTo(x + size/2, y + size/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 3: // Square
                        ctx.strokeRect(x - size/2, y - size/2, size, size);
                        break;
                    case 4: // Zigzag
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        for (let z = 0; z < 4; z++) {
                            ctx.lineTo(x + z * 8, y + (z % 2) * 15);
                        }
                        ctx.stroke();
                        break;
                }
            }

            // Add small dots
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const color = colors[Math.floor(Math.random() * colors.length)];
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Add spiral shapes
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const color = colors[Math.floor(Math.random() * colors.length)];
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                    const r = angle * 2;
                    ctx.lineTo(x + Math.cos(angle) * r, y + Math.sin(angle) * r);
                }
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 20); // Tile more to avoid stretching
            texture.magFilter = THREE.NearestFilter; // Crisp pixels, no blur
            texture.minFilter = THREE.NearestFilter; // No blur when viewed from distance
            texture.anisotropy = 16; // Better quality at angles
            return texture;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const brickWidth = 80;
            const brickHeight = 40;
            const mortarSize = 4;

            // Mortar background
            ctx.fillStyle = '#8b8680';
            ctx.fillRect(0, 0, 512, 512);

            // Draw brick pattern
            for (let row = 0; row < Math.ceil(512 / brickHeight); row++) {
                const offset = (row % 2) * (brickWidth / 2);
                for (let col = -1; col < Math.ceil(512 / brickWidth) + 1; col++) {
                    const x = col * brickWidth + offset;
                    const y = row * brickHeight;

                    // Varied brick colors for realism
                    const brickColors = ['#a0522d', '#8b4513', '#a0522d', '#9a4a1f', '#8b3a1f'];
                    const brickColor = brickColors[Math.floor(Math.random() * brickColors.length)];

                    ctx.fillStyle = brickColor;
                    ctx.fillRect(x + mortarSize, y + mortarSize, brickWidth - mortarSize, brickHeight - mortarSize);

                    // Add brick texture/variation
                    ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.1})`;
                    ctx.fillRect(x + mortarSize, y + mortarSize, brickWidth - mortarSize, brickHeight - mortarSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }

        function createLaneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Light wood color
            const gradient = ctx.createLinearGradient(0, 0, 512, 0);
            gradient.addColorStop(0, '#d4a373');
            gradient.addColorStop(0.5, '#c89968');
            gradient.addColorStop(1, '#d4a373');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Add wood grain texture
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const length = Math.random() * 100 + 50;
                ctx.strokeStyle = `rgba(139, 90, 43, ${Math.random() * 0.2})`;
                ctx.lineWidth = Math.random() * 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + length, y);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1aff,
                emissive: 0x0000aa,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, ballRadius, 0); // Start at foul line
            ball.castShadow = true;
            scene.add(ball);

            // Create Cannon.js physics body for ball
            const ballShape = new CANNON.Sphere(ballRadius);
            ballBody = new CANNON.Body({
                mass: 7.26, // kg (16 lb bowling ball)
                shape: ballShape,
                position: new CANNON.Vec3(0, ballRadius, 0),
                linearDamping: 0.01, // Very low air resistance
                angularDamping: 0.01,
                allowSleep: true
            });
            ballBody.sleepSpeedLimit = 0.15;
            ballBody.sleepTimeLimit = 0.5;

            // Add ground collision material
            const ballPhysicsMaterial = new CANNON.Material('ball');
            ballBody.material = ballPhysicsMaterial;

            world.addBody(ballBody);
        }

        function updateBallColor() {
            if (!ball || !window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const player = window.bowlingPlayers[window.currentPlayerIndex];
            const color = new THREE.Color(player.color);
            ball.material.color = color;
            ball.material.emissive = color.clone().multiplyScalar(0.3);
        }

        function createAimingArrow() {
            // Create a simple arrow/line to show aim direction
            const arrowGroup = new THREE.Group();

            // Main line pointing down the lane
            const lineGeometry = new THREE.BufferGeometry();
            const lineLength = 10; // Length of aiming line in meters
            const vertices = new Float32Array([
                0, 0.01, 0,  // Start at ball position (slightly above ground)
                0, 0.01, -lineLength  // Point down the lane
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0xff0000,  // Red aiming line
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            arrowGroup.add(line);

            // Arrow head (small cone at the end)
            const coneGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(0, 0.01, -lineLength);
            cone.rotation.x = Math.PI; // Point down
            arrowGroup.add(cone);

            arrowGroup.position.copy(ball.position);
            scene.add(arrowGroup);

            return arrowGroup;
        }

        function updateAimingArrow() {
            if (!aimingArrow) return;

            // Position arrow at ball (ball now moves left/right)
            aimingArrow.position.copy(ball.position);

            // Rotate arrow based on aim angle
            aimingArrow.rotation.y = aimAngle * Math.PI / 180;

            // Change arrow color based on mode
            if (aimingMode !== lastAimingMode) {
                const color = aimingMode === 'position' ? 0xffaa00 : 0xff0000;
                aimingArrow.children.forEach(child => {
                    if (child.material) {
                        child.material.color.set(color);
                    }
                });
                lastAimingMode = aimingMode;
            }

            // Hide arrow when ball is moving
            aimingArrow.visible = !isMoving;
        }

        function createPins() {
            // Create 10 pins in INVERTED triangle formation (point toward bowler)
            // Row 1 (1 pin): pin 1 (head pin - closest to bowler)
            // Row 2 (2 pins): pins 2, 3
            // Row 3 (3 pins): pins 4, 5, 6
            // Row 4 (4 pins): pins 7, 8, 9, 10 (back row)

            const pinPositions = [
                // Row 1 - Head pin (closest to bowler)
                { x: 0, z: -laneLength + 1 },
                // Row 2 - Behind head pin
                { x: -pinSpacing/2, z: -laneLength + 1 - pinSpacing },
                { x: pinSpacing/2, z: -laneLength + 1 - pinSpacing },
                // Row 3 - Third row
                { x: -pinSpacing, z: -laneLength + 1 - pinSpacing * 2 },
                { x: 0, z: -laneLength + 1 - pinSpacing * 2 },
                { x: pinSpacing, z: -laneLength + 1 - pinSpacing * 2 },
                // Row 4 - Back row (furthest from bowler)
                { x: -pinSpacing * 1.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: -pinSpacing * 0.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: pinSpacing * 0.5, z: -laneLength + 1 - pinSpacing * 3 },
                { x: pinSpacing * 1.5, z: -laneLength + 1 - pinSpacing * 3 }
            ];

            pins = [];
            pinBodies = [];
            pinPositions.forEach((pos, index) => {
                const pin = createPin(pos.x, pos.z, index + 1);
                pins.push(pin);
            });
        }

        function createPin(x, z, number) {
            // Simplified pin as cylinder with cone on top
            const group = new THREE.Group();

            // Body (cylinder) - positioned relative to center of mass
            const bodyGeometry = new THREE.CylinderGeometry(pinRadius * 0.6, pinRadius, pinHeight * 0.7, 8);
            const pinThreeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.05,
                shininess: 50
            });
            const body = new THREE.Mesh(bodyGeometry, pinThreeMaterial);
            body.position.y = pinHeight * 0.35 - pinHeight / 2;  // Offset from center
            group.add(body);

            // Neck (top cone)
            const neckGeometry = new THREE.CylinderGeometry(pinRadius * 0.3, pinRadius * 0.6, pinHeight * 0.3, 8);
            const neck = new THREE.Mesh(neckGeometry, pinThreeMaterial);
            neck.position.y = pinHeight * 0.85 - pinHeight / 2;  // Offset from center
            group.add(neck);

            // Red stripe
            const stripeGeometry = new THREE.CylinderGeometry(pinRadius * 0.65, pinRadius * 0.65, pinHeight * 0.1, 8);
            const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripe.position.y = pinHeight * 0.6 - pinHeight / 2;  // Offset from center
            group.add(stripe);

            group.position.set(x, pinHeight / 2, z);  // Position at center of mass height
            group.castShadow = true;
            group.userData = {
                number: number,
                standing: true,
                velocity: new THREE.Vector3(0, 0, 0),
                angularVelocity: new THREE.Vector3(0, 0, 0),
                originalX: x,  // Store original position
                originalZ: z   // Store original position
            };

            scene.add(group);

            // Create Cannon.js physics body for pin (cylinder shape)
            const pinShape = new CANNON.Cylinder(pinRadius * 0.6, pinRadius, pinHeight, 8);
            const pinBody = new CANNON.Body({
                mass: 1.5, // kg (standard bowling pin weight)
                shape: pinShape,
                position: new CANNON.Vec3(x, pinHeight / 2, z),
                linearDamping: 0.3,
                angularDamping: 0.3,
                allowSleep: true
            });
            pinBody.sleepSpeedLimit = 0.15;
            pinBody.sleepTimeLimit = 0.5;

            // Add pin material for collision
            const pinPhysicsMaterial = new CANNON.Material('pin');
            pinBody.material = pinPhysicsMaterial;

            // Store reference to THREE.js object
            pinBody.threejsObject = group;
            group.userData.physicsBody = pinBody;

            world.addBody(pinBody);
            pinBodies.push(pinBody);

            return group;
        }

        function updateCameraPosition() {
            if (pinCameraActive) {
                // Pin camera - side view of the pins
                camera.position.set(2, 1.5, -laneLength + 2);
                camera.lookAt(0, 0.3, -laneLength + 1);
                return;
            }

            switch (currentView) {
                case 'behind':
                    // Camera behind ball looking down lane
                    camera.position.set(0, 2, 3);
                    camera.lookAt(0, 0.5, -laneLength/2);
                    break;
                case 'side':
                    camera.position.set(3, 2, -laneLength/2);
                    camera.lookAt(0, 0, -laneLength/2);
                    break;
                case 'follow':
                    if (isMoving && ballVelocity.length() > 0.01) {
                        const travelDirection = ballVelocity.clone().normalize();
                        camera.position.set(
                            ball.position.x - travelDirection.x * 1.5,
                            ball.position.y + 1.5,
                            ball.position.z - travelDirection.z * 1.5
                        );
                        camera.lookAt(
                            ball.position.x + travelDirection.x * 2,
                            ball.position.y,
                            ball.position.z + travelDirection.z * 2
                        );
                    } else {
                        camera.position.set(0, 2, 3);
                        camera.lookAt(0, 0.5, -laneLength/2);
                    }
                    break;
            }
        }

        function cycleView() {
            const views = ['behind', 'side', 'follow'];
            const currentIndex = views.indexOf(currentView);
            currentView = views[(currentIndex + 1) % views.length];
            updateCameraPosition();
            showNotification(`Camera: ${currentView.charAt(0).toUpperCase() + currentView.slice(1)}`);
        }

        function showNotification(message) {
            const existing = document.getElementById('notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 107, 53, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }

        function updatePhysics(deltaTime) {
            if (!isMoving) return;

            // Sync ballVelocity from physics body for camera follow
            if (ballBody) {
                ballVelocity.set(ballBody.velocity.x, ballBody.velocity.y, ballBody.velocity.z);

                // Prevent ball from rolling backward (positive Z direction)
                if (ballBody.velocity.z > 0 && ball.position.z < -2) {
                    ballBody.velocity.z = Math.min(ballBody.velocity.z * 0.5, 0);
                }
            }

            const speed = ballVelocity.length();

            // Activate pin camera when ball gets close to pins
            if (!pinCameraActive && ball.position.z < -laneLength + 5) {
                savedView = currentView;
                pinCameraActive = true;
                updateCameraPosition();
            }

            // Check for gutter (only if bumpers are disabled - physics handles bumper collisions now)
            if (Math.abs(ball.position.x) > laneWidth/2 && ball.position.z < -1) {
                const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];

                // Check if current player has bumpers enabled
                if (currentPlayer && currentPlayer.bumpers) {
                    // Bumpers enabled - physics handles the collision, just show notification if ball bounces
                    // (This code path shouldn't trigger often since physics keeps ball from going past bumper)
                } else {
                    // No bumpers - gutter ball!
                    const pinsKnockedBeforeGutter = countPinsDown();
                    ballBody.velocity.set(0, 0, 0);
                    ballVelocity.set(0, 0, 0);
                    isMoving = false;
                    showNotification('Gutter Ball! üò¨');
                    setTimeout(() => {
                        // Restore camera and count any pins that were knocked before the gutter
                        pinCameraActive = false;
                        currentView = savedView;
                        updateCameraPosition();
                        frameComplete(pinsKnockedBeforeGutter);
                    }, 3000);
                    return;
                }
            }

            // Check for end of lane
            if (ball.position.z < -laneLength + 0.5) {
                ballBody.velocity.set(0, 0, 0);
                ballVelocity.set(0, 0, 0);
                isMoving = false;

                // Pause on pin camera for 3 seconds, then count pins
                setTimeout(() => {
                    pinCameraActive = false;
                    currentView = savedView;
                    updateCameraPosition();
                    const pinsKnocked = countPinsDown();
                    frameComplete(pinsKnocked);
                }, 3000);
                return;
            }

            // Check if ball has stopped
            if (speed < 0.01 && ball.position.z < -5) {
                ballBody.velocity.set(0, 0, 0);
                ballVelocity.set(0, 0, 0);
                ballSpin.set(0, 0, 0);
                isMoving = false;

                // Pause on pin camera for 3 seconds, then count pins
                setTimeout(() => {
                    pinCameraActive = false;
                    currentView = savedView;
                    updateCameraPosition();
                    const pinsKnocked = countPinsDown();
                    frameComplete(pinsKnocked);
                }, 3000);
            }
        }

        function updatePinPhysics(deltaTime) {
            const groundFriction = 0.92; // Coefficient of friction for wood on wood
            const airResistance = 0.98; // Air resistance
            const rollingFriction = 0.95; // Friction when rolling

            pins.forEach(pin => {
                // Skip physics for invisible pins (they've been cleared)
                if (!pin.visible) return;

                if (!pin.userData.standing) {
                    // Apply gravity to falling pins
                    pin.userData.velocity.y -= gravity * deltaTime;

                    // Separate horizontal and vertical velocity
                    const horizontalSpeed = Math.sqrt(
                        pin.userData.velocity.x ** 2 +
                        pin.userData.velocity.z ** 2
                    );

                    // Apply air resistance
                    pin.userData.velocity.x *= airResistance;
                    pin.userData.velocity.z *= airResistance;

                    // Update position
                    pin.position.add(pin.userData.velocity.clone().multiplyScalar(deltaTime));

                    // Apply angular velocity (rotation)
                    pin.rotation.x += pin.userData.angularVelocity.x * deltaTime;
                    pin.rotation.z += pin.userData.angularVelocity.z * deltaTime;

                    // Apply rotational friction
                    pin.userData.angularVelocity.multiplyScalar(rollingFriction);

                    // Floor collision
                    if (pin.position.y < 0) {
                        pin.position.y = 0;

                        // Bounce with energy loss
                        pin.userData.velocity.y = -pin.userData.velocity.y * 0.3; // Restitution

                        // Apply ground friction when in contact with floor
                        if (horizontalSpeed > 0.01) {
                            // Sliding friction
                            pin.userData.velocity.x *= groundFriction;
                            pin.userData.velocity.z *= groundFriction;
                        } else {
                            // Static friction - stop if moving very slowly
                            pin.userData.velocity.x = 0;
                            pin.userData.velocity.z = 0;
                        }
                    }

                    // Stop pin if moving very slowly (at rest)
                    if (horizontalSpeed < 0.01 && Math.abs(pin.userData.velocity.y) < 0.01 && pin.position.y < 0.01) {
                        pin.userData.velocity.set(0, 0, 0);
                        pin.userData.angularVelocity.set(0, 0, 0);
                    }
                }
            });

            // Pin-to-pin collisions
            for (let i = 0; i < pins.length; i++) {
                for (let j = i + 1; j < pins.length; j++) {
                    checkPinToPinCollision(pins[i], pins[j]);
                }
            }
        }

        function checkPinCollisions() {
            pins.forEach((pin, index) => {
                // Debug logging for each pin
                const dx = ball.position.x - pin.position.x;
                const dy = ball.position.y - pin.position.y;
                const dz = ball.position.z - pin.position.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);

                // Log pin state when ball is near
                if (distXZ < 0.5) { // Within 0.5m
                    console.log(`üé≥ Pin ${index + 1}: standing=${pin.userData.standing}, visible=${pin.visible}, pos=(${pin.position.x.toFixed(2)}, ${pin.position.y.toFixed(2)}, ${pin.position.z.toFixed(2)}), dist=${distXZ.toFixed(3)}m`);
                }

                // Only check collision with pins that are standing AND visible
                if (pin.userData.standing && pin.visible) {
                    // 3D collision detection with height consideration
                    const pinHeight = 0.38; // Pin height in meters
                    const validHeight = ball.position.y >= 0 && ball.position.y <= pinHeight + ballRadius;

                    if (distXZ < ballRadius + pinRadius && validHeight) {
                        // Collision!
                        console.log(`üí• COLLISION with Pin ${index + 1}! standing=${pin.userData.standing}, visible=${pin.visible}, dist=${distXZ.toFixed(3)}m`);
                        pin.userData.standing = false;

                        // Calculate collision point height ratio (0 = bottom, 1 = top)
                        const heightRatio = Math.min(1, Math.max(0, ball.position.y / pinHeight));

                        // Transfer momentum to pin (physics-based)
                        const direction = new THREE.Vector3(
                            pin.position.x - ball.position.x,
                            0,
                            pin.position.z - ball.position.z
                        ).normalize();

                        // Ball mass: ~7kg, Pin mass: ~1.5kg
                        const ballMass = 7.0;
                        const pinMass = 1.5;
                        const massRatio = ballMass / pinMass;

                        // Momentum transfer based on mass and velocity
                        const impactForce = ballVelocity.length() * massRatio * 0.3;

                        // Higher hits create more toppling, lower hits more sliding
                        const upwardForce = 1.5 + heightRatio * 2; // 1.5 to 3.5 based on hit height

                        pin.userData.velocity.set(
                            direction.x * impactForce,
                            upwardForce,
                            direction.z * impactForce
                        );

                        // Add rotation (more rotation for higher hits)
                        const rotationIntensity = 8 + heightRatio * 6; // 8 to 14
                        pin.userData.angularVelocity.set(
                            (Math.random() - 0.5) * rotationIntensity,
                            0,
                            (Math.random() - 0.5) * rotationIntensity
                        );

                        // Reduce ball velocity based on mass transfer
                        const energyLoss = 1.0 - (pinMass / (ballMass + pinMass));
                        ballVelocity.multiplyScalar(energyLoss);
                    }
                }
            });
        }

        function checkPinToPinCollision(pin1, pin2) {
            const dx = pin1.position.x - pin2.position.x;
            const dz = pin1.position.z - pin2.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < pinRadius * 2 && (!pin1.userData.standing || !pin2.userData.standing)) {
                // If one pin is falling and hits another standing pin
                if (pin1.userData.standing && !pin2.userData.standing) {
                    const v2 = pin2.userData.velocity.length();
                    if (v2 > 0.5) {
                        pin1.userData.standing = false;
                        const direction = new THREE.Vector3(
                            pin1.position.x - pin2.position.x,
                            0,
                            pin1.position.z - pin2.position.z
                        ).normalize();
                        pin1.userData.velocity.copy(direction.multiplyScalar(v2 * 0.5));
                        pin1.userData.velocity.y = 1;
                        pin1.userData.angularVelocity.set(
                            (Math.random() - 0.5) * 8,
                            0,
                            (Math.random() - 0.5) * 8
                        );
                    }
                } else if (!pin1.userData.standing && pin2.userData.standing) {
                    const v1 = pin1.userData.velocity.length();
                    if (v1 > 0.5) {
                        pin2.userData.standing = false;
                        const direction = new THREE.Vector3(
                            pin2.position.x - pin1.position.x,
                            0,
                            pin2.position.z - pin1.position.z
                        ).normalize();
                        pin2.userData.velocity.copy(direction.multiplyScalar(v1 * 0.5));
                        pin2.userData.velocity.y = 1;
                        pin2.userData.angularVelocity.set(
                            (Math.random() - 0.5) * 8,
                            0,
                            (Math.random() - 0.5) * 8
                        );
                    }
                }
            }
        }

        function countPinsDown() {
            let count = 0;
            pins.forEach(pin => {
                // Only count pins that are down AND visible (not cleared from previous ball)
                if (!pin.userData.standing && pin.visible) {
                    count++;
                }
            });
            return count;
        }

        function resetPins() {
            pins.forEach((pin, index) => {
                pin.userData.standing = true;
                pin.userData.velocity.set(0, 0, 0);
                pin.userData.angularVelocity.set(0, 0, 0);
                // Restore original position (at center of mass height)
                pin.position.set(pin.userData.originalX, pinHeight / 2, pin.userData.originalZ);
                pin.rotation.x = 0;
                pin.rotation.z = 0;
                pin.visible = true; // Make sure pin is visible

                // Reset physics body
                if (pinBodies[index]) {
                    pinBodies[index].position.set(pin.userData.originalX, pinHeight / 2, pin.userData.originalZ);
                    pinBodies[index].quaternion.set(0, 0, 0, 1);
                    pinBodies[index].velocity.set(0, 0, 0);
                    pinBodies[index].angularVelocity.set(0, 0, 0);
                }
            });
        }

        function clearKnockedPins() {
            // After first ball, remove knocked pins from view (like real bowling)
            pins.forEach((pin, index) => {
                if (!pin.userData.standing) {
                    pin.visible = false; // Hide knocked pins
                    // Move knocked pins far away so they don't interfere with physics
                    pin.position.set(pin.position.x, -100, pin.position.z);
                    pin.userData.velocity.set(0, 0, 0);
                    pin.userData.angularVelocity.set(0, 0, 0);

                    // Move physics body far away too
                    if (pinBodies[index]) {
                        pinBodies[index].position.set(pin.position.x, -100, pin.position.z);
                        pinBodies[index].velocity.set(0, 0, 0);
                        pinBodies[index].angularVelocity.set(0, 0, 0);
                    }
                }
            });
        }

        function resetBall() {
            ball.position.set(0, ballRadius, 0);
            ballVelocity.set(0, 0, 0);
            ballSpin.set(0, 0, 0);
            isMoving = false;
            ball.rotation.x = 0;
            aimAngle = 0; // Reset aim to center
            ballPosition = 0; // Reset ball position to center
            aimingMode = 'position'; // Reset to position mode

            // Reset physics body
            if (ballBody) {
                ballBody.position.set(0, ballRadius, 0);
                ballBody.quaternion.set(0, 0, 0, 1);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }

            updateAimingArrow();
            updateUI();
        }

        function rollBall(speed, hla = 0, sidespin = 0) {
            if (isMoving) return;
            if (gameOver) {
                showNotification('Game Over! Start a new game.');
                return;
            }

            // Convert mph to m/s
            const speedMS = speed * 0.44704;

            // Combine the launch monitor HLA with keyboard aim angle
            const totalHLA = hla + aimAngle;
            const hlaRad = totalHLA * Math.PI / 180;

            // Apply velocity to Cannon.js physics body
            ballBody.velocity.set(
                speedMS * Math.sin(hlaRad),
                0,
                -speedMS * Math.cos(hlaRad) // Negative Z is down the lane
            );

            // Apply angular velocity for sidespin (hook)
            const spinFactor = sidespin * 0.001; // Convert RPM to rad/s
            ballBody.angularVelocity.set(spinFactor, 0, 0);

            // Also set the old ballVelocity for camera follow (compatibility)
            ballVelocity.set(
                speedMS * Math.sin(hlaRad),
                0,
                -speedMS * Math.cos(hlaRad)
            );

            // Set sidespin for hook
            ballSpin.set(0, sidespin, 0);

            isMoving = true;

            // Update display
            document.getElementById('ballSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('hookAngle').textContent = hla.toFixed(1) + '¬∞';
        }

        function frameComplete(pinsKnocked) {
            console.log(`Frame complete: ${pinsKnocked} pins knocked`);

            const frame = frames[currentFrame - 1];
            frame.rolls.push(pinsKnocked);

            // Check for strike
            if (currentBall === 1 && pinsKnocked === 10) {
                frame.isStrike = true;
                showNotification('STRIKE! üé≥');

                // Move to next frame (except in 10th frame)
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // 10th frame strike - get 2 more balls
                    resetPins();
                    resetBall();
                    currentBall = 2;
                }
            }
            // Check for spare
            else if (currentBall === 2 && (frame.rolls[0] + pinsKnocked === 10)) {
                frame.isSpare = true;
                showNotification('SPARE! /');

                // Move to next frame
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // 10th frame spare - get 1 more ball
                    resetPins();
                    resetBall();
                    currentBall = 3;
                }
            }
            // Second ball
            else if (currentBall === 2) {
                // Move to next frame
                if (currentFrame < 10) {
                    resetPins();
                    resetBall();
                    currentFrame++;
                    currentBall = 1;
                } else {
                    // End of game
                    gameOver = true;
                    calculateFinalScore();
                    showNotification(`Game Over! Final Score: ${calculateTotalScore()}`);
                }
            }
            // First ball (not strike)
            else {
                clearKnockedPins(); // Clear knocked pins before second ball
                resetBall();
                currentBall = 2;
            }

            // Special handling for 10th frame
            if (currentFrame === 10) {
                // If strike or spare in 10th, allow extra balls
                if (currentBall === 3 && frame.rolls.length >= 3) {
                    gameOver = true;
                    calculateFinalScore();
                    showNotification(`Game Over! Final Score: ${calculateTotalScore()}`);
                }
            }

            updateUI();
            updateScorecard();
        }

        function calculateTotalScore() {
            let total = 0;
            for (let i = 0; i < 10; i++) {
                const frame = frames[i];

                if (frame.isStrike) {
                    total += 10;
                    // Add next two rolls
                    if (i < 9) {
                        const nextFrame = frames[i + 1];
                        total += nextFrame.rolls[0] || 0;
                        if (nextFrame.isStrike && i < 8) {
                            total += frames[i + 2].rolls[0] || 0;
                        } else {
                            total += nextFrame.rolls[1] || 0;
                        }
                    } else {
                        // 10th frame
                        total += frame.rolls[1] || 0;
                        total += frame.rolls[2] || 0;
                    }
                } else if (frame.isSpare) {
                    total += 10;
                    // Add next roll
                    if (i < 9) {
                        total += frames[i + 1].rolls[0] || 0;
                    } else {
                        total += frame.rolls[2] || 0;
                    }
                } else {
                    total += frame.rolls[0] || 0;
                    total += frame.rolls[1] || 0;
                }

                frame.score = total;
            }
            return total;
        }

        function calculateFinalScore() {
            calculateTotalScore();
        }

        function updateUI() {
            document.getElementById('currentFrameNum').textContent = currentFrame;
            document.getElementById('currentBallNum').textContent = currentBall;
            document.getElementById('totalScore').textContent = calculateTotalScore();
            document.getElementById('pinsDown').textContent = countPinsDown();
            document.getElementById('aimAngleDisplay').textContent = aimAngle.toFixed(1) + '¬∞';
            document.getElementById('ballPositionDisplay').textContent = ballPosition.toFixed(2) + 'm';
            document.getElementById('aimingModeDisplay').textContent = aimingMode;
        }

        function createScorecard() {
            const container = document.getElementById('frameContainer');
            container.innerHTML = '';

            for (let i = 0; i < 10; i++) {
                const frameDiv = document.createElement('div');
                frameDiv.className = 'frame';
                frameDiv.id = `frame${i + 1}`;

                const frameNumber = document.createElement('div');
                frameNumber.className = 'frame-number';
                frameNumber.textContent = i + 1;

                const frameRolls = document.createElement('div');
                frameRolls.className = 'frame-rolls';
                frameRolls.id = `frame${i + 1}-rolls`;

                const frameScore = document.createElement('div');
                frameScore.className = 'frame-score';
                frameScore.id = `frame${i + 1}-score`;

                frameDiv.appendChild(frameNumber);
                frameDiv.appendChild(frameRolls);
                frameDiv.appendChild(frameScore);
                container.appendChild(frameDiv);
            }

            updateScorecard();
        }

        function updateScorecard() {
            for (let i = 0; i < 10; i++) {
                const frame = frames[i];
                const rollsDiv = document.getElementById(`frame${i + 1}-rolls`);
                const scoreDiv = document.getElementById(`frame${i + 1}-score`);
                const frameDiv = document.getElementById(`frame${i + 1}`);

                // Highlight current frame
                if (i + 1 === currentFrame) {
                    frameDiv.classList.add('active');
                } else {
                    frameDiv.classList.remove('active');
                }

                // Display rolls
                rollsDiv.innerHTML = '';
                if (i < 9) {
                    // Frames 1-9
                    if (frame.isStrike) {
                        const box = document.createElement('div');
                        box.className = 'roll-box';
                        box.textContent = 'X';
                        rollsDiv.appendChild(box);
                    } else {
                        const box1 = document.createElement('div');
                        box1.className = 'roll-box';
                        box1.textContent = frame.rolls[0] || '';
                        rollsDiv.appendChild(box1);

                        if (frame.rolls.length > 1) {
                            const box2 = document.createElement('div');
                            box2.className = 'roll-box';
                            box2.textContent = frame.isSpare ? '/' : (frame.rolls[1] || '');
                            rollsDiv.appendChild(box2);
                        }
                    }
                } else {
                    // 10th frame (can have 3 rolls)
                    for (let j = 0; j < 3; j++) {
                        const box = document.createElement('div');
                        box.className = 'roll-box';
                        if (frame.rolls[j] !== undefined) {
                            if (frame.rolls[j] === 10) {
                                box.textContent = 'X';
                            } else if (j > 0 && frame.rolls[j-1] + frame.rolls[j] === 10) {
                                box.textContent = '/';
                            } else {
                                box.textContent = frame.rolls[j];
                            }
                        }
                        rollsDiv.appendChild(box);
                    }
                }

                // Display score
                if (frame.score !== null && frame.score !== undefined) {
                    scoreDiv.textContent = frame.score;
                } else {
                    scoreDiv.textContent = '';
                }
            }
        }

        // Test Shot Functions
        function toggleTestPanel() {
            const content = document.getElementById('testPanelContent');
            const toggle = document.getElementById('testPanelToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function sendTestShot() {
            const speed = parseFloat(document.getElementById('testSpeed').value);
            const hla = parseFloat(document.getElementById('testHLA').value);
            const sidespin = parseFloat(document.getElementById('testSidespin').value);

            console.log(`üß™ Test shot: ${speed} mph, HLA: ${hla}¬∞, Sidespin: ${sidespin} rpm`);

            // Clear knocked pins before test shot (like between balls in real bowling)
            clearKnockedPins();

            if (speed > 0) {
                rollBall(speed, hla, sidespin);
            }
        }

        function newGame() {
            // Reset game state
            currentFrame = 1;
            currentBall = 1;
            gameOver = false;
            frames = [];
            for (let i = 0; i < 10; i++) {
                frames.push({
                    rolls: [],
                    score: null,
                    isStrike: false,
                    isSpare: false
                });
            }

            resetPins();
            resetBall();
            updateUI();
            updateScorecard();

            // Only show notification if game was already in progress
            if (currentFrame > 1 || frames[0].rolls.length > 0) {
                showNotification('New Game Started!');
            }
        }

        function setupElectronIPC() {
            // Load players from localStorage
            const playersData = localStorage.getItem('bowlingPlayers');
            window.bowlingPlayers = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#FF6B35' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('bowlingCurrentPlayer') || '0');

            updatePlayerDisplay();
            updateBallColor();

            // Hide Next Player button if only 1 player
            if (window.bowlingPlayers.length === 1) {
                document.getElementById('nextPlayerBtn').style.display = 'none';
            }

            // Welcome message - let player know they can start immediately
            const player = window.bowlingPlayers[window.currentPlayerIndex];
            updateBumperVisibility(); // Set initial bumper state
            setTimeout(() => {
                showNotification(`${player.name} - Ready to Bowl! üé≥`);
            }, 500);

            // Listen for shot data
            window.electronAPI.onShotData((shotData) => {
                console.log('üì° Shot received:', shotData);

                let speed = shotData.ball_speed || 0;
                const hla = shotData.hla || 0;
                const sidespin = shotData.side_spin || 0;

                // Apply power boost if player has it enabled and shot is weak
                const currentPlayer = window.bowlingPlayers[window.currentPlayerIndex];
                if (currentPlayer && currentPlayer.powerMultiplier && speed > 0 && speed < 70) {
                    const originalSpeed = speed;
                    speed = speed * currentPlayer.powerMultiplier;
                    console.log(`‚ö° Power Boost: ${originalSpeed.toFixed(1)} mph ‚Üí ${speed.toFixed(1)} mph (${currentPlayer.powerMultiplier}x)`);
                }

                if (speed > 0) {
                    // Accept both putter and iron shots for bowling
                    rollBall(speed, hla, sidespin);
                }
            });
        }

        // ==================== STEAM NETWORK MULTIPLAYER ====================

        async function initNetworkMultiplayer() {
            const gameMode = localStorage.getItem('bowlingGameMode');
            if (gameMode !== 'steam') {
                console.log('üìç Local game mode - network disabled');
                isNetworkGame = false;
                return;
            }

            console.log('üåê Steam multiplayer mode - initializing network...');

            if (typeof getSteamNetwork === 'undefined') {
                console.error('‚ùå SteamNetworkAdapter not loaded');
                return;
            }

            networkAdapter = getSteamNetwork();

            try {
                const available = await networkAdapter.initialize();
                if (!available) {
                    isNetworkGame = false;
                    return;
                }

                isNetworkGame = true;
                localSteamId = networkAdapter.getLocalPlayer()?.steamId;

                const lobbyData = localStorage.getItem('bowlingSteamLobby');
                if (lobbyData) {
                    const lobby = JSON.parse(lobbyData);
                    isNetworkHost = lobby.isHost;
                }

                networkAdapter.onMessage(handleNetworkMessage);
                console.log('‚úÖ Steam network initialized');

            } catch (err) {
                console.error('‚ùå Network initialization failed:', err);
                isNetworkGame = false;
            }
        }

        function handleNetworkMessage(message) {
            if (message.from === localSteamId) return;

            switch (message.type) {
                case 'shot':
                    const { speed, hla, sidespin, playerIndex } = message.data || message;
                    if (playerIndex !== undefined) window.currentPlayerIndex = playerIndex;
                    rollBall(speed, hla, sidespin);
                    break;
                case 'pins_state':
                    console.log('üåê Pins state:', message);
                    break;
                case 'frame_complete':
                    console.log('üåê Frame complete:', message);
                    break;
                case 'game_state':
                    if (message.data) {
                        if (message.data.currentFrame) currentFrame = message.data.currentFrame;
                        if (message.data.currentBall) currentBall = message.data.currentBall;
                    }
                    break;
            }
        }

        function broadcastShot(speed, hla, sidespin) {
            if (!isNetworkGame || !networkAdapter) return;
            networkAdapter.broadcast({
                type: 'shot',
                data: { speed, hla, sidespin, playerIndex: window.currentPlayerIndex }
            });
        }

        function broadcastFrameComplete(pinsKnocked) {
            if (!isNetworkGame || !networkAdapter) return;
            networkAdapter.broadcast({
                type: 'frame_complete',
                pinsKnocked,
                frame: currentFrame,
                ball: currentBall
            });
        }

        // Initialize network
        initNetworkMultiplayer();

        // ==================== END STEAM NETWORK ====================

        function updatePlayerDisplay() {
            if (!window.bowlingPlayers || window.bowlingPlayers.length === 0) return;

            const player = window.bowlingPlayers[window.currentPlayerIndex];
            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }
        }

        function nextPlayer() {
            if (!window.bowlingPlayers || window.bowlingPlayers.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.bowlingPlayers.length;
            localStorage.setItem('bowlingCurrentPlayer', window.currentPlayerIndex.toString());

            updatePlayerDisplay();
            updateBallColor();
            updateBumperVisibility(); // Update bumper visibility for new player
            newGame(); // Start new game for next player
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Reapply visual offset after resize
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                camera.setViewOffset(window.innerWidth, window.innerHeight, visualOffsetX, visualOffsetY, window.innerWidth, window.innerHeight);
            }
        }

        function syncPhysics() {
            // Sync ball
            if (ballBody && ball) {
                ball.position.copy(ballBody.position);
                ball.quaternion.copy(ballBody.quaternion);
            }

            // Sync pins
            pinBodies.forEach((pinBody, index) => {
                if (pins[index] && pinBody) {
                    pins[index].position.copy(pinBody.position);
                    pins[index].quaternion.copy(pinBody.quaternion);

                    // Update standing status based on orientation
                    const pin = pins[index];
                    if (pin.userData.standing) {
                        // Check if pin has fallen (tilted more than 45 degrees)
                        tempUpVector.set(0, 1, 0).applyQuaternion(pin.quaternion);
                        const angle = Math.acos(tempUpVector.y) * (180 / Math.PI);

                        if (angle > 45 || pin.position.y < 0.05) {
                            pin.userData.standing = false;
                        }
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Step Cannon.js physics world
            world.step(1/60, deltaTime, 3);

            // Sync THREE.js meshes with Cannon.js bodies
            syncPhysics();

            updatePhysics(deltaTime);
            updateAimingArrow();
            updateAdjacentBalls(); // Animate adjacent lane balls

            // Update camera for follow view
            if (currentView === 'follow') {
                updateCameraPosition();
            }

            if (renderer && renderer.shadowMap) {
                const pinsAwake = pinBodies.some((body) => body && body.sleepState !== CANNON.Body.SLEEPING);
                if (isMoving || pinsAwake) {
                    renderer.shadowMap.needsUpdate = true;
                }
            }

            renderer.render(scene, camera);
        }

        // Make functions globally available for onclick handlers and event listeners
        window.sendTestShot = sendTestShot;
        window.toggleTestPanel = toggleTestPanel;
        window.cycleView = cycleView;
        window.resetBall = resetBall;
        window.nextPlayer = nextPlayer;
        window.newGame = newGame;
    </script>
</body>
</html>

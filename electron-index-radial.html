<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shanktuary Golf Mini Games</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a2332 0%, #0d1117 70%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* === Connection Tab & Settings Panel === */
        .settings-tab-btn {
            position: fixed;
            top: 16px;
            right: 0;
            z-index: 2000;
            padding: 10px 18px 10px 14px;
            border-radius: 8px 0 0 8px;
            border: 1px solid rgba(255,255,255,0.15);
            border-right: none;
            background: rgba(239, 68, 68, 0.35);
            backdrop-filter: blur(12px);
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.3s, padding-right 0.2s;
        }
        .settings-tab-btn:hover {
            padding-right: 24px;
        }
        .settings-tab-btn.connected {
            background: rgba(34, 197, 94, 0.35);
            border-color: rgba(34, 197, 94, 0.3);
        }
        .settings-tab-btn.disconnected {
            background: rgba(239, 68, 68, 0.35);
            border-color: rgba(239, 68, 68, 0.3);
        }
        .settings-tab-btn .tab-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            flex-shrink: 0;
        }
        .settings-tab-btn.connected .tab-dot {
            background: #22c55e;
        }
        .settings-tab-btn.disconnected .tab-dot {
            background: #ef4444;
        }

        .settings-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2001;
        }
        .settings-overlay.open {
            display: block;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            z-index: 2002;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255,255,255,0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-panel-header h2 {
            font-size: 1.1em;
            margin: 0;
            color: #e2e8f0;
        }
        .settings-panel-close {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .settings-panel-close:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .settings-section {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .settings-section-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #6b7280;
            margin-bottom: 12px;
        }
        .settings-section .settings-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-section .settings-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
            transition: background 0.15s;
        }
        .settings-section .settings-btn:hover {
            background: rgba(255,255,255,0.18);
        }
        .settings-section .settings-btn.primary {
            background: rgba(34, 197, 94, 0.25);
            border-color: #22c55e;
            font-weight: bold;
        }
        .settings-section .settings-btn.danger {
            background: rgba(239, 68, 68, 0.25);
            border-color: #ef4444;
        }

        .connection-status {
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            margin-bottom: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .connection-status.connected {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
        }

        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.3);
            border: 2px solid #ef4444;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #22c55e;
        }

        .status-indicator.disconnected {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .start-button {
            background: rgba(59, 130, 246, 0.3);
            border: 2px solid #3b82f6;
            color: white;
            padding: 30px 60px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 2em;
            transition: all 0.3s ease;
            margin: 40px;
        }

        .start-button:hover {
            background: rgba(59, 130, 246, 0.5);
            transform: translateY(-5px);
        }

        .game-container {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        .game-container.active {
            display: block;
        }

        .back-button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .test-button {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .test-button:hover {
            background: rgba(34, 197, 94, 0.5);
        }

        .exit-fullscreen-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            background: rgba(239, 68, 68, 0.9);
            border: 2px solid #ef4444;
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s;
        }

        .exit-fullscreen-button:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.05);
        }

        .exit-fullscreen-button.visible {
            display: block;
        }

        .fullscreen-dropdown {
            position: relative;
            display: inline-block;
            margin-left: 10px;
        }

        .fullscreen-button {
            background: rgba(34, 197, 94, 0.3);
            border: 2px solid #22c55e;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .fullscreen-button:hover {
            background: rgba(34, 197, 94, 0.5);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.95);
            min-width: 220px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            border-radius: 8px;
            z-index: 1000;
            border: 2px solid #22c55e;
        }

        .dropdown-content button {
            width: 100%;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: white;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dropdown-content button:hover {
            background: rgba(34, 197, 94, 0.3);
        }

        .dropdown-content button:first-child {
            border-radius: 6px 6px 0 0;
        }

        .dropdown-content button:last-child {
            border-radius: 0 0 6px 6px;
        }

        .dropdown-content.show {
            display: block;
        }

        body.projector-mode #gameContent canvas {
            display: none;
        }

        .score-display {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .score-item {
            text-align: center;
        }

        .score-item .label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .score-item .value {
            font-size: 2em;
            font-weight: bold;
        }

        .shot-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .shot-feedback.show {
            opacity: 1;
        }

        .shot-feedback .points {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .shot-feedback .message {
            font-size: 1.5em;
        }

        .data-panels {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .data-panel {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            min-width: 300px;
        }

        .data-panel h4 {
            margin-bottom: 10px;
            color: #60a5fa;
            font-size: 1.1em;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .data-row:last-child {
            border-bottom: none;
        }

        .data-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
        }

        .data-value {
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }

        .data-value.highlight {
            color: #60a5fa;
        }

        /* === Radial Wheel Menu === */
        #menuScreen {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            width: 100%;
        }

        .radial-container {
            position: relative;
            width: 700px;
            height: 700px;
        }

        /* Decorative radial lines */
        .radial-line {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.4), transparent);
            transform-origin: 0 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .radial-container.connected .radial-line {
            opacity: 1;
        }

        /* Center hub */
        .radial-hub {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: radial-gradient(circle, #1a4d2e, #0d2818);
            border: 3px solid #22c55e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 40px rgba(34, 197, 94, 0.3), inset 0 0 30px rgba(34, 197, 94, 0.1);
            animation: hubPulse 3s ease-in-out infinite;
            z-index: 2;
        }

        .radial-hub .hub-logo {
            width: 150px;
            height: 150px;
            object-fit: contain;
            border-radius: 50%;
            pointer-events: none;
        }

        @keyframes hubPulse {
            0%, 100% { box-shadow: 0 0 40px rgba(34, 197, 94, 0.3), inset 0 0 30px rgba(34, 197, 94, 0.1); }
            50% { box-shadow: 0 0 60px rgba(34, 197, 94, 0.5), inset 0 0 40px rgba(34, 197, 94, 0.2); }
        }

        /* Radial game buttons */
        .radial-btn {
            position: absolute;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            border: 3px solid;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            color: white;
            z-index: 3;
            opacity: 0;
            pointer-events: none;
        }

        /* Only animate in when connected */
        .radial-container.connected .radial-btn {
            animation: radialFadeIn 0.5s ease forwards;
            pointer-events: auto;
        }

        /* Fade out when disconnected after having been connected */
        .radial-container.disconnected .radial-btn {
            animation: radialFadeOut 0.4s ease forwards;
            pointer-events: none;
        }

        @keyframes radialFadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.5); }
        }

        .radial-btn:hover {
            transform: scale(1.2);
            z-index: 10;
        }

        .radial-btn .btn-icon {
            font-size: 2.2em;
            margin-bottom: 4px;
        }

        .radial-btn .btn-label {
            font-size: 0.75em;
            font-weight: 600;
            text-align: center;
            line-height: 1.2;
            padding: 0 8px;
        }

        /* Per-game colors */
        .radial-btn.game-putt { border-color: #22c55e; box-shadow: 0 0 20px rgba(34, 197, 94, 0.4); }
        .radial-btn.game-putt:hover { box-shadow: 0 0 40px rgba(34, 197, 94, 0.7); }

        .radial-btn.game-bowling { border-color: #FF6B35; box-shadow: 0 0 20px rgba(255, 107, 53, 0.4); }
        .radial-btn.game-bowling:hover { box-shadow: 0 0 40px rgba(255, 107, 53, 0.7); }

        .radial-btn.game-darts2d { border-color: #3b82f6; box-shadow: 0 0 20px rgba(59, 130, 246, 0.4); }
        .radial-btn.game-darts2d:hover { box-shadow: 0 0 40px rgba(59, 130, 246, 0.7); }

        .radial-btn.game-steam { border-color: #66c0f4; box-shadow: 0 0 20px rgba(102, 192, 244, 0.4); }
        .radial-btn.game-steam:hover { box-shadow: 0 0 40px rgba(102, 192, 244, 0.7); }
        .radial-btn.game-steam.connected { border-color: #4ade80; box-shadow: 0 0 20px rgba(74, 222, 128, 0.5); }

        /* Steam Lobby Panel */
        .steam-lobby-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 380px;
            background: linear-gradient(180deg, #1b2838 0%, #171a21 100%);
            border: 2px solid #66c0f4;
            border-radius: 12px;
            padding: 24px;
            z-index: 2500;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        .steam-lobby-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2400;
        }
        .steam-lobby-overlay.open {
            display: block;
        }
        .steam-lobby-panel.open {
            display: block;
            animation: steamFadeIn 0.3s ease;
        }
        @keyframes steamFadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .steam-lobby-panel h3 {
            margin: 0 0 15px 0;
            color: #66c0f4;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .steam-lobby-panel .status-text {
            font-size: 13px;
            color: #888;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        .steam-lobby-panel .status-text.online {
            color: #4ade80;
        }
        .steam-lobby-panel .status-text.error {
            color: #ef4444;
        }

        /* Lobby buttons */
        .steam-btn {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .steam-btn-primary {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #000;
        }
        .steam-btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
        }
        .steam-btn-secondary {
            background: rgba(102, 192, 244, 0.2);
            color: #66c0f4;
            border: 1px solid #66c0f4;
        }
        .steam-btn-secondary:hover {
            background: rgba(102, 192, 244, 0.3);
        }
        .steam-btn-danger {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
        }
        .steam-btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        .steam-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Game select dropdown */
        .steam-game-select {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }
        .steam-game-select option {
            background: #1b2838;
        }

        /* Member list */
        .steam-members {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        .steam-members h4 {
            margin: 0 0 10px 0;
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
        }
        .steam-member {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin: 5px 0;
        }
        .steam-member-avatar {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #66c0f4, #1b2838);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .steam-member-name {
            flex: 1;
            color: white;
            font-size: 14px;
        }
        .steam-member-host {
            font-size: 10px;
            padding: 2px 6px;
            background: #fbbf24;
            color: #000;
            border-radius: 4px;
            font-weight: 600;
        }
        .steam-member-you {
            font-size: 10px;
            color: #66c0f4;
        }

        .radial-btn.game-beerpong { border-color: #ef4444; box-shadow: 0 0 20px rgba(239, 68, 68, 0.4); }
        .radial-btn.game-beerpong:hover { box-shadow: 0 0 40px rgba(239, 68, 68, 0.7); }

        .radial-btn.game-baseball { border-color: #fbbf24; box-shadow: 0 0 20px rgba(251, 191, 36, 0.4); }
        .radial-btn.game-baseball:hover { box-shadow: 0 0 40px rgba(251, 191, 36, 0.7); }

        .radial-btn.game-soccer { border-color: #10b981; box-shadow: 0 0 20px rgba(16, 185, 129, 0.4); }
        .radial-btn.game-soccer:hover { box-shadow: 0 0 40px rgba(16, 185, 129, 0.7); }

        .radial-btn.game-golf { border-color: #06b6d4; box-shadow: 0 0 20px rgba(6, 182, 212, 0.4); }
        .radial-btn.game-golf:hover { box-shadow: 0 0 40px rgba(6, 182, 212, 0.7); }

        /* Staggered fade-in animation */
        @keyframes radialFadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        .radial-container.connected .radial-btn:nth-child(1) { animation-delay: 0.05s; }
        .radial-container.connected .radial-btn:nth-child(2) { animation-delay: 0.1s; }
        .radial-container.connected .radial-btn:nth-child(3) { animation-delay: 0.15s; }
        .radial-container.connected .radial-btn:nth-child(4) { animation-delay: 0.2s; }
        .radial-container.connected .radial-btn:nth-child(5) { animation-delay: 0.25s; }
        .radial-container.connected .radial-btn:nth-child(6) { animation-delay: 0.3s; }
        .radial-container.connected .radial-btn:nth-child(7) { animation-delay: 0.35s; }
        .radial-container.connected .radial-btn:nth-child(8) { animation-delay: 0.4s; }

        /* Position 8 buttons in a circle, radius ~250px from center */
        .radial-btn:nth-of-type(1) { top: calc(50% - 250px - 65px); left: calc(50% - 65px); }           /* 0deg = top */
        .radial-btn:nth-of-type(2) { top: calc(50% - 177px - 65px); left: calc(50% + 177px - 65px); }   /* 45deg */
        .radial-btn:nth-of-type(3) { top: calc(50% - 65px); left: calc(50% + 250px - 65px); }            /* 90deg = right */
        .radial-btn:nth-of-type(4) { top: calc(50% + 177px - 65px); left: calc(50% + 177px - 65px); }   /* 135deg */
        .radial-btn:nth-of-type(5) { top: calc(50% + 250px - 65px); left: calc(50% - 65px); }           /* 180deg = bottom */
        .radial-btn:nth-of-type(6) { top: calc(50% + 177px - 65px); left: calc(50% - 177px - 65px); }   /* 225deg */
        .radial-btn:nth-of-type(7) { top: calc(50% - 65px); left: calc(50% - 250px - 65px); }            /* 270deg = left */
        .radial-btn:nth-of-type(8) { top: calc(50% - 177px - 65px); left: calc(50% - 177px - 65px); }   /* 315deg */
    </style>
</head>
<body>
    <!-- Exit Fullscreen Button (shown only when in fullscreen) -->
    <button id="exitFullscreenButton" class="exit-fullscreen-button" onclick="exitFullscreen()">‚úï Exit Fullscreen</button>

    <!-- Update Notification Banner -->
    <div id="updateNotification" style="display: none; background: rgba(59, 130, 246, 0.9); border: 2px solid #3b82f6; border-radius: 10px; padding: 15px 25px; margin-bottom: 20px; max-width: 800px; width: 100%;">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 20px;">
            <div style="flex: 1;">
                <div id="updateTitle" style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">üéâ Update Available!</div>
                <div id="updateMessage" style="font-size: 0.9em; opacity: 0.9;"></div>
                <div id="updateProgress" style="display: none; margin-top: 10px;">
                    <div style="background: rgba(255,255,255,0.3); border-radius: 10px; height: 20px; overflow: hidden;">
                        <div id="updateProgressBar" style="background: #22c55e; height: 100%; width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; font-size: 0.8em; font-weight: bold;"></div>
                    </div>
                </div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button id="updateDownloadBtn" onclick="downloadUpdate()" style="background: #22c55e; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; display: none;">Download</button>
                <button id="updateInstallBtn" onclick="installUpdate()" style="background: #22c55e; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: bold; display: none;">Restart & Install</button>
                <button onclick="closeUpdateNotification()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer;">Later</button>
            </div>
        </div>
    </div>

    <!-- Steam Lobby Overlay - HIDDEN: Multiplayer not ready -->
    <div class="steam-lobby-overlay" id="steamLobbyOverlay" onclick="toggleSteamLobbyPanel()" style="display: none !important;"></div>

    <!-- Steam Lobby Panel - HIDDEN: Multiplayer not ready -->
    <div class="steam-lobby-panel" id="steamLobbyPanel" style="display: none !important;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h3 style="margin: 0;">üéÆ Steam Multiplayer</h3>
            <button onclick="toggleSteamLobbyPanel()" style="background: none; border: none; color: #888; font-size: 24px; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
        </div>

        <!-- Status -->
        <div class="status-text" id="steamStatusText">
            Checking Steam connection...
        </div>

        <!-- Not in lobby view -->
        <div id="steamNoLobby">
            <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Select Game:</label>
            <select class="steam-game-select" id="steamGameSelect">
                <option value="golf">Golf (Par 3)</option>
                <option value="putting">Putting</option>
                <option value="bowling">Bowling</option>
                <option value="darts">Darts</option>
                <option value="baseball">Home Run Derby</option>
                <option value="soccer">Soccer Penalty</option>
                <option value="beer_pong">Beer Pong</option>
            </select>

            <label style="color: #888; font-size: 12px; display: block; margin: 10px 0 5px 0;">Max Players:</label>
            <select class="steam-game-select" id="steamMaxPlayers">
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
                <option value="4" selected>4 Players</option>
            </select>

            <button class="steam-btn steam-btn-primary" id="steamCreateBtn" onclick="steamCreateLobby()">
                ‚ûï Create Lobby
            </button>

            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Join Friend's Lobby:</label>
                <input type="text" id="steamJoinLobbyId" placeholder="Enter Lobby ID"
                    style="width: 100%; padding: 8px; background: #1a1a2e; border: 1px solid #333; border-radius: 4px; color: white; margin-bottom: 8px;">
                <button class="steam-btn steam-btn-secondary" onclick="steamJoinLobbyById()">
                    üîó Join Lobby
                </button>
            </div>
        </div>

        <!-- In lobby view -->
        <div id="steamInLobby" style="display: none;">
            <!-- Lobby ID display -->
            <div style="background: #1a1a2e; border: 1px solid #333; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                <label style="color: #888; font-size: 11px; display: block; margin-bottom: 4px;">Lobby ID (share with friends):</label>
                <div style="display: flex; gap: 6px; align-items: center;">
                    <input type="text" id="steamLobbyIdDisplay" readonly
                        style="flex: 1; padding: 6px; background: #0f0f1a; border: 1px solid #444; border-radius: 3px; color: #4ade80; font-family: monospace; font-size: 12px;">
                    <button class="steam-btn steam-btn-secondary" onclick="copyLobbyId()" style="padding: 6px 10px; font-size: 11px;">
                        üìã Copy
                    </button>
                </div>
            </div>

            <div style="display: flex; gap: 8px;">
                <button class="steam-btn steam-btn-secondary" style="flex: 1;" onclick="steamInviteFriend()">
                    üë• Invite Friend
                </button>
                <button class="steam-btn steam-btn-danger" style="flex: 1;" onclick="steamLeaveLobby()">
                    üö™ Leave
                </button>
            </div>

            <!-- Member list -->
            <div class="steam-members">
                <h4>Players in Lobby</h4>
                <div id="steamMemberList">
                    <!-- Members will be added here -->
                </div>
            </div>

            <!-- Start game button (host only) -->
            <button class="steam-btn steam-btn-primary" id="steamStartGameBtn" onclick="steamStartGame()" style="margin-top: 15px; display: none;">
                üöÄ Start Game
            </button>
        </div>
    </div>

    <!-- Connection Tab -->
    <button class="settings-tab-btn disconnected" id="settingsTabBtn" onclick="toggleSettingsPanel()">
        <span class="tab-dot"></span>
        Connection
    </button>

    <!-- Settings Panel Overlay -->
    <div class="settings-overlay" id="settingsOverlay" onclick="toggleSettingsPanel()"></div>

    <!-- Slide-out Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-panel-header">
            <h2>Settings</h2>
            <button class="settings-panel-close" onclick="toggleSettingsPanel()">&times;</button>
        </div>

        <!-- Connection Section -->
        <div class="settings-section">
            <div class="settings-section-label">Connection</div>
            <div class="settings-row">
                <div id="connectionStatus" class="connection-status disconnected" style="margin-bottom: 0; width: 100%;">
                    <div class="status-indicator disconnected"></div>
                    <span>Connecting to Launch Monitor...</span>
                </div>

                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 13px; color: #9ca3af;">Monitor:</span>
                    <select id="launchMonitorType" onchange="changeLaunchMonitorType()"
                            style="flex:1; padding: 6px 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.3);
                                   border-radius: 4px; color: white; font-size: 13px; cursor: pointer;">
                        <option value="nova">Nova (Auto)</option>
                        <option value="gspro">OpenAPI/Other</option>
                    </select>
                </div>

                <div id="gsproPortConfig" style="display: none; align-items: center; gap: 8px;">
                    <span style="font-size: 13px; color: #9ca3af;">Port:</span>
                    <input type="number" id="portInput" min="1" max="65535" value="921"
                           style="width: 70px; padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.3);
                                  border-radius: 4px; color: white; font-size: 13px; text-align: center;">
                    <button onclick="changePort()"
                            style="background: rgba(34, 197, 94, 0.3); border: 1px solid #22c55e; color: white;
                                   padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">Apply</button>
                </div>

                <div id="novaStatus" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(139, 92, 246, 0.2); border-radius: 8px; border: 1px solid #8b5cf6; font-size: 13px; color: #c4b5fd;">
                    <span id="novaStatusText">üîç Discovering Nova...</span>
                    <button onclick="retryNovaDiscovery()"
                            style="background: rgba(139, 92, 246, 0.3); border: 1px solid #8b5cf6; color: white;
                                   padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        üîÑ Retry
                    </button>
                </div>

                <div style="display: flex; gap: 10px;">
                    <div id="lmReadyIndicator" style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280;"></div>
                        <span style="color: #9ca3af;">LM Ready: Unknown</span>
                    </div>
                    <div id="lmBallIndicator" style="display: flex; align-items: center; gap: 6px; font-size: 13px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: #6b7280;"></div>
                        <span style="color: #9ca3af;">Ball: Unknown</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calibration Section -->
        <div class="settings-section">
            <div class="settings-section-label">Calibration</div>
            <div class="settings-row">
                <button class="settings-btn primary" onclick="showQuickCalibration()">‚ö° Quick Cal</button>
                <button class="settings-btn" onclick="showCalibrationWizard()">‚öôÔ∏è Advanced Cal</button>
                <button class="settings-btn danger" onclick="clearAllCalibration()">üóëÔ∏è Clear Calibration</button>
            </div>
        </div>

        <!-- Tools Section -->
        <div class="settings-section">
            <div class="settings-section-label">Tools</div>
            <div class="settings-row">
                <button class="settings-btn" onclick="toggleDebugPanel()">üîç Debug</button>
                <button class="settings-btn" onclick="showGraphicsSettings()">üé® Graphics</button>
            </div>
        </div>
    </div>

    <div id="debugPanel" style="background: rgba(0,0,0,0.5); border: 2px solid #fbbf24; border-radius: 10px; padding: 15px; margin: 20px auto; max-width: 800px; font-family: monospace; font-size: 0.9em; display: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <strong style="color: #fbbf24;">üîç Debug Panel</strong>
            <button onclick="toggleDebugPanel()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer;">Hide</button>
        </div>
        <div style="display: grid; grid-template-columns: auto 1fr; gap: 5px 15px; font-size: 0.85em;">
            <div style="color: #60a5fa;">Listening Port:</div>
            <div id="debugPort">--</div>

            <div style="color: #60a5fa;">Game Active:</div>
            <div id="debugGameActive">No</div>

            <div style="color: #60a5fa;">Last Shot Received:</div>
            <div id="debugLastShot">Never</div>

            <div style="color: #60a5fa;">Total Shots:</div>
            <div id="debugTotalShots">0</div>

            <div style="color: #60a5fa;">Status:</div>
            <div id="debugStatus">Waiting for Launch Monitor...</div>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); color: #888; font-size: 0.75em;">
            Press F12 to toggle DevTools console for detailed logs
        </div>
    </div>

    <div id="menuScreen">
        <div class="radial-container">
            <!-- Decorative radial lines (8 lines at 45-degree intervals) -->
            <div class="radial-line" style="transform: rotate(0deg);"></div>
            <div class="radial-line" style="transform: rotate(45deg);"></div>
            <div class="radial-line" style="transform: rotate(90deg);"></div>
            <div class="radial-line" style="transform: rotate(135deg);"></div>
            <div class="radial-line" style="transform: rotate(180deg);"></div>
            <div class="radial-line" style="transform: rotate(225deg);"></div>
            <div class="radial-line" style="transform: rotate(270deg);"></div>
            <div class="radial-line" style="transform: rotate(315deg);"></div>

            <!-- Center hub -->
            <div class="radial-hub">
                <img src="shanktuaryminigames.png" alt="Shanktuary" class="hub-logo">
            </div>

            <!-- 8 Game buttons arranged in a circle -->
            <button class="radial-btn game-putt" onclick="startPuttPractice()">
                <span class="btn-icon">‚õ≥</span>
                <span class="btn-label">Putt Practice</span>
            </button>
            <button class="radial-btn game-bowling" onclick="startBowling()">
                <span class="btn-icon">üé≥</span>
                <span class="btn-label">Bowling</span>
            </button>
            <button class="radial-btn game-darts2d" onclick="startGame()">
                <span class="btn-icon">üéØ</span>
                <span class="btn-label">Darts</span>
            </button>
            <button class="radial-btn game-beerpong" onclick="startBeerPong()">
                <span class="btn-icon">üç∫</span>
                <span class="btn-label">Beer Pong</span>
            </button>
            <button class="radial-btn game-baseball" onclick="startHomeRunDerby()">
                <span class="btn-icon">‚öæ</span>
                <span class="btn-label">Baseball</span>
            </button>
            <button class="radial-btn game-soccer" onclick="startSoccerPenalty()">
                <span class="btn-icon">‚öΩ</span>
                <span class="btn-label">Soccer</span>
            </button>
            <button class="radial-btn game-golf" onclick="startGolfPar3()">
                <span class="btn-icon">‚õ≥</span>
                <span class="btn-label">Golf Courses</span>
            </button>
            <!-- HIDDEN: Multiplayer feature not yet ready for release -->
            <button class="radial-btn game-steam" id="steamLobbyBtn" onclick="toggleSteamLobbyPanel()" style="display: none;">
                <span class="btn-icon">üéÆ</span>
                <span class="btn-label" id="steamLobbyBtnText">Online</span>
            </button>
        </div>
    </div>

    <div id="gameContainer" class="game-container">
        <button class="back-button" onclick="backToMenu()">‚Üê Back to Menu</button>
        <button class="test-button" onclick="restartGame()">üîÑ New Game</button>
        <button class="test-button" onclick="sendTestShot()">üß™ Test Shot</button>

        <div class="fullscreen-dropdown" id="fullscreenDropdown">
            <button class="fullscreen-button" onclick="toggleFullscreenDropdown()">üñ•Ô∏è Fullscreen ‚ñº</button>
            <div class="dropdown-content" id="fullscreenDropdownContent">
                <button onclick="selectComputerFullscreen()">
                    <span>üíª</span>
                    <div>
                        <div style="font-weight: bold;">Computer Fullscreen</div>
                        <div style="font-size: 0.85em; opacity: 0.7;">Standard fullscreen mode</div>
                    </div>
                </button>
                <button onclick="selectProjectorFullscreen()">
                    <span>üìΩÔ∏è</span>
                    <div>
                        <div style="font-weight: bold;">Projector Mode</div>
                        <div style="font-size: 0.85em; opacity: 0.7;">Separate window for projector</div>
                    </div>
                </button>
            </div>
        </div>

        <div id="gameContent"></div>

        <div class="data-panels">
            <div class="data-panel">
                <h4>‚õ≥ Ball Data</h4>
                <div class="data-row">
                    <span class="data-label">Ball Speed</span>
                    <span class="data-value highlight" id="dataBallSpeed">--</span>
                </div>
                <div class="data-row">
                    <span class="data-label">HLA (Horizontal)</span>
                    <span class="data-value" id="dataHLA">--</span>
                </div>
                <div class="data-row">
                    <span class="data-label">VLA (Vertical)</span>
                    <span class="data-value" id="dataVLA">--</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Total Spin</span>
                    <span class="data-value" id="dataTotalSpin">--</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Spin Axis</span>
                    <span class="data-value" id="dataSpinAxis">--</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Carry Distance</span>
                    <span class="data-value" id="dataCarry">--</span>
                </div>
                <div class="data-row" style="border-top: 1px solid rgba(255,255,255,0.2); margin-top: 10px; padding-top: 10px;">
                    <span class="data-label">‚öôÔ∏è Calibration</span>
                    <button id="activeCalibrationMode" onclick="toggleCalibrationProfile()" style="background: rgba(59, 130, 246, 0.3); border: 2px solid #60a5fa; color: #60a5fa; padding: 4px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold; transition: all 0.2s;" title="Click to switch calibration profile">
                        Computer
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="shotFeedback" class="shot-feedback">
        <div class="points"></div>
        <div class="message"></div>
        <div class="distance" style="font-size: 1.1em; margin-top: 10px; opacity: 0.9;"></div>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; overflow-y: auto; overflow-x: hidden;">
        <div style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; max-width: 1000px; width: 90%; border: 2px solid rgba(255,255,255,0.3); margin: 40px auto;">
            <h2 style="text-align: center; margin-bottom: 10px;">‚öôÔ∏è Calibration</h2>
            <p style="text-align: center; margin-bottom: 20px; opacity: 0.8; font-size: 0.95em;">
                Adjust where shots land on the dartboard. Each display mode has its own calibration profile.
            </p>

            <!-- Profile Selector Tabs -->
            <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 25px;">
                <button id="computerProfileTab" onclick="switchCalibrationProfile('computer')" style="padding: 12px 24px; background: rgba(59, 130, 246, 0.3); border: 2px solid #3b82f6; color: white; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.2s;">
                    üíª Computer Mode
                </button>
                <button id="projectorProfileTab" onclick="switchCalibrationProfile('projector')" style="padding: 12px 24px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: bold; transition: all 0.2s;">
                    üìΩÔ∏è Projector Mode
                </button>
            </div>

            <!-- Current Profile Display -->
            <div style="text-align: center; margin-bottom: 20px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <span style="opacity: 0.8; font-size: 0.9em;">Editing Profile:</span>
                <span id="activeProfileName" style="color: #60a5fa; font-weight: bold; margin-left: 8px;">Computer Mode</span>
            </div>

            <!-- Dartboard Preview with actual game view -->
            <div style="text-align: center; margin-bottom: 25px;">
                <h3 style="margin-bottom: 15px; font-size: 1.1em;">Live Dartboard Preview</h3>
                <div style="width: 100%; display: flex; justify-content: center; margin-bottom: 15px;">
                    <canvas id="calibrationDartboardCanvas" width="500" height="500" style="border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; background: #1a1a1a; cursor: crosshair;"></canvas>
                </div>
                <p style="margin-top: 10px; font-size: 0.85em; opacity: 0.7;">
                    <span style="color: #ff6b35;">üü† Orange</span> = Test shots |
                    <span style="color: #22c55e;">üü¢ Green</span> = Marked actual position |
                    <span style="color: #fbbf24;">üü° Yellow</span> = Preview |
                    Click dartboard to mark where dart actually landed
                </p>
            </div>

            <!-- Calibration Offsets -->
            <div style="background: rgba(0,0,0,0.3); padding: 25px; border-radius: 10px; margin-bottom: 20px;">
                <div style="margin-bottom: 25px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; font-size: 1.05em;">Vertical Offset (VLA) ¬∞</label>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="min-width: 60px; font-size: 0.9em; opacity: 0.8;">‚Üì Low</span>
                        <input type="number" id="vla_offset" value="0" step="0.1" style="flex: 1; padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; color: white; font-size: 1.2em; text-align: center; font-weight: bold;" oninput="updateCalibrationPreview()">
                        <span style="min-width: 60px; font-size: 0.9em; opacity: 0.8; text-align: right;">High ‚Üë</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 0.85em; opacity: 0.7;">
                        Enter any value (decimals allowed)
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; font-size: 1.05em;">Horizontal Offset (HLA) ¬∞</label>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span style="min-width: 60px; font-size: 0.9em; opacity: 0.8;">‚Üê Left</span>
                        <input type="number" id="hla_offset" value="0" step="0.1" style="flex: 1; padding: 12px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; color: white; font-size: 1.2em; text-align: center; font-weight: bold;" oninput="updateCalibrationPreview()">
                        <span style="min-width: 60px; font-size: 0.9em; opacity: 0.8; text-align: right;">Right ‚Üí</span>
                    </div>
                    <div style="text-align: center; margin-top: 8px; font-size: 0.85em; opacity: 0.7;">
                        Enter any value (decimals allowed)
                    </div>
                </div>

                <!-- Projection Settings -->
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <h4 style="margin-bottom: 10px; font-size: 1.05em; font-weight: bold;">üìΩÔ∏è Projection Settings</h4>
                    <p style="font-size: 0.85em; opacity: 0.8; margin-bottom: 15px;">Configure your projector resolution and physical screen size</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Resolution Width (px)</label>
                            <input type="number" id="proj_res_width" value="1440" step="1" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Resolution Height (px)</label>
                            <input type="number" id="proj_res_height" value="1080" step="1" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;">
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Screen Width (inches)</label>
                            <input type="number" id="proj_size_width" value="81" step="0.1" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Screen Height (inches)</label>
                            <input type="number" id="proj_size_height" value="71" step="0.1" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;">
                        </div>
                    </div>

                    <div style="background: rgba(59, 130, 246, 0.15); padding: 10px; border-radius: 5px; font-size: 0.85em; opacity: 0.9; margin-bottom: 10px;">
                        <div><strong>Pixels per inch:</strong> <span id="ppi_display">--</span></div>
                        <div><strong>Aspect ratio:</strong> <span id="aspect_display">--</span></div>
                    </div>

                    <button onclick="saveProjectionSettings()" style="width: 100%; background: rgba(139, 92, 246, 0.3); border: 2px solid #8b5cf6; color: white; padding: 10px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold; margin-bottom: 10px;">üíæ Save Projection Settings</button>
                </div>

                <!-- Test Shot Inputs -->
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <h4 style="margin-bottom: 15px; font-size: 1em; opacity: 0.9;">Test Shot Values (Launch Monitor Says)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.8;">HLA (Horizontal)</label>
                            <input type="number" id="test_hla" value="0" step="0.5" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;" oninput="updateCalibrationPreview()">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.8;">VLA (Vertical)</label>
                            <input type="number" id="test_vla" value="15" step="0.5" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;" oninput="updateCalibrationPreview()">
                        </div>
                    </div>
                </div>

                <!-- Grid Calibration System -->
                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2);">
                    <h4 style="margin-bottom: 10px; font-size: 1.05em; font-weight: bold;">üéØ Grid Calibration</h4>
                    <p style="font-size: 0.85em; opacity: 0.8; margin-bottom: 15px;">Mark where the dart actually landed vs. where the monitor said it went</p>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Actual HLA (where it really landed)</label>
                            <input type="number" id="actual_hla" value="" step="0.1" placeholder="Click dartboard or enter" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;" oninput="updateActualPositionFromInputs()">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 0.9em; opacity: 0.9;">Actual VLA (where it really landed)</label>
                            <input type="number" id="actual_vla" value="" step="0.1" placeholder="Click dartboard or enter" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1em;" oninput="updateActualPositionFromInputs()">
                        </div>
                    </div>

                    <div id="suggestedCalibration" style="background: rgba(34, 197, 94, 0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;">
                        <div style="font-weight: bold; margin-bottom: 8px; color: #22c55e;">‚ú® Suggested Calibration</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                            <div>HLA Offset: <strong id="suggested_hla">--</strong>¬∞</div>
                            <div>VLA Offset: <strong id="suggested_vla">--</strong>¬∞</div>
                        </div>
                        <button onclick="applySuggestedCalibration()" style="width: 100%; margin-top: 10px; background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 10px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">‚úì Apply Suggested Calibration</button>
                    </div>

                    <button onclick="clearMarkedPosition()" style="width: 100%; background: rgba(239, 68, 68, 0.3); border: 2px solid #ef4444; color: white; padding: 10px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">üóëÔ∏è Clear Marked Position</button>
                </div>
            </div>

            <!-- Profile Copy Section -->
            <div style="background: rgba(139, 92, 246, 0.15); border: 2px solid #8b5cf6; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                    <div style="flex: 1; min-width: 200px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">üìã Copy Settings</div>
                        <div style="font-size: 0.85em; opacity: 0.8;">Copy calibration from the other profile</div>
                    </div>
                    <button id="copyProfileButton" onclick="copyFromOtherProfile()" style="padding: 10px 20px; background: rgba(139, 92, 246, 0.3); border: 2px solid #8b5cf6; color: white; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold; white-space: nowrap;">
                        Copy from Projector ‚Üí
                    </button>
                </div>
            </div>

            <!-- Tips -->
            <div style="background: rgba(251, 191, 36, 0.15); border: 2px solid #fbbf24; padding: 15px; border-radius: 10px; margin-bottom: 25px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #fbbf24;">üí° Calibration Tips</div>
                <ul style="font-size: 0.85em; opacity: 0.9; margin-left: 20px; line-height: 1.6;">
                    <li>Hit a test shot where you normally aim</li>
                    <li>Adjust sliders until the dart lands where you expected</li>
                    <li>Computer and Projector modes have separate calibrations</li>
                    <li>Use "Copy Settings" to transfer calibration between profiles</li>
                </ul>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                <button onclick="sendCalibrationTestShot()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üß™ Test Shot</button>
                <button onclick="clearCalibrationTestShots()" style="background: rgba(251, 191, 36, 0.3); border: 2px solid #fbbf24; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üóëÔ∏è Clear Test Shots</button>
                <button onclick="saveCalibration()" style="background: rgba(59, 130, 246, 0.3); border: 2px solid #3b82f6; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üíæ Save Profile</button>
                <button onclick="resetCurrentProfile()" style="background: rgba(239, 68, 68, 0.3); border: 2px solid #ef4444; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üîÑ Reset</button>
            </div>

            <!-- Import/Export Buttons -->
            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 15px;">
                <button onclick="exportCalibration()" style="background: rgba(139, 92, 246, 0.3); border: 2px solid #8b5cf6; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üì§ Export Config</button>
                <button onclick="importCalibration()" style="background: rgba(139, 92, 246, 0.3); border: 2px solid #8b5cf6; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üì• Import Config</button>
                <button onclick="closeCalibration()" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚úï Close</button>
            </div>

            <!-- Hidden file input for import -->
            <input type="file" id="calibrationImportInput" accept=".json" style="display: none;" onchange="handleCalibrationImport(event)">
        </div>
    </div>

    <!-- Calibration Wizard Modal -->
    <div id="calibrationWizard" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 3000; overflow-y: auto; overflow-x: hidden;">
        <div style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; max-width: 900px; width: 90%; border: 2px solid rgba(255,255,255,0.3); margin: 40px auto;">

            <!-- Step 1: Welcome -->
            <div id="wizardStep1" class="wizard-step">
                <h2 style="text-align: center; margin-bottom: 20px; font-size: 2em;">üéØ Welcome to Shanktuary Golf Mini Games!</h2>
                <p style="text-align: center; font-size: 1.2em; margin-bottom: 30px; opacity: 0.9;">
                    To get the best accuracy, we recommend calibrating your setup.
                </p>

                <div style="background: rgba(59, 130, 246, 0.15); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: #60a5fa;">üìã What you'll need:</h3>
                    <ul style="font-size: 1.05em; line-height: 1.8; margin-left: 20px;">
                        <li>Your projector connected and displaying</li>
                        <li>Your launch monitor ready to hit shots</li>
                        <li>About 5-50 minutes (depending on shot count)</li>
                        <li>Golf balls to hit for calibration</li>
                    </ul>
                </div>

                <div style="background: rgba(251, 191, 36, 0.15); padding: 20px; border-radius: 10px; margin-bottom: 30px;">
                    <h3 style="margin-bottom: 10px; color: #fbbf24;">üí° How it works:</h3>
                    <p style="font-size: 1em; line-height: 1.6;">
                        You'll hit shots at the dartboard. For each shot, you'll mark where it actually appeared on your screen.
                        The system will automatically calculate the perfect calibration for your setup!
                    </p>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                    <button onclick="startCalibrationWizard()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 15px 40px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold;">üöÄ Start Calibration</button>
                    <button onclick="skipCalibrationWizard()" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 15px 40px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold;">Skip for Now</button>
                </div>
            </div>

            <!-- Step 1.5: Choose Number of Shots -->
            <div id="wizardStep2" class="wizard-step" style="display: none;">
                <h2 style="text-align: center; margin-bottom: 20px; font-size: 2em;">üéØ How Many Calibration Shots?</h2>
                <p style="text-align: center; font-size: 1.2em; margin-bottom: 30px; opacity: 0.9;">
                    More shots = Better accuracy, but takes more time
                </p>

                <div style="background: rgba(0,0,0,0.3); padding: 40px; border-radius: 10px; margin-bottom: 30px;">
                    <label style="display: block; text-align: center; margin-bottom: 20px; font-weight: bold; font-size: 1.3em;">Number of Calibration Shots</label>
                    <input type="number" id="wizard_shot_count" value="10" min="10" max="100" step="1"
                           style="width: 100%; max-width: 300px; margin: 0 auto; display: block; padding: 20px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; color: white; font-size: 2.5em; text-align: center; font-weight: bold;"
                           oninput="updateShotCountDisplay()">
                    <div style="text-align: center; margin-top: 15px; font-size: 1.1em; opacity: 0.8;">
                        <div style="margin-bottom: 8px;">‚¨áÔ∏è Minimum: 10 shots | Maximum: 100 shots ‚¨ÜÔ∏è</div>
                        <div id="shotCountEstimate" style="color: #60a5fa; font-weight: bold;">Estimated time: ~5 minutes</div>
                    </div>
                </div>

                <div style="background: rgba(59, 130, 246, 0.15); padding: 25px; border-radius: 10px; margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px; color: #60a5fa;">üí° Recommendations:</h3>
                    <ul style="font-size: 1.05em; line-height: 1.8; margin-left: 20px;">
                        <li><strong>10-15 shots:</strong> Quick calibration, good for testing</li>
                        <li><strong>20-30 shots:</strong> Balanced accuracy and time (recommended)</li>
                        <li><strong>50+ shots:</strong> Maximum accuracy for professional setups</li>
                    </ul>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                    <button onclick="wizardGoToStep(1)" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚Üê Back</button>
                    <button onclick="confirmShotCount()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">Next Step ‚Üí</button>
                </div>
            </div>

            <!-- Step 3: Projection Settings -->
            <div id="wizardStep3" class="wizard-step" style="display: none;">
                <h2 style="text-align: center; margin-bottom: 20px;">üìΩÔ∏è Step 2: Projection Settings</h2>
                <p style="text-align: center; margin-bottom: 30px; opacity: 0.9;">
                    Enter your projector resolution and physical screen size
                </p>

                <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 10px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 10px; font-weight: bold;">Resolution Width (px)</label>
                            <input type="number" id="wizard_res_width" value="1440" step="1" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1.1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 10px; font-weight: bold;">Resolution Height (px)</label>
                            <input type="number" id="wizard_res_height" value="1080" step="1" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1.1em;">
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 10px; font-weight: bold;">Screen Width (inches)</label>
                            <input type="number" id="wizard_size_width" value="81" step="0.1" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1.1em;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 10px; font-weight: bold;">Screen Height (inches)</label>
                            <input type="number" id="wizard_size_height" value="71" step="0.1" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 1.1em;">
                        </div>
                    </div>

                    <div id="wizard_ppi_display" style="background: rgba(59, 130, 246, 0.15); padding: 15px; border-radius: 8px; font-size: 0.95em;">
                        <div><strong>Pixels per inch:</strong> <span id="wizard_ppi">17.78</span></div>
                        <div><strong>Aspect ratio:</strong> <span id="wizard_aspect">4:3</span></div>
                    </div>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                    <button onclick="wizardGoToStep(1)" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚Üê Back</button>
                    <button onclick="wizardGoToStep(4)" style="background: rgba(59, 130, 246, 0.3); border: 2px solid #3b82f6; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">Next Step ‚Üí</button>
                </div>
            </div>

            <!-- Step 3: Start Game & Open Projector -->
            <div id="wizardStep4" class="wizard-step" style="display: none;">
                <h2 style="text-align: center; margin-bottom: 20px;">üéÆ Step 3: Setup</h2>
                <p style="text-align: center; margin-bottom: 30px; opacity: 0.9;">
                    Let's get your game and projector ready
                </p>

                <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 10px; margin-bottom: 25px;">
                    <h3 style="margin-bottom: 20px; text-align: center;">What will happen:</h3>
                    <ol style="font-size: 1.1em; line-height: 2; margin-left: 20px;">
                        <li>We'll start a Practice game</li>
                        <li>Open the projector window with a grid overlay</li>
                        <li>You'll hit shots and mark where they land</li>
                        <li>The system will calculate your calibration</li>
                    </ol>
                </div>

                <div style="background: rgba(251, 191, 36, 0.15); padding: 20px; border-radius: 10px; margin-bottom: 30px; text-align: center;">
                    <p style="font-size: 1.05em; margin: 0;">
                        ‚ö†Ô∏è Make sure your projector is already displaying and ready!
                    </p>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="wizardGoToStep(3)" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚Üê Back</button>
                    <button onclick="startWizardCalibrationSession()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">Start Setup ‚Üí</button>
                </div>
            </div>

            <!-- Step 4: Collecting Shots -->
            <div id="wizardStep5" class="wizard-step" style="display: none;">
                <h2 style="text-align: center; margin-bottom: 20px;">üéØ Step 4: Collect Calibration Shots</h2>
                <p style="text-align: center; margin-bottom: 30px; opacity: 0.9;">
                    Hit shots and mark where they actually appear on your screen
                </p>

                <div style="background: rgba(59, 130, 246, 0.2); padding: 25px; border-radius: 10px; margin-bottom: 25px; text-align: center;">
                    <div style="font-size: 3em; font-weight: bold; margin-bottom: 10px;">
                        <span id="shotsCollected">0</span> / <span id="shotsTarget">10</span>
                    </div>
                    <div style="font-size: 1.2em; opacity: 0.9;">Shots Collected</div>
                </div>

                <div style="background: rgba(0,0,0,0.3); padding: 25px; border-radius: 10px; margin-bottom: 25px;">
                    <h3 style="margin-bottom: 15px; text-align: center;">How to collect a shot:</h3>
                    <ol style="font-size: 1.05em; line-height: 1.8; margin-left: 20px;">
                        <li>Hit a shot at the dartboard</li>
                        <li>Look at your projector screen - see where the dart appeared</li>
                        <li>On THIS screen below, click where the dart actually landed</li>
                        <li>Repeat until you've collected all shots</li>
                    </ol>
                </div>

                <!-- Mini dartboard for marking positions -->
                <div style="text-align: center; margin-bottom: 25px;">
                    <h3 style="margin-bottom: 15px;">Click where the dart appeared:</h3>
                    <div style="width: 100%; display: flex; justify-content: center; margin-bottom: 15px;">
                        <canvas id="wizardDartboard" width="800" height="600" style="border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; background: #1a1a1a; cursor: crosshair; max-width: 100%; height: auto;"></canvas>
                    </div>
                    <p style="font-size: 0.9em; opacity: 0.7;">Grid covers entire projector area - click anywhere you see the dart land</p>
                </div>

                <div id="currentShotInfo" style="background: rgba(34, 197, 94, 0.15); padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none;">
                    <div style="text-align: center; font-size: 1.05em;">
                        <strong>Last shot:</strong> Monitor said HLA: <span id="lastMonitorHLA">--</span>¬∞, VLA: <span id="lastMonitorVLA">--</span>¬∞
                    </div>
                </div>

                <!-- Reshoot button - only visible when shot is waiting to be marked -->
                <div id="reshootButtonContainer" style="text-align: center; margin-bottom: 20px; display: none;">
                    <button onclick="reshootWizardShot()" style="background: rgba(251, 191, 36, 0.3); border: 2px solid #fbbf24; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        üîÑ Skip This Shot (Hit Another)
                    </button>
                    <p style="font-size: 0.9em; opacity: 0.7; margin-top: 8px;">Shot went off-screen? Click here to skip it and hit another shot</p>
                </div>

                <!-- Confirm shot button - visible when user has marked a position -->
                <div id="confirmShotContainer" style="text-align: center; margin-bottom: 20px; display: none;">
                    <div style="background: rgba(34, 197, 94, 0.2); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                        <p style="font-size: 1.1em; margin-bottom: 15px;">‚úì Position marked! Use arrow keys to fine-tune, then confirm.</p>
                        <p style="font-size: 0.9em; opacity: 0.8; margin: 0;">Arrow Keys: ‚Üê‚Üí‚Üë‚Üì to adjust position (1px per press, hold Shift for 10px)</p>
                    </div>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button onclick="confirmWizardShot()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                            ‚úì Confirm Shot
                        </button>
                        <button onclick="cancelPendingShot()" style="background: rgba(239, 68, 68, 0.3); border: 2px solid #ef4444; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                            ‚úï Cancel
                        </button>
                    </div>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="cancelWizardCalibration()" style="background: rgba(239, 68, 68, 0.3); border: 2px solid #ef4444; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚úï Cancel</button>
                    <button onclick="skipToResults()" id="skipToResultsBtn" style="background: rgba(251, 191, 36, 0.3); border: 2px solid #fbbf24; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; display: none;">Skip to Results ‚Üí</button>
                </div>
            </div>

            <!-- Step 5: Results & Apply -->
            <div id="wizardStep6" class="wizard-step" style="display: none;">
                <h2 style="text-align: center; margin-bottom: 20px;">‚úÖ Step 5: Calibration Complete!</h2>
                <p style="text-align: center; margin-bottom: 30px; opacity: 0.9;">
                    Based on your shots, here's the calculated calibration
                </p>

                <div style="background: rgba(34, 197, 94, 0.2); padding: 30px; border-radius: 10px; margin-bottom: 25px; text-align: center;">
                    <h3 style="margin-bottom: 20px;">Calculated Calibration Offsets:</h3>
                    <div style="font-size: 2em; font-weight: bold; margin-bottom: 15px;">
                        HLA: <span id="finalHLA">0.0</span>¬∞ | VLA: <span id="finalVLA">0.0</span>¬∞
                    </div>
                    <div style="font-size: 1em; opacity: 0.8;">
                        Based on <span id="finalShotCount">10</span> shots
                    </div>
                </div>

                <div style="background: rgba(0,0,0,0.3); padding: 25px; border-radius: 10px; margin-bottom: 25px;">
                    <h3 style="margin-bottom: 15px;">Shot Analysis:</h3>
                    <div id="shotAnalysis" style="font-size: 0.95em; line-height: 1.6;">
                        <!-- Will be populated with shot details -->
                    </div>
                </div>

                <div style="background: rgba(59, 130, 246, 0.15); padding: 20px; border-radius: 10px; margin-bottom: 30px; text-align: center;">
                    <p style="font-size: 1.05em; margin: 0;">
                        üí° This calibration will be saved to your Projector profile
                    </p>
                </div>

                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button onclick="cancelWizardCalibration()" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">Recalibrate</button>
                    <button onclick="applyWizardCalibration()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">‚úì Apply & Finish</button>
                </div>
            </div>

        </div>
    </div>

    <!-- Quick Calibration Modal (Tap Cal) -->
    <div id="quickCalModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 3000; overflow-y: auto;">
        <div style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px; max-width: 560px; width: 90%; border: 2px solid rgba(34,197,94,0.5); margin: 30px auto;">
            <h2 style="text-align: center; margin-bottom: 5px; font-size: 1.6em;">‚ö° Tap Calibration</h2>
            <p style="text-align: center; font-size: 0.9em; margin-bottom: 15px; opacity: 0.7;">
                Throw darts and tell us where they land
            </p>

            <!-- Profile toggle tabs -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px;">
                <button id="qcProfileComputer" onclick="switchQuickCalProfile('computer')" style="background: rgba(59,130,246,0.4); border: 2px solid #3b82f6; color: white; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold;">Computer</button>
                <button id="qcProfileProjector" onclick="switchQuickCalProfile('projector')" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: rgba(255,255,255,0.6); padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px;">Projector</button>
            </div>

            <!-- Pop Out Board button (for projector users) -->
            <div style="text-align: center; margin-bottom: 12px;">
                <button onclick="popOutQuickCalBoard()" id="qcPopOutBtn" style="background: rgba(168,85,247,0.2); border: 1px solid rgba(168,85,247,0.5); color: #a855f7; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 13px;">Pop Out Board (for projector)</button>
            </div>

            <!-- Shot count + progress dots -->
            <div style="text-align: center; margin-bottom: 8px;">
                <span id="qcShotCount" style="font-size: 1.05em; font-weight: bold; color: rgba(255,255,255,0.8);">0 shots recorded</span>
                <span style="font-size: 0.8em; color: rgba(255,255,255,0.4);"> (minimum 3)</span>
            </div>
            <div id="qcProgressDots" style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px;">
                <div class="qc-dot" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05);">1</div>
                <div class="qc-dot" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05);">2</div>
                <div class="qc-dot" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05);">3</div>
                <div class="qc-dot" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05);">4</div>
                <div class="qc-dot" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05);">5</div>
            </div>

            <!-- Dartboard canvas (shows recorded shots) -->
            <div style="display: flex; justify-content: center; margin-bottom: 12px;">
                <canvas id="quickCalCanvas" width="280" height="280" style="border-radius: 10px; background: #1a1a2e;"></canvas>
            </div>

            <!-- Status message -->
            <div id="qcStatus" style="text-align: center; font-size: 1.1em; font-weight: bold; margin-bottom: 12px; color: #22c55e; min-height: 1.4em;">
                Throw a dart at the board!
            </div>

            <!-- Segment grid (hidden until shot is detected) -->
            <div id="qcSegmentGrid" style="display: none; background: rgba(0,0,0,0.3); border-radius: 12px; padding: 15px; margin-bottom: 15px;">
                <div style="text-align: center; margin-bottom: 10px; font-size: 0.9em; color: rgba(255,255,255,0.6);">Where did it land?</div>
                <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 10px;">
                    <button onclick="quickCalSegmentTapped('bullseye')" style="background: rgba(220,38,38,0.3); border: 2px solid #dc2626; color: white; padding: 8px 18px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; min-height: 42px;">Bullseye</button>
                    <button onclick="quickCalSegmentTapped('bull')" style="background: rgba(22,163,74,0.3); border: 2px solid #16a34a; color: white; padding: 8px 18px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold; min-height: 42px;">Bull</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; max-width: 300px; margin: 0 auto;">
                    <button onclick="quickCalSegmentTapped(1)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">1</button>
                    <button onclick="quickCalSegmentTapped(2)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">2</button>
                    <button onclick="quickCalSegmentTapped(3)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">3</button>
                    <button onclick="quickCalSegmentTapped(4)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">4</button>
                    <button onclick="quickCalSegmentTapped(5)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">5</button>
                    <button onclick="quickCalSegmentTapped(6)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">6</button>
                    <button onclick="quickCalSegmentTapped(7)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">7</button>
                    <button onclick="quickCalSegmentTapped(8)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">8</button>
                    <button onclick="quickCalSegmentTapped(9)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">9</button>
                    <button onclick="quickCalSegmentTapped(10)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">10</button>
                    <button onclick="quickCalSegmentTapped(11)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">11</button>
                    <button onclick="quickCalSegmentTapped(12)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">12</button>
                    <button onclick="quickCalSegmentTapped(13)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">13</button>
                    <button onclick="quickCalSegmentTapped(14)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">14</button>
                    <button onclick="quickCalSegmentTapped(15)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">15</button>
                    <button onclick="quickCalSegmentTapped(16)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">16</button>
                    <button onclick="quickCalSegmentTapped(17)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">17</button>
                    <button onclick="quickCalSegmentTapped(18)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">18</button>
                    <button onclick="quickCalSegmentTapped(19)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">19</button>
                    <button onclick="quickCalSegmentTapped(20)" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 16px; font-weight: bold; min-height: 44px;">20</button>
                </div>
                <div style="text-align: center; margin-top: 8px;">
                    <button onclick="quickCalDismissGrid()" style="background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer; font-size: 0.85em; text-decoration: underline;">Missed the board? Dismiss</button>
                </div>
            </div>

            <!-- Action buttons -->
            <div style="display: flex; gap: 12px; justify-content: center; margin-bottom: 12px;">
                <button onclick="cancelQuickCal()" style="background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: rgba(255,255,255,0.8); padding: 10px 24px; border-radius: 8px; cursor: pointer; font-size: 14px;">Cancel</button>
                <button onclick="quickCalUndo()" id="qcUndoBtn" style="display: none; background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251,191,36,0.5); color: #fbbf24; padding: 10px 24px; border-radius: 8px; cursor: pointer; font-size: 14px;">Undo Last</button>
                <button onclick="applyQuickCalibration()" id="qcApplyBtn" disabled style="background: rgba(34, 197, 94, 0.2); border: 2px solid rgba(34,197,94,0.3); color: rgba(34,197,94,0.5); padding: 10px 24px; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: bold;">Apply Calibration</button>
            </div>

            <!-- Link to advanced -->
            <div style="text-align: center;">
                <a href="#" onclick="cancelQuickCal(); showCalibrationWizard(); return false;" style="color: rgba(255,255,255,0.4); font-size: 0.85em; text-decoration: underline;">Need more precision? Use Advanced Calibration</a>
            </div>
        </div>
    </div>

    <!-- Graphics Settings Modal -->
    <div id="graphicsSettings" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 3000; overflow-y: auto;">
        <div style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 40px; max-width: 700px; width: 90%; border: 2px solid rgba(255,255,255,0.3); margin: 60px auto;">
            <h2 style="text-align: center; margin-bottom: 10px; font-size: 2em;">üé® Graphics Settings</h2>
            <p style="text-align: center; font-size: 1em; margin-bottom: 30px; opacity: 0.8;">
                These settings apply to all games
            </p>

            <!-- Brightness Settings -->
            <div style="background: rgba(0,0,0,0.3); padding: 25px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="margin-bottom: 20px; color: #fbbf24; font-size: 1.3em;">üí° Lighting</h3>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; font-size: 1.05em;">Ambient Light (Base Brightness)</label>
                    <input type="range" id="ambientLight" min="0.5" max="3.0" step="0.1" value="1.2"
                           style="width: 100%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer;"
                           oninput="updateLightingPreview()">
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.9em; opacity: 0.7;">
                        <span>Darker (0.5)</span>
                        <span id="ambientLightValue" style="font-weight: bold; color: #fbbf24;">1.2</span>
                        <span>Brighter (3.0)</span>
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: bold; font-size: 1.05em;">Sun Light (Directional Brightness)</label>
                    <input type="range" id="sunLight" min="0.5" max="4.0" step="0.1" value="1.5"
                           style="width: 100%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer;"
                           oninput="updateLightingPreview()">
                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.9em; opacity: 0.7;">
                        <span>Softer (0.5)</span>
                        <span id="sunLightValue" style="font-weight: bold; color: #fbbf24;">1.5</span>
                        <span>Stronger (4.0)</span>
                    </div>
                </div>

                <div style="background: rgba(59, 130, 246, 0.15); padding: 15px; border-radius: 8px; margin-top: 20px;">
                    <p style="font-size: 0.95em; line-height: 1.6; margin: 0;">
                        <strong style="color: #60a5fa;">üí° Tip:</strong> If games look too dark, increase both values. If too washed out, decrease them.
                    </p>
                </div>
            </div>

            <!-- Preset Buttons -->
            <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-bottom: 25px;">
                <h3 style="margin-bottom: 15px; color: #60a5fa; font-size: 1.2em;">‚ö° Quick Presets</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px;">
                    <button onclick="applyLightingPreset('dark')" style="background: rgba(100,100,100,0.3); border: 2px solid #666; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">üåô Dark</button>
                    <button onclick="applyLightingPreset('normal')" style="background: rgba(59, 130, 246, 0.3); border: 2px solid #3b82f6; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">‚òÄÔ∏è Normal</button>
                    <button onclick="applyLightingPreset('bright')" style="background: rgba(251, 191, 36, 0.3); border: 2px solid #fbbf24; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">‚ú® Bright</button>
                    <button onclick="applyLightingPreset('max')" style="background: rgba(255, 255, 255, 0.3); border: 2px solid #fff; color: white; padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95em; font-weight: bold;">üîÜ Max</button>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                <button onclick="hideGraphicsSettings()" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); color: white; padding: 15px 35px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">Cancel</button>
                <button onclick="saveGraphicsSettings()" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e; color: white; padding: 15px 35px; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">üíæ Save Settings</button>
            </div>
        </div>
    </div>

    <script>
        let currentGame = null;
        let isConnected = false;
        let totalShotsReceived = 0;

        // Auto-updater handler
        if (window.electronAPI) {
            window.electronAPI.onUpdateStatus((status) => {
                const { event, data } = status;
                console.log('Update event:', event, data);

                const notification = document.getElementById('updateNotification');
                const title = document.getElementById('updateTitle');
                const message = document.getElementById('updateMessage');
                const downloadBtn = document.getElementById('updateDownloadBtn');
                const installBtn = document.getElementById('updateInstallBtn');
                const progress = document.getElementById('updateProgress');
                const progressBar = document.getElementById('updateProgressBar');

                switch (event) {
                    case 'checking-for-update':
                        console.log('Checking for updates...');
                        break;

                    case 'update-available':
                        notification.style.display = 'block';
                        title.textContent = 'üéâ Update Available!';
                        message.textContent = `Version ${data.version} is available. Click Download to start downloading.`;
                        downloadBtn.style.display = 'inline-block';
                        installBtn.style.display = 'none';
                        progress.style.display = 'none';
                        break;

                    case 'update-not-available':
                        console.log('App is up to date!');
                        break;

                    case 'download-progress':
                        notification.style.display = 'block';
                        title.textContent = '‚¨áÔ∏è Downloading Update...';
                        message.textContent = `Downloading update: ${data.percent.toFixed(1)}%`;
                        downloadBtn.style.display = 'none';
                        installBtn.style.display = 'none';
                        progress.style.display = 'block';
                        progressBar.style.width = `${data.percent}%`;
                        break;

                    case 'update-downloaded':
                        notification.style.display = 'block';
                        title.textContent = '‚úÖ Update Ready!';
                        message.textContent = `Version ${data.version} has been downloaded. Click Install to restart and update.`;
                        downloadBtn.style.display = 'none';
                        installBtn.style.display = 'inline-block';
                        progress.style.display = 'none';
                        break;

                    case 'error':
                        notification.style.display = 'block';
                        notification.style.background = 'rgba(239, 68, 68, 0.9)';
                        notification.style.borderColor = '#ef4444';
                        title.textContent = '‚ùå Update Error';
                        message.textContent = `Could not check for updates: ${data.message}`;
                        downloadBtn.style.display = 'none';
                        installBtn.style.display = 'none';
                        progress.style.display = 'none';
                        break;
                }
            });
        }

        function downloadUpdate() {
            console.log('Starting download...');
            if (window.electronAPI) {
                window.electronAPI.downloadUpdate();
            }
        }

        function installUpdate() {
            console.log('Installing update and restarting...');
            if (window.electronAPI) {
                window.electronAPI.quitAndInstall();
            }
        }

        function closeUpdateNotification() {
            document.getElementById('updateNotification').style.display = 'none';
        }

        // Calibration profiles - NEW SYSTEM with scale factors
        let calibrationProfiles = {
            computer: {
                // New scale-based calibration
                hla_scale: 0.0667,  // Default: 15¬∞ spans full dartboard (1/15)
                vla_scale: -0.10,   // Default: 10¬∞ spans full dartboard (1/10), negative for inverted Y
                hla_offset: 0,      // Centering offset (normalized, -1 to 1)
                vla_offset: 0.5,    // VLA center offset (normalized, -1 to 1)
                // Legacy offsets (deprecated, for migration)
                hla_offset_legacy: 0,
                vla_offset_legacy: 0
            },
            projector: {
                hla_scale: 0.0667,
                vla_scale: -0.10,
                hla_offset: 0,
                vla_offset: 0.5,
                hla_offset_legacy: 0,
                vla_offset_legacy: 0
            }
        };

        let activeCalibrationProfile = 'computer'; // Current active profile

        // Expose calibration to game modules
        window.calibrationProfiles = calibrationProfiles;
        window.activeCalibrationProfile = activeCalibrationProfile;

        // Calibration test shots (separate from game darts)
        let calibrationTestShots = [];
        let calibrationMarkedPosition = null; // {hla, vla} for where user marks actual position

        // Projector mode
        let projectorChannel = new BroadcastChannel('nova_games_projector');
        let projectorWindow = null;
        let projectorMode = false;

        // Expose projectorMode and projectorChannel to global scope for darts_multiplayer.js
        window.projectorMode = projectorMode;
        window.projectorChannel = projectorChannel;

        // Load calibration profiles from localStorage
        function loadCalibration() {
            const saved = localStorage.getItem('darts_calibration_profiles');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);

                    // MIGRATION: Convert old format to new format
                    ['computer', 'projector'].forEach(profileName => {
                        if (loaded[profileName]) {
                            const profile = loaded[profileName];

                            // Check if this is old format (only has hla_offset/vla_offset)
                            if (profile.hla_scale === undefined) {
                                console.log(`Migrating ${profileName} profile from old to new format`);

                                // Migrate to new format with default scale factors
                                calibrationProfiles[profileName] = {
                                    hla_scale: 0.0667,  // Default
                                    vla_scale: -0.10,   // Default
                                    hla_offset: profile.hla_offset || 0,
                                    vla_offset: (profile.vla_offset || 0) / 10.0 + 0.5,  // Convert old offset to new system
                                    hla_offset_legacy: profile.hla_offset || 0,
                                    vla_offset_legacy: profile.vla_offset || 0
                                };
                            } else {
                                // New format, use as-is
                                calibrationProfiles[profileName] = profile;
                            }
                        }
                    });

                    console.log('Loaded and migrated calibration profiles:', calibrationProfiles);

                    // Update global reference
                    window.calibrationProfiles = calibrationProfiles;
                } catch (e) {
                    console.error('Error loading calibration:', e);
                }
            }

            // Auto-select profile based on projector mode
            updateActiveProfile();
        }

        // Update active calibration profile based on current mode
        function updateActiveProfile(manualOverride = false) {
            if (!manualOverride) {
                activeCalibrationProfile = projectorMode ? 'projector' : 'computer';
            }
            window.activeCalibrationProfile = activeCalibrationProfile; // Update global
            console.log('Active calibration profile:', activeCalibrationProfile);

            // Update the indicator button in the UI
            const indicator = document.getElementById('activeCalibrationMode');
            if (indicator) {
                const isProjector = activeCalibrationProfile === 'projector';
                indicator.textContent = isProjector ? 'Projector' : 'Computer';
                indicator.style.borderColor = isProjector ? '#a78bfa' : '#60a5fa';
                indicator.style.color = isProjector ? '#a78bfa' : '#60a5fa';
                indicator.style.background = isProjector ? 'rgba(139, 92, 246, 0.3)' : 'rgba(59, 130, 246, 0.3)';
            }
        }

        // Manual toggle between calibration profiles
        function toggleCalibrationProfile() {
            // Toggle between computer and projector
            activeCalibrationProfile = activeCalibrationProfile === 'computer' ? 'projector' : 'computer';
            window.activeCalibrationProfile = activeCalibrationProfile;

            console.log('üîÑ Manually switched calibration profile to:', activeCalibrationProfile);

            // Update UI with manual override flag
            updateActiveProfile(true);

            // Show feedback
            const profileName = activeCalibrationProfile === 'computer' ? 'Computer' : 'Projector';
            showShotFeedback(0, `Switched to ${profileName} Calibration`);
        }

        // Update debug panel
        function updateDebugPanel(field, value) {
            const elem = document.getElementById('debug' + field);
            if (elem) elem.textContent = value;
        }

        // Launch Monitor Status Indicators
        function updateLaunchMonitorStatus(status) {
            console.log('üì° Launch Monitor Status Update:', status);

            // Update Ready Indicator
            const readyIndicator = document.getElementById('lmReadyIndicator');
            if (readyIndicator) {
                const dot = readyIndicator.querySelector('div');
                const text = readyIndicator.querySelector('span');
                if (status.isReady === true) {
                    dot.style.background = '#22c55e'; // Green
                    text.textContent = 'LM Ready: Yes';
                    text.style.color = '#22c55e';
                } else if (status.isReady === false) {
                    dot.style.background = '#ef4444'; // Red
                    text.textContent = 'LM Ready: No';
                    text.style.color = '#ef4444';
                } else {
                    dot.style.background = '#6b7280'; // Gray
                    text.textContent = 'LM Ready: Unknown';
                    text.style.color = '#9ca3af';
                }
            }

            // Update Ball Detected Indicator
            const ballIndicator = document.getElementById('lmBallIndicator');
            if (ballIndicator) {
                const dot = ballIndicator.querySelector('div');
                const text = ballIndicator.querySelector('span');
                if (status.ballDetected === true) {
                    dot.style.background = '#22c55e'; // Green
                    text.textContent = 'Ball: Detected';
                    text.style.color = '#22c55e';
                } else if (status.ballDetected === false) {
                    dot.style.background = '#ef4444'; // Red
                    text.textContent = 'Ball: No';
                    text.style.color = '#ef4444';
                } else {
                    dot.style.background = '#6b7280'; // Gray
                    text.textContent = 'Ball: Unknown';
                    text.style.color = '#9ca3af';
                }
            }
        }

        // Listen for launch monitor status updates
        if (window.electronAPI && window.electronAPI.onLaunchMonitorStatus) {
            window.electronAPI.onLaunchMonitorStatus((status) => {
                updateLaunchMonitorStatus(status);
            });
        }

        // Toggle settings panel
        function toggleSettingsPanel() {
            document.getElementById('settingsPanel').classList.toggle('open');
            document.getElementById('settingsOverlay').classList.toggle('open');
        }

        // ==================== STEAM LOBBY FUNCTIONS ====================

        let steamNetwork = null;
        let steamPanelOpen = false;

        // Initialize Steam on page load
        async function initSteamLobby() {
            steamNetwork = getSteamNetwork();

            try {
                const available = await steamNetwork.initialize();
                updateSteamUI(available);

                if (available) {
                    // Set up event handlers
                    steamNetwork.on('lobby-created', onLobbyCreated);
                    steamNetwork.on('lobby-joined', onLobbyJoined);
                    steamNetwork.on('member-joined', onMemberChanged);
                    steamNetwork.on('member-left', onMemberChanged);
                    steamNetwork.on('members-updated', onMembersUpdated);
                    steamNetwork.on('disconnected', onLobbyDisconnected);
                    steamNetwork.on('error', onSteamError);

                    // Set up message handler
                    steamNetwork.onMessage(handleSteamMessage);
                }
            } catch (err) {
                console.error('Steam init error:', err);
                updateSteamStatus('Steam initialization failed', 'error');
            }
        }

        function toggleSteamLobbyPanel() {
            steamPanelOpen = !steamPanelOpen;
            document.getElementById('steamLobbyPanel').classList.toggle('open', steamPanelOpen);
            document.getElementById('steamLobbyOverlay').classList.toggle('open', steamPanelOpen);
        }

        function updateSteamUI(available) {
            const btn = document.getElementById('steamLobbyBtn');
            const statusText = document.getElementById('steamStatusText');
            const createBtn = document.getElementById('steamCreateBtn');

            if (available) {
                const player = steamNetwork.getLocalPlayer();
                updateSteamStatus(`Connected as ${player?.name || 'Unknown'}`, 'online');
                createBtn.disabled = false;
            } else {
                updateSteamStatus('Steam not available - install steamworks.js and run Steam', 'error');
                createBtn.disabled = true;
            }
        }

        function updateSteamStatus(text, type = '') {
            const statusText = document.getElementById('steamStatusText');
            statusText.textContent = text;
            statusText.className = 'status-text ' + type;
        }

        async function steamCreateLobby() {
            if (!steamNetwork || !steamNetwork.isSteamAvailable()) {
                updateSteamStatus('Steam not available', 'error');
                return;
            }

            const gameType = document.getElementById('steamGameSelect').value;
            const maxPlayers = parseInt(document.getElementById('steamMaxPlayers').value);

            updateSteamStatus('Creating lobby...', '');
            document.getElementById('steamCreateBtn').disabled = true;

            const result = await steamNetwork.createLobby(gameType, maxPlayers, 'friends_only');

            if (result.success) {
                updateSteamStatus('Lobby created! Share the ID with friends.', 'online');
                showInLobbyUI(true);
                // Display the lobby ID
                const lobbyIdDisplay = document.getElementById('steamLobbyIdDisplay');
                if (lobbyIdDisplay && result.lobbyId) {
                    lobbyIdDisplay.value = result.lobbyId;
                }
            } else {
                updateSteamStatus('Failed to create lobby: ' + result.error, 'error');
                document.getElementById('steamCreateBtn').disabled = false;
            }
        }

        function copyLobbyId() {
            const lobbyIdDisplay = document.getElementById('steamLobbyIdDisplay');
            if (lobbyIdDisplay && lobbyIdDisplay.value) {
                navigator.clipboard.writeText(lobbyIdDisplay.value).then(() => {
                    updateSteamStatus('Lobby ID copied to clipboard!', 'online');
                }).catch(() => {
                    // Fallback: select the text
                    lobbyIdDisplay.select();
                    document.execCommand('copy');
                    updateSteamStatus('Lobby ID copied!', 'online');
                });
            }
        }

        async function steamInviteFriend() {
            if (!steamNetwork) return;

            const result = await steamNetwork.inviteFriend();
            if (!result.success) {
                updateSteamStatus('Failed to open invite: ' + result.error, 'error');
            } else if (result.lobbyId) {
                // Overlay didn't open, show lobby ID for manual sharing
                updateSteamStatus('Lobby ID: ' + result.lobbyId, 'online');
                // Copy to clipboard
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(result.lobbyId);
                    updateSteamStatus('Lobby ID copied to clipboard: ' + result.lobbyId, 'online');
                }
            }
        }

        async function steamJoinLobbyById() {
            if (!steamNetwork) return;

            const lobbyIdInput = document.getElementById('steamJoinLobbyId');
            const lobbyId = lobbyIdInput.value.trim();

            if (!lobbyId) {
                updateSteamStatus('Please enter a lobby ID', 'error');
                return;
            }

            updateSteamStatus('Joining lobby...', '');
            const result = await steamNetwork.joinLobby(lobbyId);

            if (result.success) {
                updateSteamStatus('Joined lobby!', 'online');
                showInLobbyUI(true);
                document.getElementById('steamCreateBtn').disabled = true;
                lobbyIdInput.value = '';
            } else {
                updateSteamStatus('Failed to join: ' + result.error, 'error');
            }
        }

        async function steamLeaveLobby() {
            if (!steamNetwork) return;

            await steamNetwork.leaveLobby();
            showInLobbyUI(false);
            updateSteamStatus('Left lobby', '');
            document.getElementById('steamCreateBtn').disabled = false;
        }

        async function steamStartGame() {
            if (!steamNetwork || !steamNetwork.isLobbyHost()) return;

            const gameType = steamNetwork.getGameType();
            const members = steamNetwork.getMembers();

            // Store lobby info for the game to use
            localStorage.setItem('steamLobbyActive', 'true');
            localStorage.setItem('steamGameType', gameType);
            localStorage.setItem('steamPlayers', JSON.stringify(members));
            localStorage.setItem('steamIsHost', steamNetwork.isLobbyHost() ? 'true' : 'false');

            // Broadcast game start to all players
            await steamNetwork.startGame({
                gameType: gameType,
                players: members
            });

            // Launch the appropriate game
            launchSteamGame(gameType);
        }

        function launchSteamGame(gameType) {
            // Close the panel
            toggleSteamLobbyPanel();

            // Save Steam lobby data for the game to pick up
            const lobbyData = {
                lobbyId: steamNetwork.getLobbyId(),
                isHost: steamNetwork.isLobbyHost()
            };

            // Get Steam players and convert to game format
            const steamMembers = steamNetwork.getMembers();
            const playerColors = ['#4ade80', '#60a5fa', '#f472b6', '#fbbf24', '#a78bfa', '#34d399', '#fb7185', '#38bdf8'];

            const gamePlayers = steamMembers.map((member, idx) => ({
                name: member.name || 'Player ' + (idx + 1),
                color: playerColors[idx % playerColors.length],
                steamId: member.steamId
            }));

            console.log('üéÆ Steam players for game:', gamePlayers);

            // Set game mode and lobby data based on game type
            const gameModeKeys = {
                'golf': 'golfGameMode',
                'putting': 'puttingGameMode',
                'bowling': 'bowlingGameMode',
                'darts': 'dartsGameMode',
                'baseball': 'homerunGameMode',
                'soccer': 'soccerGameMode',
                'beer_pong': 'beerPongGameMode'
            };

            const lobbyKeys = {
                'golf': 'golfSteamLobby',
                'putting': 'puttingSteamLobby',
                'bowling': 'bowlingSteamLobby',
                'darts': 'dartsSteamLobby',
                'baseball': 'homerunSteamLobby',
                'soccer': 'soccerSteamLobby',
                'beer_pong': 'beerPongSteamLobby'
            };

            const playerKeys = {
                'golf': 'golfPar3Players',
                'putting': 'puttingPlayers',
                'bowling': 'bowlingPlayers',
                'darts': 'dartsPlayers',
                'baseball': 'homerunPlayers',
                'soccer': 'soccerPlayers',
                'beer_pong': 'beerPongPlayers'
            };

            // Set Steam mode for this game
            if (gameModeKeys[gameType]) {
                localStorage.setItem(gameModeKeys[gameType], 'steam');
                localStorage.setItem(lobbyKeys[gameType], JSON.stringify(lobbyData));
                // Store the players for the game to use
                if (playerKeys[gameType]) {
                    localStorage.setItem(playerKeys[gameType], JSON.stringify(gamePlayers));
                }
                console.log(`üåê Steam mode enabled for ${gameType}:`, lobbyData, 'players:', gamePlayers);
            }

            // Launch the corresponding game
            // For Steam games, bypass the setup screens and launch directly
            switch (gameType) {
                case 'golf':
                    // Launch golf directly with Steam players (skip setup screen)
                    launchGolfPar3DirectForSteam(gamePlayers);
                    break;
                case 'putting':
                    startPuttPractice();
                    break;
                case 'bowling':
                    startBowling();
                    break;
                case 'darts':
                    startGame(); // 2D Darts
                    break;
                case 'baseball':
                    startHomeRunDerby();
                    break;
                case 'soccer':
                    startSoccerPenalty();
                    break;
                case 'beer_pong':
                    startBeerPong();
                    break;
            }
        }

        // Direct launch for Steam multiplayer - bypasses the setup screen
        function launchGolfPar3DirectForSteam(players) {
            console.log('üåê Launching golf directly with Steam players:', players);

            // Use saved settings or defaults
            const savedStimp = localStorage.getItem('golfGreenStimp') || '10';
            const savedCourse = localStorage.getItem('golfSelectedCourse') || 'shanktuary';
            const savedHoles = localStorage.getItem('golfSelectedHoles') || '"all"';

            // Ensure all required localStorage is set for the game
            localStorage.setItem('golfPar3Players', JSON.stringify(players));
            localStorage.setItem('golfPar3CurrentPlayer', '0');
            localStorage.setItem('golfGreenStimp', savedStimp);
            localStorage.setItem('golfSelectedCourse', savedCourse);
            localStorage.setItem('golfSelectedHoles', savedHoles);
            localStorage.setItem('golfGimmieCircles', 'true');

            // Make sure game mode stays as 'steam' (not overwritten to 'local')
            localStorage.setItem('golfGameMode', 'steam');

            // Get course name for window title
            const courseNames = {
                shanktuary: 'Shanktuary Hills Golf',
                rockwiga: 'Rockwiga Country Club'
            };
            const courseName = courseNames[savedCourse] || 'Shanktuary Hills Golf';

            // Open game window directly
            window.electronAPI.openGameWindow({
                url: 'golf-par3.html',
                title: courseName + ' - Steam Multiplayer',
                width: 1400,
                height: 900,
                playerData: {
                    players: players,
                    currentPlayer: 0,
                    gimmieCircles: true
                }
            });

            console.log('üéÆ Golf game launched with players:', players.map(p => p.name).join(', '));
        }

        function showInLobbyUI(inLobby) {
            document.getElementById('steamNoLobby').style.display = inLobby ? 'none' : 'block';
            document.getElementById('steamInLobby').style.display = inLobby ? 'block' : 'none';

            const btn = document.getElementById('steamLobbyBtn');
            btn.classList.toggle('connected', inLobby);
            document.getElementById('steamLobbyBtnText').textContent = inLobby ? 'In Lobby' : 'Online';

            if (inLobby) {
                updateMemberList();
                updateStartButton();
            }
        }

        function updateMemberList() {
            const members = steamNetwork.getMembers();
            const localPlayer = steamNetwork.getLocalPlayer();
            const isHost = steamNetwork.isLobbyHost();
            const container = document.getElementById('steamMemberList');

            container.innerHTML = members.map((member, idx) => {
                const isMe = member.steamId === localPlayer?.steamId;
                const isHostMember = idx === 0; // First member is typically host

                return `
                    <div class="steam-member">
                        <div class="steam-member-avatar">${member.name?.charAt(0) || '?'}</div>
                        <div class="steam-member-name">${member.name || 'Unknown'}</div>
                        ${isHostMember ? '<span class="steam-member-host">HOST</span>' : ''}
                        ${isMe ? '<span class="steam-member-you">(You)</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        function updateStartButton() {
            const startBtn = document.getElementById('steamStartGameBtn');
            const isHost = steamNetwork.isLobbyHost();
            const memberCount = steamNetwork.getMemberCount();

            startBtn.style.display = isHost ? 'block' : 'none';
            startBtn.disabled = memberCount < 2;
            startBtn.textContent = memberCount < 2 ? 'üöÄ Waiting for players...' : 'üöÄ Start Game';
        }

        // Steam event handlers
        function onLobbyCreated(data) {
            console.log('Lobby created:', data);
            showInLobbyUI(true);
        }

        function onLobbyJoined(data) {
            console.log('Joined lobby:', data);
            showInLobbyUI(true);
            updateSteamStatus('Joined lobby!', 'online');
        }

        function onMemberChanged(data) {
            console.log('Member changed:', data);
            updateMemberList();
            updateStartButton();
        }

        function onMembersUpdated(data) {
            console.log('Members updated:', data);
            updateMemberList();
            updateStartButton();
        }

        function onLobbyDisconnected() {
            console.log('Disconnected from lobby');
            showInLobbyUI(false);
            updateSteamStatus('Disconnected from lobby', '');
            document.getElementById('steamCreateBtn').disabled = false;
        }

        function onSteamError(data) {
            console.error('Steam error:', data);
            updateSteamStatus('Error: ' + data.error, 'error');
        }

        function handleSteamMessage(msg) {
            console.log('Steam message received:', msg);

            // Handle game start message
            if (msg.type === 'game_start') {
                localStorage.setItem('steamLobbyActive', 'true');
                localStorage.setItem('steamGameType', msg.gameType);
                localStorage.setItem('steamPlayers', JSON.stringify(msg.players));
                localStorage.setItem('steamIsHost', 'false');

                // Launch game for non-host players
                launchSteamGame(msg.gameType);
            }
        }

        // Initialize Steam when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Delay Steam init slightly to ensure scripts are loaded
            setTimeout(initSteamLobby, 500);
        });

        // ==================== END STEAM LOBBY FUNCTIONS ====================

        // Debug: Press backtick (`) to force-show games without LM connection
        document.addEventListener('keydown', function(e) {
            if (e.key === '`') {
                const rc = document.querySelector('.radial-container');
                if (rc) {
                    rc.classList.remove('disconnected');
                    rc.classList.add('connected');
                    console.log('Debug: force-showing games');
                }
            }
        });

        // Toggle debug panel
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // Retry Nova discovery
        function retryNovaDiscovery() {
            console.log('üîÑ Retrying Nova discovery...');
            if (window.electronAPI && window.electronAPI.startNovaDiscovery) {
                window.electronAPI.startNovaDiscovery();
            }
        }

        // Launch Monitor Type Selection
        function changeLaunchMonitorType() {
            const monitorType = document.getElementById('launchMonitorType').value;
            const gsproConfig = document.getElementById('gsproPortConfig');
            const novaStatus = document.getElementById('novaStatus');

            if (monitorType === 'nova') {
                // Hide GSPro port config, show Nova status
                gsproConfig.style.display = 'none';
                novaStatus.style.display = 'flex';

                // Stop GSPro server and start Nova discovery
                if (window.electronAPI) {
                    if (window.electronAPI.stopGSProServer) {
                        window.electronAPI.stopGSProServer();
                    }
                    if (window.electronAPI.startNovaDiscovery) {
                        window.electronAPI.startNovaDiscovery();
                    }
                }
            } else {
                // Show GSPro port config, hide Nova status
                gsproConfig.style.display = 'flex';
                novaStatus.style.display = 'none';

                // Stop Nova and start GSPro server
                if (window.electronAPI) {
                    if (window.electronAPI.stopNovaDiscovery) {
                        window.electronAPI.stopNovaDiscovery();
                    }
                    if (window.electronAPI.startGSProServer) {
                        window.electronAPI.startGSProServer();
                    }
                }
            }
        }

        // Port configuration functions
        async function loadCurrentPort() {
            try {
                const port = await window.electronAPI.getGSProPort();
                document.getElementById('portInput').value = port;
            } catch (err) {
                console.error('Failed to load current port:', err);
            }
        }

        async function changePort() {
            const portInput = document.getElementById('portInput');
            const newPort = parseInt(portInput.value);

            if (newPort < 1 || newPort > 65535) {
                alert('Port must be between 1 and 65535');
                await loadCurrentPort(); // Reset to current port
                return;
            }

            try {
                const result = await window.electronAPI.setGSProPort(newPort);
                if (result.success) {
                    alert(`Port changed to ${result.port}. Server restarting...`);
                } else {
                    alert(`Error: ${result.error}`);
                    await loadCurrentPort(); // Reset to current port
                }
            } catch (err) {
                console.error('Failed to change port:', err);
                alert('Failed to change port. See console for details.');
                await loadCurrentPort(); // Reset to current port
            }
        }

        // Graphics Settings
        let graphicsSettings = {
            ambientLight: 1.2,
            sunLight: 1.5
        };

        function loadGraphicsSettings() {
            try {
                const saved = localStorage.getItem('graphics_settings');
                if (saved) {
                    graphicsSettings = JSON.parse(saved);
                    console.log('Loaded graphics settings:', graphicsSettings);
                }
            } catch (e) {
                console.error('Error loading graphics settings:', e);
            }
        }

        function showGraphicsSettings() {
            loadGraphicsSettings();

            // Set slider values
            document.getElementById('ambientLight').value = graphicsSettings.ambientLight;
            document.getElementById('sunLight').value = graphicsSettings.sunLight;

            // Update displays
            updateLightingPreview();

            // Show modal
            document.getElementById('graphicsSettings').style.display = 'block';
        }

        function hideGraphicsSettings() {
            document.getElementById('graphicsSettings').style.display = 'none';
        }

        function updateLightingPreview() {
            const ambient = parseFloat(document.getElementById('ambientLight').value);
            const sun = parseFloat(document.getElementById('sunLight').value);

            document.getElementById('ambientLightValue').textContent = ambient.toFixed(1);
            document.getElementById('sunLightValue').textContent = sun.toFixed(1);
        }

        function applyLightingPreset(preset) {
            const presets = {
                dark: { ambient: 0.8, sun: 1.0 },
                normal: { ambient: 1.2, sun: 1.5 },
                bright: { ambient: 2.0, sun: 2.5 },
                max: { ambient: 3.0, sun: 4.0 }
            };

            const settings = presets[preset];
            if (settings) {
                document.getElementById('ambientLight').value = settings.ambient;
                document.getElementById('sunLight').value = settings.sun;
                updateLightingPreview();
            }
        }

        function saveGraphicsSettings() {
            const ambient = parseFloat(document.getElementById('ambientLight').value);
            const sun = parseFloat(document.getElementById('sunLight').value);

            graphicsSettings = {
                ambientLight: ambient,
                sunLight: sun
            };

            localStorage.setItem('graphics_settings', JSON.stringify(graphicsSettings));
            console.log('Graphics settings saved:', graphicsSettings);

            alert(`Graphics Settings Saved!\n\nAmbient Light: ${ambient.toFixed(1)}\nSun Light: ${sun.toFixed(1)}\n\nThese settings will apply to all games.`);
            hideGraphicsSettings();
        }

        // Track which profile is being edited in calibration modal
        let calibrationEditingProfile = 'computer';

        // Calibration functions
        function openCalibration() {
            const modal = document.getElementById('calibrationModal');
            modal.style.display = 'flex';

            // Set editing profile to current active profile
            calibrationEditingProfile = activeCalibrationProfile;

            // Update tab UI and load profile
            updateCalibrationTabs();
            loadProfileIntoCalibrationUI();

            // Load projection settings
            loadProjectionSettings();

            // Set default test values if empty
            if (!document.getElementById('test_hla').value) {
                document.getElementById('test_hla').value = '0';
            }
            if (!document.getElementById('test_vla').value) {
                document.getElementById('test_vla').value = '15';
            }

            // Setup click handler for calibration dartboard
            setupCalibrationDartboardClick();

            // Draw preview
            updateCalibrationPreview();
        }

        function exportCalibration() {
            // Create export object with all calibration profiles
            const exportData = {
                version: "2.2.0",
                exportDate: new Date().toISOString(),
                profiles: calibrationProfiles
            };

            // Convert to JSON
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `darts-calibration-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('‚úÖ Calibration exported:', exportData);
            alert('Calibration exported successfully!\nFile saved to your Downloads folder.');
        }

        function importCalibration() {
            // Trigger file input
            document.getElementById('calibrationImportInput').click();
        }

        function handleCalibrationImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    // Validate format
                    if (!importData.profiles) {
                        alert('Invalid calibration file format!');
                        return;
                    }

                    // Confirm import
                    const confirm = window.confirm(
                        `Import calibration from ${importData.exportDate || 'unknown date'}?\n\n` +
                        `This will replace your current calibration settings.\n\n` +
                        `Profiles found:\n` +
                        `- Computer: HLA ${importData.profiles.computer?.hla_scale || 0}, VLA ${importData.profiles.computer?.vla_scale || 0}\n` +
                        `- Projector: HLA ${importData.profiles.projector?.hla_scale || 0}, VLA ${importData.profiles.projector?.vla_scale || 0}`
                    );

                    if (!confirm) return;

                    // Import profiles
                    calibrationProfiles = importData.profiles;

                    // Save to localStorage
                    localStorage.setItem('darts_calibration_profiles', JSON.stringify(calibrationProfiles));

                    // Update global reference
                    window.calibrationProfiles = calibrationProfiles;

                    // Reload UI
                    loadProfileIntoCalibrationUI();
                    updateCalibrationPreview();

                    console.log('‚úÖ Calibration imported:', calibrationProfiles);
                    alert('Calibration imported successfully!\nSettings have been applied.');

                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error importing calibration file!\nPlease check the file format.');
                }
            };

            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function closeCalibration() {
            document.getElementById('calibrationModal').style.display = 'none';

            // Clear test shots when closing calibration
            calibrationTestShots = [];
            calibrationMarkedPosition = null;
            console.log('Calibration closed - test shots cleared');
        }

        function setupCalibrationDartboardClick() {
            const canvas = document.getElementById('calibrationDartboardCanvas');
            if (!canvas || canvas.hasCalibrationListener) return;

            canvas.hasCalibrationListener = true;
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const clickX = (event.clientX - rect.left) * scaleX;
                const clickY = (event.clientY - rect.top) * scaleY;

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const DARTBOARD_RADIUS = 170; // Match the drawing radius

                // Convert pixel position to HLA/VLA
                const dartX = clickX - centerX;
                const dartY = clickY - centerY;

                // Convert back to HLA/VLA coordinates
                const hla = (dartX / DARTBOARD_RADIUS) * 15.0;
                const vla = -(dartY / DARTBOARD_RADIUS) * 10.0 + 15.0;

                // Update the actual position inputs
                document.getElementById('actual_hla').value = hla.toFixed(2);
                document.getElementById('actual_vla').value = vla.toFixed(2);

                // Set the marked position
                calibrationMarkedPosition = { hla: hla, vla: vla };
                calculateSuggestedCalibration();
                updateCalibrationPreview();

                console.log('Marked actual position:', { hla: hla.toFixed(2), vla: vla.toFixed(2) });
            });
        }

        function switchCalibrationProfile(profileName) {
            calibrationEditingProfile = profileName;
            updateCalibrationTabs();
            loadProfileIntoCalibrationUI();
            updateCalibrationPreview();
        }

        function updateCalibrationTabs() {
            const computerTab = document.getElementById('computerProfileTab');
            const projectorTab = document.getElementById('projectorProfileTab');
            const profileNameDisplay = document.getElementById('activeProfileName');
            const copyButton = document.getElementById('copyProfileButton');

            if (calibrationEditingProfile === 'computer') {
                computerTab.style.background = 'rgba(59, 130, 246, 0.3)';
                computerTab.style.borderColor = '#3b82f6';
                projectorTab.style.background = 'rgba(255,255,255,0.1)';
                projectorTab.style.borderColor = 'rgba(255,255,255,0.3)';
                profileNameDisplay.textContent = 'Computer Mode';
                copyButton.textContent = 'Copy from Projector ‚Üí';
            } else {
                projectorTab.style.background = 'rgba(59, 130, 246, 0.3)';
                projectorTab.style.borderColor = '#3b82f6';
                computerTab.style.background = 'rgba(255,255,255,0.1)';
                computerTab.style.borderColor = 'rgba(255,255,255,0.3)';
                profileNameDisplay.textContent = 'Projector Mode';
                copyButton.textContent = '‚Üê Copy from Computer';
            }
        }

        function loadProfileIntoCalibrationUI() {
            const profile = calibrationProfiles[calibrationEditingProfile];
            document.getElementById('hla_offset').value = profile.hla_offset;
            document.getElementById('vla_offset').value = profile.vla_offset;
        }

        function copyFromOtherProfile() {
            const sourceProfile = calibrationEditingProfile === 'computer' ? 'projector' : 'computer';
            const source = calibrationProfiles[sourceProfile];

            // Copy values to UI
            document.getElementById('hla_offset').value = source.hla_offset;
            document.getElementById('vla_offset').value = source.vla_offset;

            // Update preview
            updateCalibrationPreview();

            const sourceName = sourceProfile === 'computer' ? 'Computer' : 'Projector';
            console.log(`Copied calibration from ${sourceName} profile`);
        }

        function resetCurrentProfile() {
            if (confirm(`Reset ${calibrationEditingProfile} calibration to default (0, 0)?`)) {
                document.getElementById('hla_offset').value = 0;
                document.getElementById('vla_offset').value = 0;
                updateCalibrationPreview();
            }
        }

        function updateCalibrationPreview() {
            const hla = parseFloat(document.getElementById('hla_offset').value) || 0;
            const vla = parseFloat(document.getElementById('vla_offset').value) || 0;

            // Draw preview with actual dartboard
            drawCalibrationDartboard(hla, vla);
        }

        function drawCalibrationDartboard(hlaOffset, vlaOffset) {
            const canvas = document.getElementById('calibrationDartboardCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            // Adjusted for 500x500 canvas with proper margins for numbers
            const DARTBOARD_RADIUS = 170;
            const BULLSEYE_RADIUS = 12.75;
            const BULLS_RING_RADIUS = 34;
            const TRIPLE_INNER = 85;
            const TRIPLE_OUTER = 93.5;
            const DOUBLE_INNER = 153;
            const DOUBLE_OUTER = 170;
            const NUMBERS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw dartboard segments
            for (let i = 0; i < 20; i++) {
                const angle1 = (i * 18 - 9) * Math.PI / 180;
                const angle2 = ((i + 1) * 18 - 9) * Math.PI / 180;
                const isBlack = i % 2 === 0;
                const segmentColor1 = isBlack ? '#000000' : '#f5f5f5';
                const segmentColor2 = isBlack ? '#16a34a' : '#dc2626';

                // Draw segments
                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_OUTER, DOUBLE_INNER, angle1, angle2, segmentColor2);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_OUTER, TRIPLE_INNER, angle1, angle2, segmentColor2);
                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_INNER, TRIPLE_OUTER, angle1, angle2, segmentColor1);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_INNER, BULLS_RING_RADIUS, angle1, angle2, segmentColor1);

                // Draw numbers
                const numberAngle = i * 18 * Math.PI / 180;
                const numberRadius = DARTBOARD_RADIUS + 20;
                const numX = centerX + Math.sin(numberAngle) * numberRadius;
                const numY = centerY - Math.cos(numberAngle) * numberRadius;

                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(NUMBERS[i], numX, numY);
            }

            // Bull's ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLS_RING_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = '#16a34a';
            ctx.fill();

            // Bullseye
            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLSEYE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = '#dc2626';
            ctx.fill();

            // Draw existing darts from game (if game is active)
            if (currentGame && currentGame.players) {
                currentGame.players.forEach(player => {
                    player.dartsThrown.forEach(dart => {
                        drawCalibrationDart(ctx, centerX + dart.x, centerY + dart.y, player.color, 5);
                    });
                });
            }

            // Draw calibration test shots in ORANGE
            calibrationTestShots.forEach(shot => {
                const x = (shot.hla / 15.0) * DARTBOARD_RADIUS;
                const y = -((shot.vla - 15.0) / 10.0) * DARTBOARD_RADIUS;
                drawCalibrationDart(ctx, centerX + x, centerY + y, '#ff6b35', 8);
            });

            // Draw preview of test shot values with calibration applied
            const testHLA = parseFloat(document.getElementById('test_hla').value) || 0;
            const testVLA = parseFloat(document.getElementById('test_vla').value) || 15;

            // Calculate positions
            const rawX = (testHLA / 15.0) * DARTBOARD_RADIUS;
            const rawY = -((testVLA - 15.0) / 10.0) * DARTBOARD_RADIUS;

            const calibratedHLA = testHLA + hlaOffset;
            const calibratedVLA = testVLA + vlaOffset;
            const calibratedX = (calibratedHLA / 15.0) * DARTBOARD_RADIUS;
            const calibratedY = -((calibratedVLA - 15.0) / 10.0) * DARTBOARD_RADIUS;

            // Draw arrow from raw to calibrated if different
            if (Math.abs(rawX - calibratedX) > 1 || Math.abs(rawY - calibratedY) > 1) {
                ctx.beginPath();
                ctx.moveTo(centerX + rawX, centerY + rawY);
                ctx.lineTo(centerX + calibratedX, centerY + calibratedY);
                ctx.strokeStyle = 'rgba(96, 165, 250, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 8]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw raw position (before calibration)
                drawCalibrationDart(ctx, centerX + rawX, centerY + rawY, 'rgba(150, 150, 150, 0.7)', 7);
            }

            // Draw calibrated position (preview - not yet fired)
            drawCalibrationDart(ctx, centerX + calibratedX, centerY + calibratedY, '#fbbf24', 9);

            // Label for preview
            ctx.fillStyle = '#fbbf24';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Preview', centerX + calibratedX + 12, centerY + calibratedY);

            // Draw marked actual position in GREEN
            if (calibrationMarkedPosition) {
                const actualX = (calibrationMarkedPosition.hla / 15.0) * DARTBOARD_RADIUS;
                const actualY = -((calibrationMarkedPosition.vla - 15.0) / 10.0) * DARTBOARD_RADIUS;
                drawCalibrationDart(ctx, centerX + actualX, centerY + actualY, '#22c55e', 10);

                // Label
                ctx.fillStyle = '#22c55e';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('Actual', centerX + actualX + 12, centerY + actualY);
            }

            // Draw visible grid overlay for reference
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.25)'; // Light blue, more visible
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);

            // Horizontal grid lines
            for (let i = -3; i <= 3; i++) {
                const y = centerY + (i * DARTBOARD_RADIUS / 3);
                ctx.beginPath();
                ctx.moveTo(centerX - DARTBOARD_RADIUS, y);
                ctx.lineTo(centerX + DARTBOARD_RADIUS, y);
                ctx.stroke();
            }

            // Vertical grid lines
            for (let i = -3; i <= 3; i++) {
                const x = centerX + (i * DARTBOARD_RADIUS / 3);
                ctx.beginPath();
                ctx.moveTo(x, centerY - DARTBOARD_RADIUS);
                ctx.lineTo(x, centerY + DARTBOARD_RADIUS);
                ctx.stroke();
            }

            // Center crosshair - more prominent
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)'; // Brighter blue
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(centerX - 30, centerY);
            ctx.lineTo(centerX + 30, centerY);
            ctx.moveTo(centerX, centerY - 30);
            ctx.lineTo(centerX, centerY + 30);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawCalibrationSegment(ctx, centerX, centerY, outerRadius, innerRadius, angle1, angle2, color) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, angle1, angle2);
            ctx.arc(centerX, centerY, innerRadius, angle2, angle1, true);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawCalibrationDart(ctx, x, y, color, radius) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function sendCalibrationTestShot() {
            const testHLA = parseFloat(document.getElementById('test_hla').value) || 0;
            const testVLA = parseFloat(document.getElementById('test_vla').value) || 15;

            // Get current profile offsets
            const hlaOffset = parseFloat(document.getElementById('hla_offset').value) || 0;
            const vlaOffset = parseFloat(document.getElementById('vla_offset').value) || 0;

            // Add to calibration test shots array (with calibration applied)
            calibrationTestShots.push({
                hla: testHLA + hlaOffset,
                vla: testVLA + vlaOffset
            });

            console.log('Calibration test shot added:', { hla: testHLA + hlaOffset, vla: testVLA + vlaOffset });

            // Create test shot with calibration already applied
            const testShot = {
                ball_speed: 100,
                hla: testHLA + hlaOffset,
                vla: testVLA + vlaOffset,
                total_spin: 2500,
                back_spin: 2400,
                side_spin: 0,
                spin_axis: 0,
                carry_distance: 180
            };

            // Also send to game if active
            if (currentGame && currentGame.gameActive) {
                console.log('Sending calibration test shot to game:', testShot);
                currentGame.handleShot(testShot);
                updateDataDisplay(testShot);
            }

            // Redraw calibration preview to show new dart
            updateCalibrationPreview();
        }

        function clearCalibrationTestShots() {
            calibrationTestShots = [];
            console.log('Calibration test shots cleared');
            updateCalibrationPreview();
        }

        function updateActualPositionFromInputs() {
            const actualHLA = parseFloat(document.getElementById('actual_hla').value);
            const actualVLA = parseFloat(document.getElementById('actual_vla').value);

            if (!isNaN(actualHLA) && !isNaN(actualVLA)) {
                calibrationMarkedPosition = { hla: actualHLA, vla: actualVLA };
                calculateSuggestedCalibration();
                updateCalibrationPreview();
            }
        }

        function calculateSuggestedCalibration() {
            const testHLA = parseFloat(document.getElementById('test_hla').value) || 0;
            const testVLA = parseFloat(document.getElementById('test_vla').value) || 15;

            if (!calibrationMarkedPosition) {
                document.getElementById('suggestedCalibration').style.display = 'none';
                return;
            }

            // Calculate the offset needed
            // If test says 0¬∞ but it actually landed at -2¬∞, we need offset of -2¬∞
            const suggestedHLA = calibrationMarkedPosition.hla - testHLA;
            const suggestedVLA = calibrationMarkedPosition.vla - testVLA;

            document.getElementById('suggested_hla').textContent = suggestedHLA.toFixed(2);
            document.getElementById('suggested_vla').textContent = suggestedVLA.toFixed(2);
            document.getElementById('suggestedCalibration').style.display = 'block';
        }

        function applySuggestedCalibration() {
            const suggestedHLA = parseFloat(document.getElementById('suggested_hla').textContent);
            const suggestedVLA = parseFloat(document.getElementById('suggested_vla').textContent);

            document.getElementById('hla_offset').value = suggestedHLA;
            document.getElementById('vla_offset').value = suggestedVLA;

            updateCalibrationPreview();
            alert('Calibration applied! Don\'t forget to Save Profile.');
        }

        function clearMarkedPosition() {
            calibrationMarkedPosition = null;
            document.getElementById('actual_hla').value = '';
            document.getElementById('actual_vla').value = '';
            document.getElementById('suggestedCalibration').style.display = 'none';
            updateCalibrationPreview();
        }

        function saveCalibration() {
            const hla = parseFloat(document.getElementById('hla_offset').value);
            const vla = parseFloat(document.getElementById('vla_offset').value);

            // Save to the profile being edited
            calibrationProfiles[calibrationEditingProfile].hla_offset = hla;
            calibrationProfiles[calibrationEditingProfile].vla_offset = vla;

            // Save all profiles to localStorage
            localStorage.setItem('darts_calibration_profiles', JSON.stringify(calibrationProfiles));

            console.log('Calibration profile saved:', calibrationEditingProfile, calibrationProfiles[calibrationEditingProfile]);

            const profileName = calibrationEditingProfile === 'computer' ? 'Computer' : 'Projector';
            alert(`${profileName} Calibration Saved!\n\nHLA Offset: ${hla.toFixed(1)}¬∞\nVLA Offset: ${vla.toFixed(1)}¬∞`);

            closeCalibration();
        }

        // Projection Settings
        let projectionSettings = {
            resWidth: 1440,
            resHeight: 1080,
            sizeWidth: 81,
            sizeHeight: 71
        };

        function loadProjectionSettings() {
            const saved = localStorage.getItem('darts_projection_settings');
            if (saved) {
                try {
                    projectionSettings = JSON.parse(saved);
                    console.log('Loaded projection settings:', projectionSettings);
                } catch (e) {
                    console.error('Error loading projection settings:', e);
                }
            }

            // Update UI
            document.getElementById('proj_res_width').value = projectionSettings.resWidth;
            document.getElementById('proj_res_height').value = projectionSettings.resHeight;
            document.getElementById('proj_size_width').value = projectionSettings.sizeWidth;
            document.getElementById('proj_size_height').value = projectionSettings.sizeHeight;

            updateProjectionDisplay();
        }

        function saveProjectionSettings() {
            const resWidth = parseFloat(document.getElementById('proj_res_width').value);
            const resHeight = parseFloat(document.getElementById('proj_res_height').value);
            const sizeWidth = parseFloat(document.getElementById('proj_size_width').value);
            const sizeHeight = parseFloat(document.getElementById('proj_size_height').value);

            projectionSettings = {
                resWidth: resWidth,
                resHeight: resHeight,
                sizeWidth: sizeWidth,
                sizeHeight: sizeHeight
            };

            localStorage.setItem('darts_projection_settings', JSON.stringify(projectionSettings));
            console.log('Projection settings saved:', projectionSettings);

            updateProjectionDisplay();

            alert(`Projection Settings Saved!\n\nResolution: ${resWidth}x${resHeight}\nSize: ${sizeWidth}" x ${sizeHeight}"`);
        }

        function updateProjectionDisplay() {
            const resWidth = parseFloat(document.getElementById('proj_res_width').value) || 1440;
            const resHeight = parseFloat(document.getElementById('proj_res_height').value) || 1080;
            const sizeWidth = parseFloat(document.getElementById('proj_size_width').value) || 81;
            const sizeHeight = parseFloat(document.getElementById('proj_size_height').value) || 71;

            // Calculate PPI (average of horizontal and vertical)
            const ppiH = resWidth / sizeWidth;
            const ppiV = resHeight / sizeHeight;
            const ppiAvg = (ppiH + ppiV) / 2;

            // Calculate aspect ratio
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(resWidth, resHeight);
            const aspectW = resWidth / divisor;
            const aspectH = resHeight / divisor;

            document.getElementById('ppi_display').textContent = `${ppiAvg.toFixed(2)} (H: ${ppiH.toFixed(2)}, V: ${ppiV.toFixed(2)})`;
            document.getElementById('aspect_display').textContent = `${aspectW}:${aspectH} (${(resWidth/resHeight).toFixed(3)})`;
        }

        // Add input listeners for projection settings
        document.addEventListener('DOMContentLoaded', () => {
            const projInputs = ['proj_res_width', 'proj_res_height', 'proj_size_width', 'proj_size_height'];
            projInputs.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    elem.addEventListener('input', updateProjectionDisplay);
                }
            });
        });

        // ==================================================================
        // CALIBRATION WIZARD SYSTEM
        // ==================================================================

        // Wizard state
        let wizardShots = []; // {monitor: {hla, vla}, actual: {hla, vla}}
        let wizardTargetShotCount = 10; // Configurable shot count (10-100)
        let wizardCurrentStep = 1;
        let wizardInProgress = false;
        let wizardWaitingForShot = false;
        let wizardLastShotData = null;
        let wizardPendingShot = null; // {normalizedX, normalizedY, pixelX, pixelY} - awaiting confirmation

        // ==================================================================
        // TAP CALIBRATION SYSTEM (Quick Cal)
        // ==================================================================

        let quickCalActive = false;
        let quickCalWaitingForTap = false;   // waiting for user to tap a segment
        let quickCalPendingMonitor = null;   // {hla, vla} from last shot, awaiting tap
        let quickCalShots = [];              // {targetX, targetY, monitorHLA, monitorVLA, label}
        let quickCalTargetProfile = 'computer';
        let quickCalPopout = null;       // window reference
        let quickCalChannel = null;      // BroadcastChannel
        let quickCalGuidedMode = false;  // true when pop-out is active
        let quickCalGuidedTarget = 0;    // current target index in guided mode

        const QUICK_CAL_GUIDED_TARGETS = [
            { name: 'Bullseye',   x: 0,    y: 0    },
            { name: '20 Segment', x: 0,    y: -0.7 },
            { name: '6 Segment',  x: 0.7,  y: 0    },
            { name: '3 Segment',  x: 0,    y: 0.7  },
            { name: '11 Segment', x: -0.7, y: 0    }
        ];

        const QUICK_CAL_MIN_SHOTS = 3;
        const QUICK_CAL_MAX_SHOTS = 5;
        const SEGMENT_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
        const SEGMENT_RADIUS = 0.65; // normalized radius for single zone

        function segmentToCoords(segmentNumber) {
            const segIndex = SEGMENT_ORDER.indexOf(segmentNumber);
            if (segIndex === -1) return { x: 0, y: 0 };
            const angleRad = segIndex * 18 * Math.PI / 180;
            return {
                x: Math.sin(angleRad) * SEGMENT_RADIUS,
                y: -Math.cos(angleRad) * SEGMENT_RADIUS
            };
        }

        function showQuickCalibration() {
            quickCalActive = true;
            quickCalWaitingForTap = false;
            quickCalPendingMonitor = null;
            quickCalShots = [];
            quickCalTargetProfile = activeCalibrationProfile;
            quickCalGuidedMode = false;
            quickCalGuidedTarget = 0;

            document.getElementById('quickCalModal').style.display = 'block';
            switchQuickCalProfile(quickCalTargetProfile);

            // Clean up any previous pop-out
            if (quickCalChannel) {
                try { quickCalChannel.postMessage({ type: 'close' }); } catch(e) {}
                quickCalChannel.close();
                quickCalChannel = null;
            }
            if (quickCalPopout && !quickCalPopout.closed) {
                quickCalPopout.close();
            }
            quickCalPopout = null;

            // Reset UI
            updateQuickCalUI();
            document.getElementById('qcSegmentGrid').style.display = 'none';
            document.getElementById('qcStatus').textContent = 'Throw a dart at the board!';
            document.getElementById('qcStatus').style.color = '#22c55e';
            document.getElementById('qcPopOutBtn').textContent = 'Pop Out Board (for projector)';
            document.getElementById('qcPopOutBtn').style.borderColor = 'rgba(168,85,247,0.5)';
            document.getElementById('qcPopOutBtn').style.color = '#a855f7';

            drawQuickCalDartboard();
        }

        function handleQuickCalShot(shotData) {
            if (!quickCalActive) return false;
            if (quickCalShots.length >= QUICK_CAL_MAX_SHOTS) return false;

            // Guided mode: auto-record shot against current target
            if (quickCalGuidedMode && quickCalGuidedTarget < QUICK_CAL_GUIDED_TARGETS.length) {
                const target = QUICK_CAL_GUIDED_TARGETS[quickCalGuidedTarget];
                quickCalShots.push({
                    targetX: target.x,
                    targetY: target.y,
                    monitorHLA: shotData.hla,
                    monitorVLA: shotData.vla,
                    label: target.name,
                    guidedIndex: quickCalGuidedTarget
                });

                console.log(`‚ö° Guided Cal: Shot ${quickCalShots.length} auto-recorded ‚Äî ${target.name} ‚Üí (${target.x.toFixed(2)}, ${target.y.toFixed(2)})`);

                quickCalGuidedTarget++;
                sendQuickCalUpdate();
                updateQuickCalUI();
                drawQuickCalDartboard();

                if (quickCalShots.length >= QUICK_CAL_MAX_SHOTS || quickCalGuidedTarget >= QUICK_CAL_GUIDED_TARGETS.length) {
                    document.getElementById('qcStatus').textContent = 'All guided shots recorded! Click Apply to finish.';
                    document.getElementById('qcStatus').style.color = '#22c55e';
                } else {
                    const next = QUICK_CAL_GUIDED_TARGETS[quickCalGuidedTarget];
                    document.getElementById('qcStatus').textContent = `Shot recorded! Next: ${next.name}`;
                    document.getElementById('qcStatus').style.color = '#22c55e';
                }

                return true;
            }

            if (quickCalWaitingForTap) return true; // absorb shot while grid is showing

            // Tap mode: save monitor reading, show segment grid for user to tap
            quickCalPendingMonitor = { hla: shotData.hla, vla: shotData.vla };
            quickCalWaitingForTap = true;

            document.getElementById('qcSegmentGrid').style.display = 'block';
            document.getElementById('qcStatus').textContent = 'Where did it land? Tap the segment.';
            document.getElementById('qcStatus').style.color = '#fbbf24';

            console.log(`‚ö° Tap Cal: Shot detected ‚Äî HLA: ${shotData.hla.toFixed(2)}, VLA: ${shotData.vla.toFixed(2)} ‚Äî waiting for segment tap`);

            return true;
        }

        function quickCalSegmentTapped(segment) {
            if (!quickCalWaitingForTap || !quickCalPendingMonitor) return;

            let coords, label;
            if (segment === 'bullseye' || segment === 'bull') {
                coords = { x: 0, y: 0 };
                label = segment === 'bullseye' ? 'Bullseye' : 'Bull';
            } else {
                coords = segmentToCoords(segment);
                label = String(segment);
            }

            quickCalShots.push({
                targetX: coords.x,
                targetY: coords.y,
                monitorHLA: quickCalPendingMonitor.hla,
                monitorVLA: quickCalPendingMonitor.vla,
                label: label
            });

            quickCalWaitingForTap = false;
            quickCalPendingMonitor = null;

            // Hide grid
            document.getElementById('qcSegmentGrid').style.display = 'none';

            console.log(`‚ö° Tap Cal: Shot ${quickCalShots.length} recorded ‚Äî ${label} ‚Üí (${coords.x.toFixed(2)}, ${coords.y.toFixed(2)})`);

            updateQuickCalUI();
            drawQuickCalDartboard();

            if (quickCalShots.length >= QUICK_CAL_MAX_SHOTS) {
                document.getElementById('qcStatus').textContent = 'All 5 shots recorded! Click Apply to finish.';
                document.getElementById('qcStatus').style.color = '#22c55e';
            } else {
                document.getElementById('qcStatus').textContent = `Shot recorded (${label})! Throw another dart.`;
                document.getElementById('qcStatus').style.color = '#22c55e';
            }
        }

        function quickCalDismissGrid() {
            // Missed the board ‚Äî discard pending monitor data
            quickCalWaitingForTap = false;
            quickCalPendingMonitor = null;
            document.getElementById('qcSegmentGrid').style.display = 'none';
            document.getElementById('qcStatus').textContent = 'No problem ‚Äî throw another dart!';
            document.getElementById('qcStatus').style.color = 'rgba(255,255,255,0.6)';
        }

        function updateQuickCalUI() {
            const count = quickCalShots.length;

            // Shot count text
            document.getElementById('qcShotCount').textContent = `${count} shot${count !== 1 ? 's' : ''} recorded`;

            // Progress dots
            const dots = document.querySelectorAll('#qcProgressDots .qc-dot');
            dots.forEach((dot, i) => {
                if (i < count) {
                    dot.style.background = 'rgba(34, 197, 94, 0.4)';
                    dot.style.borderColor = '#22c55e';
                    dot.style.color = '#22c55e';
                    dot.innerHTML = '&#10003;';
                } else {
                    dot.style.background = 'rgba(255,255,255,0.05)';
                    dot.style.borderColor = 'rgba(255,255,255,0.3)';
                    dot.style.color = 'rgba(255,255,255,0.5)';
                    dot.textContent = (i + 1).toString();
                }
            });

            // Apply button
            const btn = document.getElementById('qcApplyBtn');
            if (count >= QUICK_CAL_MIN_SHOTS) {
                btn.disabled = false;
                btn.style.background = 'rgba(34, 197, 94, 0.3)';
                btn.style.borderColor = '#22c55e';
                btn.style.color = '#22c55e';
            } else {
                btn.disabled = true;
                btn.style.background = 'rgba(34, 197, 94, 0.2)';
                btn.style.borderColor = 'rgba(34,197,94,0.3)';
                btn.style.color = 'rgba(34,197,94,0.5)';
            }

            // Undo button
            document.getElementById('qcUndoBtn').style.display = count > 0 ? 'inline-block' : 'none';
        }

        function drawQuickCalDartboard() {
            const canvas = document.getElementById('quickCalCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const BOARD_RADIUS = 115;
            const BULLSEYE_R = 8.5;
            const BULLS_RING_R = 23;
            const TRIPLE_IN = 58;
            const TRIPLE_OUT = 63;
            const DOUBLE_IN = 104;
            const DOUBLE_OUT = 115;
            const NUMBERS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw dartboard
            for (let i = 0; i < 20; i++) {
                const a1 = (i * 18 - 9) * Math.PI / 180;
                const a2 = ((i + 1) * 18 - 9) * Math.PI / 180;
                const isBlack = i % 2 === 0;
                const c1 = isBlack ? '#000000' : '#f5f5f5';
                const c2 = isBlack ? '#16a34a' : '#dc2626';

                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_OUT, DOUBLE_IN, a1, a2, c2);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_OUT, TRIPLE_IN, a1, a2, c2);
                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_IN, TRIPLE_OUT, a1, a2, c1);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_IN, BULLS_RING_R, a1, a2, c1);

                const na = i * 18 * Math.PI / 180;
                const nr = BOARD_RADIUS + 14;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(NUMBERS[i], centerX + Math.sin(na) * nr, centerY - Math.cos(na) * nr);
            }

            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLS_RING_R, 0, 2 * Math.PI);
            ctx.fillStyle = '#16a34a';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLSEYE_R, 0, 2 * Math.PI);
            ctx.fillStyle = '#dc2626';
            ctx.fill();

            // Draw recorded shots
            quickCalShots.forEach(shot => {
                const sx = centerX + shot.targetX * BOARD_RADIUS;
                const sy = centerY + shot.targetY * BOARD_RADIUS;
                drawCalibrationDart(ctx, sx, sy, '#22c55e', 7);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(shot.label, sx, sy - 11);
            });
        }

        function quickCalUndo() {
            if (quickCalShots.length === 0) return;

            const removed = quickCalShots.pop();
            console.log(`‚ö° Tap Cal: Undid shot ‚Äî ${removed.label}`);

            // Cancel any pending tap
            quickCalWaitingForTap = false;
            quickCalPendingMonitor = null;
            document.getElementById('qcSegmentGrid').style.display = 'none';

            // In guided mode, rewind the target index
            if (quickCalGuidedMode && removed.guidedIndex !== undefined) {
                quickCalGuidedTarget = removed.guidedIndex;
                sendQuickCalUpdate();
            }

            updateQuickCalUI();
            drawQuickCalDartboard();

            if (quickCalGuidedMode && quickCalGuidedTarget < QUICK_CAL_GUIDED_TARGETS.length) {
                const next = QUICK_CAL_GUIDED_TARGETS[quickCalGuidedTarget];
                document.getElementById('qcStatus').textContent = `Undone. Aim at: ${next.name}`;
            } else {
                document.getElementById('qcStatus').textContent = 'Undone. Throw another dart!';
            }
            document.getElementById('qcStatus').style.color = '#fbbf24';
        }

        function calculateQuickCalibration() {
            if (quickCalShots.length < QUICK_CAL_MIN_SHOTS) return null;

            const hlaValues = quickCalShots.map(s => s.monitorHLA);
            const vlaValues = quickCalShots.map(s => s.monitorVLA);
            const targetXValues = quickCalShots.map(s => s.targetX);
            const targetYValues = quickCalShots.map(s => s.targetY);

            const hlaReg = linearRegression(hlaValues, targetXValues);
            const vlaReg = linearRegression(vlaValues, targetYValues);

            if (isNaN(hlaReg.slope) || isNaN(hlaReg.intercept) || isNaN(vlaReg.slope) || isNaN(vlaReg.intercept)) {
                console.warn('‚ö° Tap Cal: Regression produced NaN');
                return null;
            }

            if (Math.abs(hlaReg.slope) < 0.0001 || Math.abs(vlaReg.slope) < 0.0001) {
                console.warn('‚ö° Tap Cal: Degenerate regression (near-zero slope)');
                return null;
            }

            const hlaR2 = calculateR2(hlaValues, targetXValues, hlaReg.slope, hlaReg.intercept);
            const vlaR2 = calculateR2(vlaValues, targetYValues, vlaReg.slope, vlaReg.intercept);

            return {
                hla_scale: hlaReg.slope,
                hla_offset: hlaReg.intercept,
                vla_scale: vlaReg.slope,
                vla_offset: vlaReg.intercept,
                hlaR2: hlaR2,
                vlaR2: vlaR2,
                shotCount: quickCalShots.length
            };
        }

        function applyQuickCalibration() {
            const results = calculateQuickCalibration();

            if (!results) {
                alert('Calibration failed ‚Äî not enough spread in your shots.\nTry hitting different segments across the board.');
                return;
            }

            const profile = calibrationProfiles[quickCalTargetProfile];
            profile.hla_scale = results.hla_scale;
            profile.hla_offset = results.hla_offset;
            profile.vla_scale = results.vla_scale;
            profile.vla_offset = results.vla_offset;
            profile.usePolynomial = undefined;
            profile.hla_poly = undefined;
            profile.vla_poly = undefined;

            localStorage.setItem('darts_calibration_profiles', JSON.stringify(calibrationProfiles));
            localStorage.setItem('darts_has_calibrated', 'true');

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚ö° TAP CALIBRATION APPLIED');
            console.log(`Profile: ${quickCalTargetProfile}`);
            console.log(`HLA Scale: ${results.hla_scale.toFixed(4)}, Offset: ${results.hla_offset.toFixed(4)}`);
            console.log(`VLA Scale: ${results.vla_scale.toFixed(4)}, Offset: ${results.vla_offset.toFixed(4)}`);
            console.log(`R¬≤ ‚Äî HLA: ${results.hlaR2.toFixed(3)}, VLA: ${results.vlaR2.toFixed(3)}`);
            console.log(`Shots: ${results.shotCount}`);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

            const fitQuality = Math.min(results.hlaR2, results.vlaR2);
            let fitMessage;
            if (fitQuality > 0.9) fitMessage = 'Excellent calibration!';
            else if (fitQuality > 0.7) fitMessage = 'Good calibration.';
            else if (fitQuality > 0.5) fitMessage = 'Fair ‚Äî consider recalibrating with wider spread.';
            else fitMessage = 'Low confidence ‚Äî try hitting more spread-out segments.';

            alert(`Calibration applied to ${quickCalTargetProfile} profile!\n\n` +
                  `${fitMessage}\n` +
                  `Fit: ${(fitQuality * 100).toFixed(1)}% | Shots: ${results.shotCount}`);

            closeQuickCal();
        }

        function cancelQuickCal() {
            closeQuickCal();
        }

        function closeQuickCal() {
            quickCalActive = false;
            quickCalWaitingForTap = false;
            quickCalPendingMonitor = null;

            // Clean up pop-out window
            if (quickCalChannel) {
                try { quickCalChannel.postMessage({ type: 'close' }); } catch(e) {}
                quickCalChannel.close();
                quickCalChannel = null;
            }
            if (quickCalPopout && !quickCalPopout.closed) {
                quickCalPopout.close();
            }
            quickCalPopout = null;
            quickCalGuidedMode = false;
            quickCalGuidedTarget = 0;

            document.getElementById('quickCalModal').style.display = 'none';
        }

        function switchQuickCalProfile(profile) {
            quickCalTargetProfile = profile;

            const compBtn = document.getElementById('qcProfileComputer');
            const projBtn = document.getElementById('qcProfileProjector');

            if (profile === 'computer') {
                compBtn.style.background = 'rgba(59,130,246,0.4)';
                compBtn.style.borderColor = '#3b82f6';
                compBtn.style.borderWidth = '2px';
                compBtn.style.color = 'white';
                compBtn.style.fontWeight = 'bold';
                projBtn.style.background = 'rgba(255,255,255,0.1)';
                projBtn.style.borderColor = 'rgba(255,255,255,0.3)';
                projBtn.style.borderWidth = '1px';
                projBtn.style.color = 'rgba(255,255,255,0.6)';
                projBtn.style.fontWeight = 'normal';
            } else {
                projBtn.style.background = 'rgba(59,130,246,0.4)';
                projBtn.style.borderColor = '#3b82f6';
                projBtn.style.borderWidth = '2px';
                projBtn.style.color = 'white';
                projBtn.style.fontWeight = 'bold';
                compBtn.style.background = 'rgba(255,255,255,0.1)';
                compBtn.style.borderColor = 'rgba(255,255,255,0.3)';
                compBtn.style.borderWidth = '1px';
                compBtn.style.color = 'rgba(255,255,255,0.6)';
                compBtn.style.fontWeight = 'normal';
            }
        }

        function popOutQuickCalBoard() {
            // Open the pop-out dartboard window
            quickCalPopout = window.open('quick-cal-board.html', 'quickCalBoard', 'width=800,height=800');
            if (!quickCalPopout) {
                alert('Pop-up blocked! Please allow pop-ups for this app.');
                return;
            }

            // Set up BroadcastChannel
            if (quickCalChannel) quickCalChannel.close();
            quickCalChannel = new BroadcastChannel('quick_cal_dartboard');
            quickCalChannel.onmessage = (e) => {
                const msg = e.data;
                if (msg.type === 'popout_ready') {
                    // Pop-out loaded, enter guided mode
                    quickCalGuidedMode = true;
                    quickCalGuidedTarget = quickCalShots.length; // resume from current shot count
                    sendQuickCalUpdate();

                    document.getElementById('qcPopOutBtn').textContent = 'Board Open';
                    document.getElementById('qcPopOutBtn').style.borderColor = '#22c55e';
                    document.getElementById('qcPopOutBtn').style.color = '#22c55e';

                    if (quickCalGuidedTarget < QUICK_CAL_GUIDED_TARGETS.length) {
                        const next = QUICK_CAL_GUIDED_TARGETS[quickCalGuidedTarget];
                        document.getElementById('qcStatus').textContent = `Guided mode: Aim at ${next.name}`;
                        document.getElementById('qcStatus').style.color = '#a855f7';
                    }

                    console.log('‚ö° Guided Cal: Pop-out board connected, entering guided mode');
                } else if (msg.type === 'popout_closing') {
                    // Pop-out was closed, revert to tap mode
                    quickCalGuidedMode = false;
                    quickCalPopout = null;

                    document.getElementById('qcPopOutBtn').textContent = 'Pop Out Board (for projector)';
                    document.getElementById('qcPopOutBtn').style.borderColor = 'rgba(168,85,247,0.5)';
                    document.getElementById('qcPopOutBtn').style.color = '#a855f7';

                    if (quickCalShots.length < QUICK_CAL_MAX_SHOTS) {
                        document.getElementById('qcStatus').textContent = 'Pop-out closed. Throw a dart and tap where it lands.';
                        document.getElementById('qcStatus').style.color = '#fbbf24';
                    }

                    console.log('‚ö° Guided Cal: Pop-out closed, reverting to tap mode');
                }
            };

            // Send initial state in case pop-out loads before channel listener
            setTimeout(() => sendQuickCalUpdate(), 200);
        }

        function sendQuickCalUpdate() {
            if (!quickCalChannel) return;
            const completed = [];
            for (let i = 0; i < quickCalGuidedTarget; i++) completed.push(i);
            quickCalChannel.postMessage({
                type: 'update',
                currentTarget: quickCalGuidedTarget,
                completedTargets: completed,
                done: quickCalGuidedTarget >= QUICK_CAL_GUIDED_TARGETS.length
            });
        }

        // Check for first-time use on load
        window.addEventListener('load', async () => {
            checkFirstTimeUse();
            await loadCurrentPort();

            // Auto-start Nova discovery if it's the selected monitor type
            if (window.electronAPI && window.electronAPI.startNovaDiscovery) {
                const monitorType = document.getElementById('launchMonitorType').value;
                if (monitorType === 'nova') {
                    console.log('üéØ Auto-starting Nova discovery on load');
                    window.electronAPI.startNovaDiscovery();
                }
            }
        });

        function checkFirstTimeUse() {
            const hasCalibrated = localStorage.getItem('darts_has_calibrated');
            const hasSkipped = localStorage.getItem('darts_wizard_skipped');

            if (!hasCalibrated && !hasSkipped) {
                // First time - show wizard after a brief delay
                setTimeout(() => {
                    showQuickCalibration();
                }, 1000);
            }
        }

        function showCalibrationWizard() {
            document.getElementById('calibrationWizard').style.display = 'block';
            wizardGoToStep(1);
        }

        function startCalibrationWizard() {
            wizardGoToStep(2);
            // Load saved projection settings if they exist
            const saved = localStorage.getItem('darts_projection_settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    document.getElementById('wizard_res_width').value = settings.resWidth;
                    document.getElementById('wizard_res_height').value = settings.resHeight;
                    document.getElementById('wizard_size_width').value = settings.sizeWidth;
                    document.getElementById('wizard_size_height').value = settings.sizeHeight;
                    updateWizardProjectionDisplay();
                } catch (e) {}
            }
        }

        function skipCalibrationWizard() {
            localStorage.setItem('darts_wizard_skipped', 'true');
            document.getElementById('calibrationWizard').style.display = 'none';
        }

        function updateShotCountDisplay() {
            const count = parseInt(document.getElementById('wizard_shot_count').value) || 10;

            // Enforce min/max
            if (count < 10) {
                document.getElementById('wizard_shot_count').value = 10;
                return;
            }
            if (count > 100) {
                document.getElementById('wizard_shot_count').value = 100;
                return;
            }

            // Update time estimate (assuming ~30 seconds per shot)
            const estimatedMinutes = Math.ceil((count * 30) / 60);
            const timeText = estimatedMinutes === 1 ? '~1 minute' : `~${estimatedMinutes} minutes`;
            document.getElementById('shotCountEstimate').textContent = `Estimated time: ${timeText}`;
        }

        function confirmShotCount() {
            const count = parseInt(document.getElementById('wizard_shot_count').value) || 10;

            // Validate range
            if (count < 10 || count > 100) {
                alert('Please enter a number between 10 and 100');
                return;
            }

            // Store the target shot count
            wizardTargetShotCount = count;
            console.log(`‚úÖ Calibration configured for ${wizardTargetShotCount} shots`);

            // Move to next step (projection settings)
            wizardGoToStep(3);
        }

        function wizardGoToStep(step) {
            // Hide all steps
            for (let i = 1; i <= 6; i++) {
                const stepEl = document.getElementById('wizardStep' + i);
                if (stepEl) stepEl.style.display = 'none';
            }

            // Show requested step
            const targetStep = document.getElementById('wizardStep' + step);
            if (targetStep) {
                targetStep.style.display = 'block';
                wizardCurrentStep = step;
            }

            // Update projection display if on step 2
            if (step === 2) {
                updateWizardProjectionDisplay();
                // Add input listeners
                ['wizard_res_width', 'wizard_res_height', 'wizard_size_width', 'wizard_size_height'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.removeEventListener('input', updateWizardProjectionDisplay);
                        el.addEventListener('input', updateWizardProjectionDisplay);
                    }
                });
            }

            // Setup dartboard canvas if on step 5 (shot collection)
            if (step === 5) {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üìç WIZARD STEP 4 ACTIVATED - READY TO COLLECT SHOTS');
                console.log('wizardInProgress:', wizardInProgress);
                console.log('wizardWaitingForShot:', wizardWaitingForShot);
                console.log('wizardCurrentStep:', wizardCurrentStep);
                console.log('Wizard is now ready to intercept shots!');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                // Notify projector to start showing content
                if (projectorMode) {
                    projectorChannel.postMessage({
                        type: 'game_start',
                        data: { gameType: 'calibration_wizard' }
                    });
                }
                setupWizardDartboard();
            }

            // End wizard projector display if leaving step 5 (shot collection)
            if (wizardCurrentStep === 5 && step !== 5 && projectorMode) {
                projectorChannel.postMessage({ type: 'game_end' });
            }
        }

        function updateWizardProjectionDisplay() {
            const resWidth = parseFloat(document.getElementById('wizard_res_width').value) || 1440;
            const resHeight = parseFloat(document.getElementById('wizard_res_height').value) || 1080;
            const sizeWidth = parseFloat(document.getElementById('wizard_size_width').value) || 81;
            const sizeHeight = parseFloat(document.getElementById('wizard_size_height').value) || 71;

            const ppiH = resWidth / sizeWidth;
            const ppiV = resHeight / sizeHeight;
            const ppiAvg = (ppiH + ppiV) / 2;

            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(Math.round(resWidth), Math.round(resHeight));
            const aspectW = Math.round(resWidth) / divisor;
            const aspectH = Math.round(resHeight) / divisor;

            document.getElementById('wizard_ppi').textContent = ppiAvg.toFixed(2);
            document.getElementById('wizard_aspect').textContent = `${aspectW}:${aspectH}`;
        }

        function startWizardCalibrationSession() {
            // Save projection settings
            const projSettings = {
                resWidth: parseFloat(document.getElementById('wizard_res_width').value),
                resHeight: parseFloat(document.getElementById('wizard_res_height').value),
                sizeWidth: parseFloat(document.getElementById('wizard_size_width').value),
                sizeHeight: parseFloat(document.getElementById('wizard_size_height').value)
            };
            localStorage.setItem('darts_projection_settings', JSON.stringify(projSettings));

            // Reset wizard state
            wizardShots = [];
            wizardInProgress = true;
            wizardWaitingForShot = true;

            // Update the shot counter display with configured target
            document.getElementById('shotsTarget').textContent = wizardTargetShotCount;
            document.getElementById('shotsCollected').textContent = '0';

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üßô WIZARD CALIBRATION SESSION STARTED');
            console.log(`Target shots: ${wizardTargetShotCount}`);
            console.log('wizardInProgress:', wizardInProgress);
            console.log('wizardWaitingForShot:', wizardWaitingForShot);
            console.log('Will go to step 5 (shot collection) in 1.5 seconds...');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            // Start a practice game if not already
            if (!currentGame || !currentGame.gameActive) {
                // Start practice game automatically
                startGameFromWizard();
            }

            // Open projector mode
            toggleProjectorFullscreen();

            // Wait for projector to load before starting dartboard
            setTimeout(() => {
                // Go to shot collection step
                wizardGoToStep(5);
                updateWizardShotCounter();
            }, 1500); // Give projector window time to load
        }

        function startGameFromWizard() {
            // Simulate starting a practice game with 1 player
            const players = [{
                name: 'Calibration',
                color: '#60a5fa',
                dartsThrown: [],
                currentRound: 1,
                score: 501
            }];

            currentGame = new DartsGame(players, '501');
            currentGame.gameActive = true;

            console.log('Wizard started practice game for calibration');
        }

        function setupWizardDartboard() {
            const canvas = document.getElementById('wizardDartboard');
            if (!canvas || canvas.hasWizardListener) return;

            // Resize canvas to match user's projector resolution for full-screen grid coverage
            const resWidth = parseFloat(document.getElementById('wizard_res_width').value) || 1440;
            const resHeight = parseFloat(document.getElementById('wizard_res_height').value) || 1080;
            canvas.width = resWidth;
            canvas.height = resHeight;
            console.log(`üìê Wizard canvas resized to projector resolution: ${resWidth}x${resHeight}`);

            canvas.hasWizardListener = true;

            // Draw dartboard
            drawWizardDartboard();

            // Add click handler
            canvas.addEventListener('click', function(event) {
                // Only check if we have shot data to record
                if (!wizardLastShotData) {
                    alert('Please hit a shot with your launch monitor first!');
                    return;
                }

                console.log('User clicked on wizard dartboard');

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                const clickX = (event.clientX - rect.left) * scaleX;
                const clickY = (event.clientY - rect.top) * scaleY;

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Use full canvas width/height for coordinate mapping
                // This allows clicking anywhere on screen, not just dartboard
                const maxRadius = Math.max(centerX, centerY); // 200 pixels from center

                // Convert pixel position to HLA/VLA
                const dartX = clickX - centerX;
                const dartY = clickY - centerY;

                // Store as NORMALIZED coordinates (-1 to 1, where 1 = canvas edge)
                // Use canvas radius for full-canvas dart placement
                const canvasRadius = Math.min(canvas.width, canvas.height) / 2;
                const normalizedX = dartX / canvasRadius;
                const normalizedY = dartY / canvasRadius;

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üëÜ USER CLICKED ON WIZARD DARTBOARD');
                console.log('Click position (pixels):', { clickX, clickY });
                console.log('Dartboard offset:', { dartX, dartY });
                console.log('Normalized position:', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
                console.log('Monitor reading:', wizardLastShotData);
                console.log('Storing pending shot (awaiting confirmation)...');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                // Store pending shot for confirmation
                wizardPendingShot = {
                    normalizedX,
                    normalizedY,
                    pixelX: clickX,
                    pixelY: clickY
                };

                // Show confirm button, hide reshoot button
                document.getElementById('confirmShotContainer').style.display = 'block';
                document.getElementById('reshootButtonContainer').style.display = 'none';

                // Redraw to show pending position
                drawWizardDartboard();
            });
        }

        function drawWizardDartboard() {
            const canvas = document.getElementById('wizardDartboard');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Scale dartboard proportionally to canvas size (use smaller dimension for radius)
            const scaleFactor = Math.min(canvas.width, canvas.height) / 400;  // 400 was original canvas size
            const DARTBOARD_RADIUS = 140 * scaleFactor;
            const BULLSEYE_RADIUS = 10.5 * scaleFactor;
            const BULLS_RING_RADIUS = 28 * scaleFactor;
            const TRIPLE_INNER = 70 * scaleFactor;
            const TRIPLE_OUTER = 77 * scaleFactor;
            const DOUBLE_INNER = 126 * scaleFactor;
            const DOUBLE_OUTER = 140 * scaleFactor;
            const NUMBERS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw dartboard segments
            for (let i = 0; i < 20; i++) {
                const angle1 = (i * 18 - 9) * Math.PI / 180;
                const angle2 = ((i + 1) * 18 - 9) * Math.PI / 180;
                const isBlack = i % 2 === 0;
                const segmentColor1 = isBlack ? '#000000' : '#f5f5f5';
                const segmentColor2 = isBlack ? '#16a34a' : '#dc2626';

                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_OUTER, DOUBLE_INNER, angle1, angle2, segmentColor2);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_OUTER, TRIPLE_INNER, angle1, angle2, segmentColor2);
                drawCalibrationSegment(ctx, centerX, centerY, DOUBLE_INNER, TRIPLE_OUTER, angle1, angle2, segmentColor1);
                drawCalibrationSegment(ctx, centerX, centerY, TRIPLE_INNER, BULLS_RING_RADIUS, angle1, angle2, segmentColor1);

                // Draw numbers (scaled)
                const numberAngle = i * 18 * Math.PI / 180;
                const numberRadius = DARTBOARD_RADIUS + (20 * scaleFactor);
                const numX = centerX + Math.sin(numberAngle) * numberRadius;
                const numY = centerY - Math.cos(numberAngle) * numberRadius;

                ctx.fillStyle = 'white';
                ctx.font = `bold ${12 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(NUMBERS[i], numX, numY);
            }

            // Bull's ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLS_RING_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = '#16a34a';
            ctx.fill();

            // Bullseye
            ctx.beginPath();
            ctx.arc(centerX, centerY, BULLSEYE_RADIUS, 0, 2 * Math.PI);
            ctx.fillStyle = '#dc2626';
            ctx.fill();

            // Draw grid overlay - covers entire canvas for launch monitor accuracy
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)'; // Bright yellow, highly visible
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // Horizontal lines - cover entire canvas height
            for (let i = 0; i <= 10; i++) {
                const y = (canvas.height / 10) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Vertical lines - cover entire canvas width
            for (let i = 0; i <= 10; i++) {
                const x = (canvas.width / 10) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Center crosshair
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(centerX - 25, centerY);
            ctx.lineTo(centerX + 25, centerY);
            ctx.moveTo(centerX, centerY - 25);
            ctx.lineTo(centerX, centerY + 25);
            ctx.stroke();
            ctx.setLineDash([]);

            // Use canvas radius for full-canvas dart placement
            const canvasRadius = Math.min(canvas.width, canvas.height) / 2;

            // Draw collected shots (green dots - where user marked actual position)
            wizardShots.forEach((shot, idx) => {
                // shot.actual.x and shot.actual.y are normalized (-1 to 1)
                const x = shot.actual.x * canvasRadius;
                const y = shot.actual.y * canvasRadius;
                drawCalibrationDart(ctx, centerX + x, centerY + y, '#22c55e', 6 * scaleFactor);
            });

            // Draw current monitor reading (blue dot - using DEFAULT calibration for preview)
            if (wizardLastShotData) {
                // Use default scale factors for preview (will be calculated properly after calibration)
                const defaultHlaScale = 0.0667;  // 1/15
                const defaultVlaScale = -0.10;   // -1/10
                const defaultHlaOffset = 0;
                const defaultVlaOffset = 0.5;

                const normalizedX = wizardLastShotData.hla * defaultHlaScale + defaultHlaOffset;
                const normalizedY = wizardLastShotData.vla * defaultVlaScale + defaultVlaOffset;

                const x = normalizedX * canvasRadius;
                const y = normalizedY * canvasRadius;

                const dotX = centerX + x;
                const dotY = centerY + y;

                // Check if dot is outside visible canvas
                const isOffScreen = dotX < 0 || dotX > canvas.width || dotY < 0 || dotY > canvas.height;
                if (isOffScreen) {
                    console.warn('‚ö†Ô∏è BLUE DOT IS OFF-SCREEN!');
                    console.warn(`Calculated position: (${dotX.toFixed(1)}, ${dotY.toFixed(1)})`);
                    console.warn(`Canvas size: ${canvas.width} x ${canvas.height}`);
                    console.warn(`Monitor reading: HLA=${wizardLastShotData.hla.toFixed(2)}¬∞, VLA=${wizardLastShotData.vla.toFixed(2)}¬∞`);
                    console.warn('This is expected - you should click where you SAW the dart land on projector');
                } else {
                    console.log(`‚úì Blue dot drawn at (${dotX.toFixed(1)}, ${dotY.toFixed(1)})`);
                }

                drawCalibrationDart(ctx, dotX, dotY, '#3b82f6', 8 * scaleFactor); // Blue, slightly larger
            }

            // Draw pending shot marker (yellow/gold - awaiting confirmation)
            if (wizardPendingShot) {
                const x = wizardPendingShot.normalizedX * canvasRadius;
                const y = wizardPendingShot.normalizedY * canvasRadius;
                const dotX = centerX + x;
                const dotY = centerY + y;

                // Draw pulsing yellow marker
                drawCalibrationDart(ctx, dotX, dotY, '#fbbf24', 10 * scaleFactor); // Gold/yellow, largest

                // Draw crosshair on pending position
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 2 * scaleFactor;
                ctx.setLineDash([5 * scaleFactor, 5 * scaleFactor]);
                ctx.beginPath();
                ctx.moveTo(dotX - 20 * scaleFactor, dotY);
                ctx.lineTo(dotX + 20 * scaleFactor, dotY);
                ctx.moveTo(dotX, dotY - 20 * scaleFactor);
                ctx.lineTo(dotX, dotY + 20 * scaleFactor);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Broadcast to projector if in projector mode
            if (projectorMode) {
                try {
                    const dataUrl = canvas.toDataURL();
                    projectorChannel.postMessage({
                        type: 'game_update',
                        data: {
                            canvasData: dataUrl,
                            width: canvas.width,
                            height: canvas.height
                        }
                    });
                } catch (err) {
                    console.error('Error broadcasting wizard dartboard to projector:', err);
                }
            }
        }

        function recordWizardShot(normalizedX, normalizedY) {
            if (!wizardLastShotData) {
                console.log('‚ö†Ô∏è Cannot record wizard shot - no wizardLastShotData');
                return;
            }

            wizardShots.push({
                monitor: {
                    hla: wizardLastShotData.hla,
                    vla: wizardLastShotData.vla
                },
                actual: {
                    x: normalizedX,  // Normalized position (-1 to 1)
                    y: normalizedY
                }
            });

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚úÖ WIZARD SHOT RECORDED (#' + wizardShots.length + ')');
            console.log('Monitor reading:', wizardLastShotData);
            console.log('Actual position (normalized):', { x: normalizedX.toFixed(3), y: normalizedY.toFixed(3) });
            console.log('Setting wizardWaitingForShot = true');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            wizardLastShotData = null;
            wizardWaitingForShot = true;

            // Hide the reshoot button now that shot is recorded
            document.getElementById('reshootButtonContainer').style.display = 'none';
            document.getElementById('currentShotInfo').style.display = 'none';

            updateWizardShotCounter();
            drawWizardDartboard();

            // Auto-advance if target shots collected
            if (wizardShots.length >= wizardTargetShotCount) {
                setTimeout(() => {
                    calculateWizardCalibration();
                    wizardGoToStep(6);
                }, 500);
            }
        }

        function updateWizardShotCounter() {
            document.getElementById('shotsCollected').textContent = wizardShots.length;

            // Show skip button if at least 3 shots
            if (wizardShots.length >= 3) {
                document.getElementById('skipToResultsBtn').style.display = 'inline-block';
            }
        }

        function skipToResults() {
            if (wizardShots.length < 3) {
                alert('Please collect at least 3 shots before skipping.');
                return;
            }
            calculateWizardCalibration();
            wizardGoToStep(6);  // Step 6 is Results (after adding shot count step)
        }

        function confirmWizardShot() {
            if (!wizardPendingShot) {
                console.warn('No pending shot to confirm');
                return;
            }

            console.log('‚úì User confirmed pending shot position');

            // Record the shot
            recordWizardShot(wizardPendingShot.normalizedX, wizardPendingShot.normalizedY);

            // Clear pending state
            wizardPendingShot = null;
            document.getElementById('confirmShotContainer').style.display = 'none';

            drawWizardDartboard();
        }

        function cancelPendingShot() {
            console.log('‚úï User cancelled pending shot');

            // Clear pending state
            wizardPendingShot = null;
            document.getElementById('confirmShotContainer').style.display = 'none';

            // Show reshoot button again
            if (wizardLastShotData) {
                document.getElementById('reshootButtonContainer').style.display = 'block';
            }

            drawWizardDartboard();
        }

        // Arrow key handler for fine-tuning calibration shot position
        document.addEventListener('keydown', function(event) {
            // Only active when wizard is in shot collection step AND has pending shot
            if (wizardCurrentStep !== 5 || !wizardPendingShot) return;

            const canvas = document.getElementById('wizardDartboard');
            if (!canvas) return;

            // Movement amount: 1px normal, 10px with shift
            const moveAmount = event.shiftKey ? 10 : 1;

            let moved = false;
            switch(event.key) {
                case 'ArrowLeft':
                    wizardPendingShot.pixelX -= moveAmount;
                    moved = true;
                    break;
                case 'ArrowRight':
                    wizardPendingShot.pixelX += moveAmount;
                    moved = true;
                    break;
                case 'ArrowUp':
                    wizardPendingShot.pixelY -= moveAmount;
                    moved = true;
                    break;
                case 'ArrowDown':
                    wizardPendingShot.pixelY += moveAmount;
                    moved = true;
                    break;
                case 'Enter':
                    // Confirm shot with Enter key
                    confirmWizardShot();
                    event.preventDefault();
                    return;
                case 'Escape':
                    // Cancel with Escape key
                    cancelPendingShot();
                    event.preventDefault();
                    return;
            }

            if (moved) {
                event.preventDefault();

                // Recalculate normalized coordinates from pixel position
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const dartX = wizardPendingShot.pixelX - centerX;
                const dartY = wizardPendingShot.pixelY - centerY;
                const canvasRadius = Math.min(canvas.width, canvas.height) / 2;
                wizardPendingShot.normalizedX = dartX / canvasRadius;
                wizardPendingShot.normalizedY = dartY / canvasRadius;

                console.log(`Arrow key: Moved pending shot to (${wizardPendingShot.pixelX.toFixed(1)}, ${wizardPendingShot.pixelY.toFixed(1)})`);

                // Redraw
                drawWizardDartboard();
            }
        });

        function reshootWizardShot() {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üîÑ RESHOOT REQUESTED - Clearing current shot');
            console.log('Discarding shot data:', wizardLastShotData);
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            // Clear the current shot
            wizardLastShotData = null;
            wizardWaitingForShot = true;

            // Hide the reshoot button
            document.getElementById('reshootButtonContainer').style.display = 'none';
            document.getElementById('currentShotInfo').style.display = 'none';

            // Redraw dartboard (removes blue dot)
            drawWizardDartboard();
        }

        // Linear regression helper function
        function linearRegression(xValues, yValues) {
            const n = xValues.length;
            if (n === 0) return { slope: 0, intercept: 0 };

            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            for (let i = 0; i < n; i++) {
                sumX += xValues[i];
                sumY += yValues[i];
                sumXY += xValues[i] * yValues[i];
                sumX2 += xValues[i] * xValues[i];
            }

            // Least squares formulas
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            return { slope, intercept };
        }

        // Calculate R¬≤ (coefficient of determination) for goodness of fit
        function calculateR2(xValues, yValues, slope, intercept) {
            const n = xValues.length;
            if (n === 0) return 0;

            const yMean = yValues.reduce((a, b) => a + b, 0) / n;

            let ssTotal = 0; // Total sum of squares
            let ssResidual = 0; // Residual sum of squares

            for (let i = 0; i < n; i++) {
                const yPredicted = slope * xValues[i] + intercept;
                ssTotal += Math.pow(yValues[i] - yMean, 2);
                ssResidual += Math.pow(yValues[i] - yPredicted, 2);
            }

            return 1 - (ssResidual / ssTotal);
        }

        // Polynomial (quadratic) regression: y = a*x^2 + b*x + c
        function quadraticRegression(xValues, yValues) {
            const n = xValues.length;
            if (n < 3) return null; // Need at least 3 points for quadratic

            // Build normal equations matrix
            let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0;
            let sumY = 0, sumXY = 0, sumX2Y = 0;

            for (let i = 0; i < n; i++) {
                const x = xValues[i];
                const y = yValues[i];
                const x2 = x * x;
                const x3 = x2 * x;
                const x4 = x3 * x;

                sumX += x;
                sumX2 += x2;
                sumX3 += x3;
                sumX4 += x4;
                sumY += y;
                sumXY += x * y;
                sumX2Y += x2 * y;
            }

            // Solve the system of equations using Cramer's rule
            const denominator = n * sumX2 * sumX4 + sumX * sumX3 * sumX2 + sumX2 * sumX * sumX3
                              - sumX2 * sumX2 * sumX2 - n * sumX3 * sumX3 - sumX * sumX * sumX4;

            if (Math.abs(denominator) < 1e-10) return null; // Singular matrix

            const a = (n * sumX2 * sumX2Y + sumX * sumX3 * sumY + sumX2 * sumXY * sumX
                     - sumX2 * sumX2 * sumY - n * sumX3 * sumXY - sumX * sumX * sumX2Y) / denominator;

            const b = (n * sumX2Y * sumX4 + sumY * sumX3 * sumX2 + sumX2 * sumX * sumXY
                     - sumX2 * sumX2Y * sumX2 - n * sumX3 * sumXY - sumY * sumX * sumX4) / denominator;

            const c = (sumY * sumX2 * sumX4 + sumX * sumXY * sumX2 + sumX2Y * sumX * sumX3
                     - sumX2 * sumXY * sumX2 - sumY * sumX3 * sumX3 - sumX2Y * sumX * sumX2) / denominator;

            return { a, b, c };
        }

        // Calculate R¬≤ for polynomial regression
        function calculateQuadraticR2(xValues, yValues, a, b, c) {
            const n = xValues.length;
            if (n === 0) return 0;

            const yMean = yValues.reduce((sum, val) => sum + val, 0) / n;

            let ssTotal = 0;
            let ssResidual = 0;

            for (let i = 0; i < n; i++) {
                const x = xValues[i];
                const yPredicted = a * x * x + b * x + c;
                ssTotal += Math.pow(yValues[i] - yMean, 2);
                ssResidual += Math.pow(yValues[i] - yPredicted, 2);
            }

            return 1 - (ssResidual / ssTotal);
        }

        // Analyze shot spread quality
        function analyzeShotSpread(shots) {
            const n = shots.length;
            if (n === 0) return { quality: 'none', message: 'No shots collected' };

            // Calculate spread in normalized coordinates
            const xValues = shots.map(s => s.actual.x);
            const yValues = shots.map(s => s.actual.y);

            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Check if shots cover enough of the dartboard (normalized -1 to 1 = 2 units total)
            const horizontalCoverage = xRange / 2; // 0-1 scale
            const verticalCoverage = yRange / 2;

            // Calculate standard deviation to check clustering
            const xMean = xValues.reduce((a, b) => a + b, 0) / n;
            const yMean = yValues.reduce((a, b) => a + b, 0) / n;
            const xStd = Math.sqrt(xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0) / n);
            const yStd = Math.sqrt(yValues.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0) / n);

            let quality = 'good';
            let warnings = [];

            if (horizontalCoverage < 0.3) {
                warnings.push('Shots clustered horizontally - try hitting left AND right edges');
                quality = 'fair';
            }
            if (verticalCoverage < 0.3) {
                warnings.push('Shots clustered vertically - try hitting top AND bottom of dartboard');
                quality = 'fair';
            }
            if (horizontalCoverage < 0.2 && verticalCoverage < 0.2) {
                quality = 'poor';
                warnings.push('Shots too clustered - spread shots across entire dartboard');
            }
            if (n < 5) {
                warnings.push('Few shots collected - 10 shots recommended for best accuracy');
            }

            return {
                quality,
                horizontalCoverage: (horizontalCoverage * 100).toFixed(0),
                verticalCoverage: (verticalCoverage * 100).toFixed(0),
                xStd: xStd.toFixed(3),
                yStd: yStd.toFixed(3),
                warnings
            };
        }

        function calculateWizardCalibration() {
            if (wizardShots.length === 0) {
                alert('No shots collected!');
                return;
            }

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üìä CALCULATING CALIBRATION (LINEAR + POLYNOMIAL)');
            console.log('Shots collected:', wizardShots.length);

            // Analyze shot spread quality
            const spreadAnalysis = analyzeShotSpread(wizardShots);
            console.log('Shot spread quality:', spreadAnalysis.quality);
            console.log('Horizontal coverage:', spreadAnalysis.horizontalCoverage + '%');
            console.log('Vertical coverage:', spreadAnalysis.verticalCoverage + '%');
            if (spreadAnalysis.warnings.length > 0) {
                console.warn('Shot spread warnings:', spreadAnalysis.warnings);
            }

            // Extract data for regression
            const hlaValues = wizardShots.map(s => s.monitor.hla);
            const vlaValues = wizardShots.map(s => s.monitor.vla);
            const xValues = wizardShots.map(s => s.actual.x);
            const yValues = wizardShots.map(s => s.actual.y);

            // Try LINEAR regression first
            const hlaLinear = linearRegression(hlaValues, xValues);
            const vlaLinear = linearRegression(vlaValues, yValues);
            const hlaLinearR2 = calculateR2(hlaValues, xValues, hlaLinear.slope, hlaLinear.intercept);
            const vlaLinearR2 = calculateR2(vlaValues, yValues, vlaLinear.slope, vlaLinear.intercept);

            console.log('LINEAR - HLA R¬≤:', hlaLinearR2.toFixed(3), 'VLA R¬≤:', vlaLinearR2.toFixed(3));

            // Try POLYNOMIAL (quadratic) regression if we have enough shots
            let hlaQuad = null, vlaQuad = null;
            let hlaQuadR2 = 0, vlaQuadR2 = 0;
            let usePolynomial = { hla: false, vla: false };

            if (wizardShots.length >= 5) {
                hlaQuad = quadraticRegression(hlaValues, xValues);
                vlaQuad = quadraticRegression(vlaValues, yValues);

                if (hlaQuad) {
                    hlaQuadR2 = calculateQuadraticR2(hlaValues, xValues, hlaQuad.a, hlaQuad.b, hlaQuad.c);
                    console.log('POLYNOMIAL - HLA R¬≤:', hlaQuadR2.toFixed(3));
                    // Use polynomial if it's significantly better (at least 5% improvement)
                    if (hlaQuadR2 > hlaLinearR2 + 0.05) {
                        usePolynomial.hla = true;
                        console.log('‚úÖ Using POLYNOMIAL for HLA (better fit)');
                    }
                }

                if (vlaQuad) {
                    vlaQuadR2 = calculateQuadraticR2(vlaValues, yValues, vlaQuad.a, vlaQuad.b, vlaQuad.c);
                    console.log('POLYNOMIAL - VLA R¬≤:', vlaQuadR2.toFixed(3));
                    if (vlaQuadR2 > vlaLinearR2 + 0.05) {
                        usePolynomial.vla = true;
                        console.log('‚úÖ Using POLYNOMIAL for VLA (better fit)');
                    }
                }
            }

            // Select best model for each axis
            const finalHlaR2 = usePolynomial.hla ? hlaQuadR2 : hlaLinearR2;
            const finalVlaR2 = usePolynomial.vla ? vlaQuadR2 : vlaLinearR2;

            console.log('FINAL - HLA R¬≤:', finalHlaR2.toFixed(3), usePolynomial.hla ? '(polynomial)' : '(linear)');
            console.log('FINAL - VLA R¬≤:', finalVlaR2.toFixed(3), usePolynomial.vla ? '(polynomial)' : '(linear)');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            // Store results for application
            window.wizardCalibrationResults = {
                // Linear coefficients (always store for backward compatibility)
                hla_scale: hlaLinear.slope,
                hla_offset: hlaLinear.intercept,
                vla_scale: vlaLinear.slope,
                vla_offset: vlaLinear.intercept,

                // Polynomial coefficients (if used)
                usePolynomial: usePolynomial,
                hla_poly: usePolynomial.hla ? hlaQuad : null,
                vla_poly: usePolynomial.vla ? vlaQuad : null,

                // Quality metrics
                hlaR2: finalHlaR2,
                vlaR2: finalVlaR2,
                shotCount: wizardShots.length,
                spreadQuality: spreadAnalysis.quality,
                spreadWarnings: spreadAnalysis.warnings
            };

            // Update UI
            document.getElementById('finalHLA').textContent = hlaLinear.slope.toFixed(4);
            document.getElementById('finalVLA').textContent = vlaLinear.slope.toFixed(4);
            document.getElementById('finalShotCount').textContent = wizardShots.length;

            // Build enhanced shot analysis with prediction errors
            let analysisHTML = '<div style="margin-bottom: 15px;">';

            // Quality badge
            const qualityColor = spreadAnalysis.quality === 'good' ? '#22c55e' :
                                spreadAnalysis.quality === 'fair' ? '#f59e0b' : '#ef4444';
            analysisHTML += `<div style="background: ${qualityColor}33; border: 2px solid ${qualityColor}; padding: 10px; border-radius: 8px; margin-bottom: 15px;">`;
            analysisHTML += `<strong>Calibration Quality:</strong> ${spreadAnalysis.quality.toUpperCase()}<br>`;
            analysisHTML += `<strong>Coverage:</strong> H: ${spreadAnalysis.horizontalCoverage}%, V: ${spreadAnalysis.verticalCoverage}%<br>`;
            analysisHTML += `<strong>Fit Quality:</strong> HLA: ${(finalHlaR2 * 100).toFixed(1)}%, VLA: ${(finalVlaR2 * 100).toFixed(1)}%`;
            if (usePolynomial.hla || usePolynomial.vla) {
                analysisHTML += `<br><strong>Model:</strong> ${usePolynomial.hla ? 'Polynomial (HLA)' : 'Linear (HLA)'}, ${usePolynomial.vla ? 'Polynomial (VLA)' : 'Linear (VLA)'}`;
            }
            analysisHTML += '</div>';

            // Warnings
            if (spreadAnalysis.warnings.length > 0) {
                analysisHTML += '<div style="background: rgba(251, 191, 36, 0.15); border-left: 3px solid #fbbf24; padding: 10px; margin-bottom: 15px;">';
                analysisHTML += '<strong>‚ö†Ô∏è Recommendations:</strong><ul style="margin: 5px 0 0 20px;">';
                spreadAnalysis.warnings.forEach(warning => {
                    analysisHTML += `<li>${warning}</li>`;
                });
                analysisHTML += '</ul></div>';
            }

            // Shot-by-shot errors
            analysisHTML += '<strong>Shot Errors:</strong><ul style="list-style: none; padding: 0; font-size: 0.9em;">';
            wizardShots.forEach((shot, idx) => {
                let predictedX, predictedY;

                if (usePolynomial.hla && hlaQuad) {
                    const hla = shot.monitor.hla;
                    predictedX = hlaQuad.a * hla * hla + hlaQuad.b * hla + hlaQuad.c;
                } else {
                    predictedX = shot.monitor.hla * hlaLinear.slope + hlaLinear.intercept;
                }

                if (usePolynomial.vla && vlaQuad) {
                    const vla = shot.monitor.vla;
                    predictedY = vlaQuad.a * vla * vla + vlaQuad.b * vla + vlaQuad.c;
                } else {
                    predictedY = shot.monitor.vla * vlaLinear.slope + vlaLinear.intercept;
                }

                const errorX = Math.abs(shot.actual.x - predictedX);
                const errorY = Math.abs(shot.actual.y - predictedY);
                const totalError = Math.sqrt(errorX*errorX + errorY*errorY);

                const errorPct = (totalError * 50).toFixed(1); // Convert normalized to % of radius
                const errorColor = totalError < 0.1 ? '#22c55e' : totalError < 0.2 ? '#f59e0b' : '#ef4444';

                analysisHTML += `<li style="margin-bottom: 6px; color: ${errorColor};">Shot ${idx + 1}: Error ${totalError.toFixed(3)} (${errorPct}% of radius)</li>`;
            });
            analysisHTML += '</ul></div>';

            document.getElementById('shotAnalysis').innerHTML = analysisHTML;
        }

        function applyWizardCalibration() {
            if (!window.wizardCalibrationResults) {
                alert('No calibration results available. Please complete the calibration wizard first.');
                return;
            }

            const results = window.wizardCalibrationResults;

            // Apply to projector profile
            calibrationProfiles.projector.hla_scale = results.hla_scale;
            calibrationProfiles.projector.hla_offset = results.hla_offset;
            calibrationProfiles.projector.vla_scale = results.vla_scale;
            calibrationProfiles.projector.vla_offset = results.vla_offset;

            // Save polynomial coefficients if used
            if (results.usePolynomial) {
                calibrationProfiles.projector.usePolynomial = results.usePolynomial;
                calibrationProfiles.projector.hla_poly = results.hla_poly;
                calibrationProfiles.projector.vla_poly = results.vla_poly;
            }

            // Save to localStorage
            localStorage.setItem('darts_calibration_profiles', JSON.stringify(calibrationProfiles));
            localStorage.setItem('darts_has_calibrated', 'true');

            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚úÖ WIZARD CALIBRATION APPLIED');
            console.log('Projector profile updated:', calibrationProfiles.projector);
            if (results.usePolynomial && (results.usePolynomial.hla || results.usePolynomial.vla)) {
                console.log('Using POLYNOMIAL regression for better accuracy!');
            }
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            const fitQuality = Math.min(results.hlaR2, results.vlaR2);
            let fitMessage = '';
            if (fitQuality > 0.9) fitMessage = '(Excellent fit!)';
            else if (fitQuality > 0.7) fitMessage = '(Good fit)';
            else if (fitQuality > 0.5) fitMessage = '(Fair fit - consider recalibrating with better spread)';
            else fitMessage = '(Poor fit - shots may need more spread across dartboard)';

            let modelInfo = '';
            if (results.usePolynomial && (results.usePolynomial.hla || results.usePolynomial.vla)) {
                modelInfo = '\n\nüî¨ Using advanced polynomial model for improved accuracy at edges!';
            }

            let warningInfo = '';
            if (results.spreadWarnings && results.spreadWarnings.length > 0) {
                warningInfo = '\n\n‚ö†Ô∏è Suggestions:\n' + results.spreadWarnings.join('\n');
            }

            alert(`Calibration applied successfully! ${fitMessage}\n\n` +
                  `HLA Scale: ${results.hla_scale.toFixed(4)}\n` +
                  `HLA Offset: ${results.hla_offset.toFixed(4)}\n` +
                  `VLA Scale: ${results.vla_scale.toFixed(4)}\n` +
                  `VLA Offset: ${results.vla_offset.toFixed(4)}\n\n` +
                  `Based on ${results.shotCount} shots\n` +
                  `Fit Quality: ${(fitQuality * 100).toFixed(1)}%` +
                  `${modelInfo}${warningInfo}`);

            // Close wizard
            document.getElementById('calibrationWizard').style.display = 'none';
            wizardInProgress = false;
            wizardShots = [];
            window.wizardCalibrationResults = null;

            // Close projector if it was opened during wizard
            if (projectorWindow && !projectorWindow.closed) {
                projectorWindow.close();
                projectorWindow = null;
                projectorMode = false;
                window.projectorMode = false;
                document.body.classList.remove('projector-mode');
                updateActiveProfile();
            }
        }

        function cancelWizardCalibration() {
            if (confirm('Are you sure you want to cancel calibration?')) {
                document.getElementById('calibrationWizard').style.display = 'none';
                wizardInProgress = false;
                wizardShots = [];
                wizardWaitingForShot = false;

                // Close projector if it was opened
                if (projectorWindow && !projectorWindow.closed) {
                    projectorWindow.close();
                    projectorWindow = null;
                    projectorMode = false;
                    window.projectorMode = false;
                    document.body.classList.remove('projector-mode');
                    updateActiveProfile();
                }
            }
        }

        function clearAllCalibration() {
            if (confirm('‚ö†Ô∏è Clear ALL calibration data?\n\nThis will reset both Computer and Projector profiles to defaults.\n\nYou will need to recalibrate.\n\nAre you sure?')) {
                // Reset to default profiles
                calibrationProfiles = {
                    computer: {
                        hla_scale: 0.0667,
                        vla_scale: -0.10,
                        hla_offset: 0,
                        vla_offset: 0.5,
                        hla_offset_legacy: 0,
                        vla_offset_legacy: 0
                    },
                    projector: {
                        hla_scale: 0.0667,
                        vla_scale: -0.10,
                        hla_offset: 0,
                        vla_offset: 0.5,
                        hla_offset_legacy: 0,
                        vla_offset_legacy: 0
                    }
                };

                // Update global reference
                window.calibrationProfiles = calibrationProfiles;

                // Clear localStorage
                localStorage.removeItem('darts_calibration_profiles');
                localStorage.removeItem('darts_has_calibrated');
                localStorage.removeItem('darts_wizard_skipped');

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üóëÔ∏è ALL CALIBRATION DATA CLEARED');
                console.log('Profiles reset to defaults:', calibrationProfiles);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

                alert('‚úÖ All calibration data cleared!\n\nBoth Computer and Projector profiles have been reset to defaults.\n\nYou can now run the calibration wizard to set up new calibration.');
            }
        }

        // Intercept shots during wizard calibration
        function handleWizardShot(shotData) {
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üéØ WIZARD SHOT HANDLER CALLED');
            console.log('wizardInProgress:', wizardInProgress);
            console.log('wizardWaitingForShot:', wizardWaitingForShot);
            console.log('wizardCurrentStep:', wizardCurrentStep);
            console.log('shotData:', shotData);

            if (!wizardInProgress || !wizardWaitingForShot) {
                console.log('‚ùå WIZARD NOT ACTIVE - Shot will go to normal game');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
                return false;
            }

            console.log('‚úÖ WIZARD INTERCEPTING SHOT');
            wizardLastShotData = {
                hla: shotData.hla,
                vla: shotData.vla
            };

            wizardWaitingForShot = false;

            // Update UI
            document.getElementById('lastMonitorHLA').textContent = shotData.hla.toFixed(2);
            document.getElementById('lastMonitorVLA').textContent = shotData.vla.toFixed(2);
            document.getElementById('currentShotInfo').style.display = 'block';

            const reshootBtn = document.getElementById('reshootButtonContainer');
            const currentShotInfo = document.getElementById('currentShotInfo');

            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üìç SHOWING RESHOOT BUTTON & SHOT INFO');
            console.log('reshootButtonContainer element:', reshootBtn);
            console.log('currentShotInfo element:', currentShotInfo);

            // Make sure confirm button is hidden when new shot arrives
            const confirmContainer = document.getElementById('confirmShotContainer');
            if (confirmContainer) {
                confirmContainer.style.display = 'none';
            }

            if (reshootBtn) {
                const beforeDisplay = window.getComputedStyle(reshootBtn).display;
                reshootBtn.style.display = 'block';
                reshootBtn.style.visibility = 'visible'; // Force visibility
                const afterDisplay = window.getComputedStyle(reshootBtn).display;
                console.log('Reshoot button display (before):', beforeDisplay);
                console.log('Reshoot button display (after):', afterDisplay);
                console.log('Reshoot button visible:', reshootBtn.offsetWidth > 0 && reshootBtn.offsetHeight > 0);
                console.log('Reshoot button parent:', reshootBtn.parentElement);
                console.log('Reshoot button parent display:', reshootBtn.parentElement ? window.getComputedStyle(reshootBtn.parentElement).display : 'N/A');
            } else {
                console.error('‚ùå ERROR: reshootButtonContainer element not found in DOM!');
            }

            if (currentShotInfo) {
                currentShotInfo.style.display = 'block';
                console.log('‚úì Current shot info shown');
            }
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

            // Redraw dartboard to show the blue dot (monitor reading)
            drawWizardDartboard();

            console.log('Wizard waiting for user to mark position for shot:', wizardLastShotData);
            console.log('Blue dot drawn at monitor reading - waiting for user click or reshoot');
            console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

            return true; // Signal that wizard handled the shot
        }

        // ==================================================================
        // END CALIBRATION WIZARD SYSTEM
        // ==================================================================

        // Apply calibration to shot data (using active profile)
        function applyCalibratedShot(shotData) {
            const profile = calibrationProfiles[activeCalibrationProfile];
            return {
                ...shotData,
                hla: shotData.hla + profile.hla_offset,
                vla: shotData.vla + profile.vla_offset
            };
        }

        // Load calibration on startup
        loadCalibration();

        // Initialize Electron IPC listeners
        console.log('Initializing Electron IPC...');
        console.log('window.electronAPI available:', !!window.electronAPI);

        if (window.electronAPI) {
            console.log('‚úì Electron API detected - setting up listeners');

            // Listen for connection status updates
            window.electronAPI.onConnectionStatus((status) => {
                console.log('Connection status update:', status);
                updateConnectionStatus(status.connected, status.receivingData);
                if (status.port) {
                    updateDebugPanel('Port', status.port);
                }
            });

            // Listen for Nova status updates
            window.electronAPI.onNovaStatus((status) => {
                console.log('Nova status update:', status);
                const novaStatusText = document.getElementById('novaStatusText');
                if (novaStatusText) {
                    const statusIcons = {
                        'discovering': 'üîç',
                        'connecting': 'üîå',
                        'connected': '‚úÖ',
                        'error': '‚ùå',
                        'not-found': '‚ö†Ô∏è',
                        'disconnected': 'üîå',
                        'stopped': 'üõë'
                    };
                    const icon = statusIcons[status.status] || 'üì°';
                    novaStatusText.textContent = `${icon} ${status.message}`;
                }
            });

            // Listen for shot data
            window.electronAPI.onShotData((shotData) => {
                totalShotsReceived++;

                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üéØ SHOT DATA RECEIVED IN RENDERER');
                console.log('Shot data (raw):', shotData);

                // Check if quick cal is active and should intercept this shot
                if (handleQuickCalShot(shotData)) {
                    console.log('Shot intercepted by quick calibration');
                    return;
                }

                // Check if wizard is active and should intercept this shot
                if (handleWizardShot(shotData)) {
                    console.log('Shot intercepted by calibration wizard');
                    return; // Don't process further if wizard handled it
                }

                // Apply calibration
                const calibratedShot = applyCalibratedShot(shotData);
                console.log('Shot data (calibrated):', calibratedShot);
                console.log('Calibration offsets:', calibrationProfiles[activeCalibrationProfile]);

                // Calculate carry distance using aerodynamic model
                calibratedShot.carry_distance = calculateCarry(calibratedShot);
                console.log('Calculated carry distance:', calibratedShot.carry_distance, 'yards');

                console.log('Current game exists:', !!currentGame);
                console.log('Game active:', currentGame ? currentGame.gameActive : 'N/A');

                // Update debug panel
                const now = new Date();
                updateDebugPanel('LastShot', now.toLocaleTimeString());
                updateDebugPanel('TotalShots', totalShotsReceived);
                updateDebugPanel('Status', currentGame ? (currentGame.gameActive ? '‚úì Processing shot' : '‚ö† Game not active') : '‚ö† No game started');

                if (currentGame) {
                    console.log('Calling currentGame.handleShot()...');
                    try {
                        currentGame.handleShot(calibratedShot);
                        console.log('‚úì handleShot() completed');
                        updateDebugPanel('Status', '‚úì Shot processed successfully');
                    } catch (err) {
                        console.error('‚ùå Error in handleShot():', err);
                        updateDebugPanel('Status', '‚ùå Error: ' + err.message);
                    }

                    console.log('Calling updateDataDisplay()...');
                    try {
                        updateDataDisplay(calibratedShot);
                        console.log('‚úì updateDataDisplay() completed');
                    } catch (err) {
                        console.error('‚ùå Error in updateDataDisplay():', err);
                    }
                } else {
                    console.warn('‚ö† No active game - shot ignored');
                    console.warn('  User needs to click "Play Darts" and complete setup');
                    updateDebugPanel('Status', '‚ö† No game - click "Play Darts"');
                }
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
            });

            // Get initial connection status
            window.electronAPI.getConnectionStatus().then((status) => {
                updateConnectionStatus(status.connected);
            });
        }

        function updateConnectionStatus(connected, receivingData) {
            isConnected = connected;
            const statusEl = document.getElementById('connectionStatus');
            const indicator = statusEl.querySelector('.status-indicator');
            const text = statusEl.querySelector('span');
            const tabBtn = document.getElementById('settingsTabBtn');
            const radialContainer = document.querySelector('.radial-container');

            if (connected && receivingData) {
                // Actually receiving data from launch monitor
                statusEl.className = 'connection-status connected';
                indicator.className = 'status-indicator connected';
                text.textContent = '‚úì Connected to Launch Monitor (Receiving Data)';
                if (tabBtn) { tabBtn.classList.add('connected'); tabBtn.classList.remove('disconnected'); }
                if (radialContainer) { radialContainer.classList.add('connected'); radialContainer.classList.remove('disconnected'); }
            } else if (connected && !receivingData) {
                // Listening but no data yet
                statusEl.className = 'connection-status disconnected';
                indicator.className = 'status-indicator disconnected';
                text.textContent = '‚è≥ Listening on port 921 (No data yet - check firewall)';
                if (tabBtn) { tabBtn.classList.add('disconnected'); tabBtn.classList.remove('connected'); }
                // Only play fadeOut if games were previously shown
                if (radialContainer && radialContainer.classList.contains('connected')) {
                    radialContainer.classList.add('disconnected');
                }
                if (radialContainer) { radialContainer.classList.remove('connected'); }
            } else {
                // Not connected at all
                statusEl.className = 'connection-status disconnected';
                indicator.className = 'status-indicator disconnected';
                text.textContent = '‚ö† Starting up...';
                if (tabBtn) { tabBtn.classList.add('disconnected'); tabBtn.classList.remove('connected'); }
                // Only play fadeOut if games were previously shown
                if (radialContainer && radialContainer.classList.contains('connected')) {
                    radialContainer.classList.add('disconnected');
                }
                if (radialContainer) { radialContainer.classList.remove('connected'); }
            }
        }

        function startGame() {
            console.log('Starting Darts game...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('dartsGameMode', 'local');
            localStorage.removeItem('dartsSteamLobby');

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');

            console.log('Creating DartsGame instance...');
            currentGame = new DartsGame();

            console.log('Initializing game...');
            currentGame.init();
        }


        async function startSkeeBall() {
            console.log('üé± startSkeeBall() called');
            console.log('Starting Skee-Ball game...');
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');

            if (!window.SkeeBallGame) {
                alert('Skee-Ball game is still loading. Please try again in a moment.');
                backToMenu();
                return;
            }

            console.log('Creating SkeeBallGame instance...');
            window.currentSkeeBallGame = new window.SkeeBallGame();
            currentGame = window.currentSkeeBallGame;

            console.log('Initializing Skee-Ball...');
            currentGame.init();

            console.log('Game initialized. gameActive:', currentGame.gameActive);
            console.log('‚úì Game ready - waiting for shots!');

            // Update debug panel
            updateDebugPanel('GameActive', currentGame.gameActive ? 'Yes - waiting for setup' : 'No');
            updateDebugPanel('Status', 'Game started - complete player setup');

            if (projectorMode) {
                broadcastGameStart('darts');
            }
        }

        function startHomeRunDerby() {
            console.log('‚öæ Starting Home Run Derby...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('homerunGameMode', 'local');
            localStorage.removeItem('homerunSteamLobby');

            // Hide menu, show game container with setup
            document.getElementById('menuScreen').style.display = 'none';
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.classList.add('active');

            // Initialize Home Run Derby setup
            showHomeRunDerbySetup();
        }

        function startPuttPractice() {
            console.log('‚õ≥ Starting Putt-Practice...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('puttingGameMode', 'local');
            localStorage.removeItem('puttingSteamLobby');

            // Hide menu, show game container with setup
            document.getElementById('menuScreen').style.display = 'none';
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.classList.add('active');

            // Initialize Putt-Practice setup
            showPuttPracticeSetup();
        }

        function showHomeRunDerbySetup() {
            const gameContent = document.getElementById('gameContent');
            gameContent.innerHTML = `
                <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
                    <h2 style="text-align: center; margin-bottom: 30px;">‚öæ Home Run Derby Setup</h2>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Number of Players</h3>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${[1,2,3,4].map(n => `
                                <button onclick="setHomeRunDerbyPlayerCount(${n})"
                                        style="flex: 1; min-width: 80px; padding: 15px; font-size: 1.2em;
                                               background: rgba(251, 191, 36, 0.3); border: 2px solid #fbbf24;
                                               color: white; border-radius: 8px; cursor: pointer;">
                                    ${n} Player${n > 1 ? 's' : ''}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">üìê Visual Offset (Projector Alignment)</h3>
                        <!-- Live Preview Canvas -->
                        <div style="margin-bottom: 20px; text-align: center;">
                            <canvas id="homerunOffsetPreviewCanvas" width="600" height="400"
                                    style="border: 2px solid #fbbf24; border-radius: 8px; background: #1a1a1a; max-width: 100%;"></canvas>
                            <div style="font-size: 0.9em; opacity: 0.7; margin-top: 8px;">
                                Live Preview - Adjust sliders to see offset in real-time
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Horizontal: <span id="homerunOffsetXValue" style="color: #fbbf24;">0</span> px
                            </div>
                            <input type="range" id="homerunOffsetXSlider" min="-500" max="500" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #fbbf24;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üê Left (-500)</span>
                                <span>Center (0)</span>
                                <span>Right (+500) ‚Üí</span>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Vertical: <span id="homerunOffsetYValue" style="color: #fbbf24;">0</span> px
                            </div>
                            <input type="range" id="homerunOffsetYSlider" min="-300" max="300" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #fbbf24;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üë Up (-300)</span>
                                <span>Center (0)</span>
                                <span>Down (+300) ‚Üì</span>
                            </div>
                        </div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                            Adjust if your projector/screen is not centered.<br>
                            Shifts the camera view to align with your physical setup.
                        </div>
                    </div>

                    <div id="homeRunPlayerNamesSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Player Names</h3>
                        <div id="homeRunPlayerNameInputs"></div>
                    </div>

                    <div id="homeRunStartSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; text-align: center;">
                        <button onclick="launchHomeRunDerbyGame()"
                                style="padding: 20px 40px; font-size: 1.3em; background: rgba(251, 191, 36, 0.5);
                                       border: 2px solid #fbbf24; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            üöÄ Launch Game
                        </button>
                        <br><br>
                        <button onclick="backToMenu()"
                                style="padding: 10px 20px; background: rgba(100,100,100,0.5); border: 2px solid #666;
                                       color: white; border-radius: 8px; cursor: pointer;">
                            ‚Üê Back to Menu
                        </button>
                    </div>
                </div>
            `;

            // Setup Visual Offset sliders
            setTimeout(() => {
                const offsetXSlider = document.getElementById('homerunOffsetXSlider');
                const offsetXValue = document.getElementById('homerunOffsetXValue');
                const offsetYSlider = document.getElementById('homerunOffsetYSlider');
                const offsetYValue = document.getElementById('homerunOffsetYValue');

                const savedOffsetX = localStorage.getItem('golfVisualOffsetX') || '0';
                const savedOffsetY = localStorage.getItem('golfVisualOffsetY') || '0';

                const previewCanvas = document.getElementById('homerunOffsetPreviewCanvas');
                const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;

                // Function to draw preview with offset
                function drawOffsetPreview(offsetX, offsetY) {
                    if (!previewCtx) return;

                    const canvas = previewCanvas;
                    const w = canvas.width;
                    const h = canvas.height;

                    // Clear canvas
                    previewCtx.fillStyle = '#1a1a1a';
                    previewCtx.fillRect(0, 0, w, h);

                    // Apply offset transform (scale down for preview - 600px canvas represents ~1920px screen)
                    const scale = w / 1920;
                    const offsetXScaled = offsetX * scale;
                    const offsetYScaled = offsetY * scale;

                    previewCtx.save();
                    previewCtx.translate(offsetXScaled, offsetYScaled);

                    // Draw grid
                    previewCtx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
                    previewCtx.lineWidth = 1;
                    for (let x = 0; x <= w; x += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(x, 0);
                        previewCtx.lineTo(x, h);
                        previewCtx.stroke();
                    }
                    for (let y = 0; y <= h; y += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(0, y);
                        previewCtx.lineTo(w, y);
                        previewCtx.stroke();
                    }

                    // Draw center crosshairs
                    previewCtx.strokeStyle = '#fbbf24';
                    previewCtx.lineWidth = 2;
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const crossSize = 30;

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX - crossSize, centerY);
                    previewCtx.lineTo(centerX + crossSize, centerY);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - crossSize);
                    previewCtx.lineTo(centerX, centerY + crossSize);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                    previewCtx.stroke();

                    // Draw corner markers
                    previewCtx.fillStyle = '#fbbf24';
                    const markerSize = 5;
                    previewCtx.fillRect(10, 10, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, 10, markerSize, markerSize);
                    previewCtx.fillRect(10, h - 10 - markerSize, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, h - 10 - markerSize, markerSize, markerSize);

                    // Draw "TARGET" text
                    previewCtx.font = 'bold 24px Arial';
                    previewCtx.fillStyle = '#fbbf24';
                    previewCtx.textAlign = 'center';
                    previewCtx.textBaseline = 'middle';
                    previewCtx.fillText('TARGET', centerX, centerY + 50);

                    previewCtx.restore();

                    // Red border if offset active
                    if (offsetX !== 0 || offsetY !== 0) {
                        previewCtx.strokeStyle = '#ef4444';
                        previewCtx.lineWidth = 3;
                        previewCtx.strokeRect(2, 2, w - 4, h - 4);
                    }
                }

                if (offsetXSlider && offsetXValue) {
                    offsetXSlider.value = savedOffsetX;
                    offsetXValue.textContent = savedOffsetX;
                    offsetXSlider.addEventListener('input', (e) => {
                        offsetXValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetX', e.target.value);
                        drawOffsetPreview(parseInt(e.target.value), parseInt(offsetYSlider.value));
                    });
                }

                if (offsetYSlider && offsetYValue) {
                    offsetYSlider.value = savedOffsetY;
                    offsetYValue.textContent = savedOffsetY;
                    offsetYSlider.addEventListener('input', (e) => {
                        offsetYValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetY', e.target.value);
                        drawOffsetPreview(parseInt(offsetXSlider.value), parseInt(e.target.value));
                    });
                }

                // Initial draw
                drawOffsetPreview(parseInt(savedOffsetX), parseInt(savedOffsetY));
            }, 100);
        }

        window.homeRunDerbyPlayers = [];

        function setHomeRunDerbyPlayerCount(count) {
            window.homeRunDerbyPlayers = [];
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe'];

            for (let i = 0; i < count; i++) {
                window.homeRunDerbyPlayers.push({
                    name: `Player ${i + 1}`,
                    color: colors[i] || '#ffffff',
                    powerMultiplier: 1.0
                });
            }

            // Show player name inputs
            const section = document.getElementById('homeRunPlayerNamesSection');
            const inputsDiv = document.getElementById('homeRunPlayerNameInputs');

            inputsDiv.innerHTML = window.homeRunDerbyPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.homeRunDerbyPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((color, colorIndex) => `
                                <button onclick="selectHomeRunDerbyPlayerColor(${i}, '${color}')"
                                        id="hrColorBtn${i}_${colorIndex}"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${color}; border: 3px solid ${player.color === color ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === color ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + color + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(139, 92, 246, 0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.4);">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.9em; opacity: 0.9;">
                            üë∂ Power Boost (for kids/beginners):
                        </label>
                        <select onchange="window.homeRunDerbyPlayers[${i}].powerMultiplier = parseFloat(this.value)"
                                style="width: 100%; padding: 8px; font-size: 0.95em;
                                       background: rgba(0,0,0,0.3); border: 2px solid rgba(139, 92, 246, 0.6);
                                       color: white; border-radius: 6px; cursor: pointer;">
                            <option value="1.0" selected>None (1.0x)</option>
                            <option value="2.0">2x Boost</option>
                            <option value="3.0">3x Boost</option>
                            <option value="4.0">4x Boost</option>
                            <option value="5.0">5x Boost</option>
                        </select>
                        <div style="margin-top: 6px; font-size: 0.85em; opacity: 0.7; line-height: 1.3;">
                            Multiplies ball speed for weak shots (< 70 mph)
                        </div>
                    </div>
                </div>
            `).join('');

            section.style.display = 'block';
            document.getElementById('homeRunStartSection').style.display = 'block';
        }

        function selectHomeRunDerbyPlayerColor(playerIndex, color) {
            // Check if color is already taken by another player
            const colorTaken = window.homeRunDerbyPlayers.some((p, i) => i !== playerIndex && p.color === color);

            if (colorTaken) {
                alert('This color is already taken by another player!');
                return;
            }

            // Save current player data before re-rendering
            window.homeRunDerbyPlayers.forEach((p, i) => {
                const nameInput = document.querySelector(`#homeRunPlayerNameInputs input[onchange*="[${i}].name"]`);
                const powerSelect = document.querySelector(`#homeRunPlayerNameInputs select[onchange*="[${i}].powerMultiplier"]`);
                if (nameInput) p.name = nameInput.value.trim() || p.name;
                if (powerSelect) p.powerMultiplier = parseFloat(powerSelect.value);
            });

            // Update player color
            window.homeRunDerbyPlayers[playerIndex].color = color;

            // Re-render with updated colors
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe'];
            const inputsDiv = document.getElementById('homeRunPlayerNameInputs');

            inputsDiv.innerHTML = window.homeRunDerbyPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.homeRunDerbyPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectHomeRunDerbyPlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(139, 92, 246, 0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.4);">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.9em; opacity: 0.9;">
                            üë∂ Power Boost (for kids/beginners):
                        </label>
                        <select onchange="window.homeRunDerbyPlayers[${i}].powerMultiplier = parseFloat(this.value)"
                                style="width: 100%; padding: 8px; font-size: 0.95em;
                                       background: rgba(0,0,0,0.3); border: 2px solid rgba(139, 92, 246, 0.6);
                                       color: white; border-radius: 6px; cursor: pointer;">
                            <option value="1.0" ${player.powerMultiplier === 1.0 ? 'selected' : ''}>None (1.0x)</option>
                            <option value="2.0" ${player.powerMultiplier === 2.0 ? 'selected' : ''}>2x Boost</option>
                            <option value="3.0" ${player.powerMultiplier === 3.0 ? 'selected' : ''}>3x Boost</option>
                            <option value="4.0" ${player.powerMultiplier === 4.0 ? 'selected' : ''}>4x Boost</option>
                            <option value="5.0" ${player.powerMultiplier === 5.0 ? 'selected' : ''}>5x Boost</option>
                        </select>
                        <div style="margin-top: 6px; font-size: 0.85em; opacity: 0.7; line-height: 1.3;">
                            Multiplies ball speed for weak shots (< 70 mph)
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function launchHomeRunDerbyGame() {
            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'homerun-derby.html',
                title: 'Home Run Derby',
                width: 1200,
                height: 800,
                playerData: {
                    players: window.homeRunDerbyPlayers,
                    currentPlayer: 0
                }
            });

            // Return to menu
            backToMenu();
        }

        function showPuttPracticeSetup() {
            const gameContent = document.getElementById('gameContent');
            gameContent.innerHTML = `
                <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
                    <h2 style="text-align: center; margin-bottom: 30px;">‚õ≥ Putting Practice Setup</h2>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Number of Players</h3>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${[1,2,3,4].map(n => `
                                <button onclick="setPuttingPlayerCount(${n})"
                                        style="flex: 1; min-width: 80px; padding: 15px; font-size: 1.2em;
                                               background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e;
                                               color: white; border-radius: 8px; cursor: pointer;">
                                    ${n} Player${n > 1 ? 's' : ''}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">üìê Visual Offset (Projector Alignment)</h3>
                        <!-- Live Preview Canvas -->
                        <div style="margin-bottom: 20px; text-align: center;">
                            <canvas id="puttOffsetPreviewCanvas" width="600" height="400"
                                    style="border: 2px solid #22c55e; border-radius: 8px; background: #1a1a1a; max-width: 100%;"></canvas>
                            <div style="font-size: 0.9em; opacity: 0.7; margin-top: 8px;">
                                Live Preview - Adjust sliders to see offset in real-time
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Horizontal: <span id="puttOffsetXValue" style="color: #22c55e;">0</span> px
                            </div>
                            <input type="range" id="puttOffsetXSlider" min="-500" max="500" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #22c55e;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üê Left (-500)</span>
                                <span>Center (0)</span>
                                <span>Right (+500) ‚Üí</span>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Vertical: <span id="puttOffsetYValue" style="color: #22c55e;">0</span> px
                            </div>
                            <input type="range" id="puttOffsetYSlider" min="-300" max="300" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #22c55e;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üë Up (-300)</span>
                                <span>Center (0)</span>
                                <span>Down (+300) ‚Üì</span>
                            </div>
                        </div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                            Adjust if your projector/screen is not centered.<br>
                            Shifts the camera view to align with your physical setup.
                        </div>
                    </div>

                    <div id="puttingPlayerNamesSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Player Names</h3>
                        <div id="puttingPlayerNameInputs"></div>
                    </div>

                    <div id="puttingStartSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; text-align: center;">
                        <button onclick="launchPuttPracticeGame()"
                                style="padding: 20px 40px; font-size: 1.3em; background: rgba(34, 197, 94, 0.5);
                                       border: 2px solid #22c55e; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            üöÄ Launch Game
                        </button>
                        <br><br>
                        <button onclick="backToMenu()"
                                style="padding: 10px 20px; background: rgba(100,100,100,0.5); border: 2px solid #666;
                                       color: white; border-radius: 8px; cursor: pointer;">
                            ‚Üê Back to Menu
                        </button>
                    </div>
                </div>
            `;

            // Setup Visual Offset sliders
            setTimeout(() => {
                const offsetXSlider = document.getElementById('puttOffsetXSlider');
                const offsetXValue = document.getElementById('puttOffsetXValue');
                const offsetYSlider = document.getElementById('puttOffsetYSlider');
                const offsetYValue = document.getElementById('puttOffsetYValue');

                const savedOffsetX = localStorage.getItem('golfVisualOffsetX') || '0';
                const savedOffsetY = localStorage.getItem('golfVisualOffsetY') || '0';

                const previewCanvas = document.getElementById('puttOffsetPreviewCanvas');
                const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;

                // Function to draw preview with offset
                function drawOffsetPreview(offsetX, offsetY) {
                    if (!previewCtx) return;

                    const canvas = previewCanvas;
                    const w = canvas.width;
                    const h = canvas.height;

                    // Clear canvas
                    previewCtx.fillStyle = '#1a1a1a';
                    previewCtx.fillRect(0, 0, w, h);

                    // Apply offset transform (scale down for preview - 600px canvas represents ~1920px screen)
                    const scale = w / 1920;
                    const offsetXScaled = offsetX * scale;
                    const offsetYScaled = offsetY * scale;

                    previewCtx.save();
                    previewCtx.translate(offsetXScaled, offsetYScaled);

                    // Draw grid
                    previewCtx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
                    previewCtx.lineWidth = 1;
                    for (let x = 0; x <= w; x += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(x, 0);
                        previewCtx.lineTo(x, h);
                        previewCtx.stroke();
                    }
                    for (let y = 0; y <= h; y += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(0, y);
                        previewCtx.lineTo(w, y);
                        previewCtx.stroke();
                    }

                    // Draw center crosshairs
                    previewCtx.strokeStyle = '#22c55e';
                    previewCtx.lineWidth = 2;
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const crossSize = 30;

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX - crossSize, centerY);
                    previewCtx.lineTo(centerX + crossSize, centerY);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - crossSize);
                    previewCtx.lineTo(centerX, centerY + crossSize);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                    previewCtx.stroke();

                    // Draw corner markers
                    previewCtx.fillStyle = '#22c55e';
                    const markerSize = 5;
                    previewCtx.fillRect(10, 10, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, 10, markerSize, markerSize);
                    previewCtx.fillRect(10, h - 10 - markerSize, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, h - 10 - markerSize, markerSize, markerSize);

                    // Draw "TARGET" text
                    previewCtx.font = 'bold 24px Arial';
                    previewCtx.fillStyle = '#22c55e';
                    previewCtx.textAlign = 'center';
                    previewCtx.textBaseline = 'middle';
                    previewCtx.fillText('TARGET', centerX, centerY + 50);

                    previewCtx.restore();

                    // Red border if offset active
                    if (offsetX !== 0 || offsetY !== 0) {
                        previewCtx.strokeStyle = '#ef4444';
                        previewCtx.lineWidth = 3;
                        previewCtx.strokeRect(2, 2, w - 4, h - 4);
                    }
                }

                if (offsetXSlider && offsetXValue) {
                    offsetXSlider.value = savedOffsetX;
                    offsetXValue.textContent = savedOffsetX;
                    offsetXSlider.addEventListener('input', (e) => {
                        offsetXValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetX', e.target.value);
                        drawOffsetPreview(parseInt(e.target.value), parseInt(offsetYSlider.value));
                    });
                }

                if (offsetYSlider && offsetYValue) {
                    offsetYSlider.value = savedOffsetY;
                    offsetYValue.textContent = savedOffsetY;
                    offsetYSlider.addEventListener('input', (e) => {
                        offsetYValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetY', e.target.value);
                        drawOffsetPreview(parseInt(offsetXSlider.value), parseInt(e.target.value));
                    });
                }

                // Initial draw
                drawOffsetPreview(parseInt(savedOffsetX), parseInt(savedOffsetY));
            }, 100);
        }

        window.puttingPlayers = [];

        function setPuttingPlayerCount(count) {
            window.puttingPlayers = [];
            const colors = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];

            for (let i = 0; i < count; i++) {
                window.puttingPlayers.push({
                    name: `Player ${i + 1}`,
                    color: colors[i] || '#ffffff'
                });
            }

            // Show player name inputs
            const section = document.getElementById('puttingPlayerNamesSection');
            const inputsDiv = document.getElementById('puttingPlayerNameInputs');

            inputsDiv.innerHTML = window.puttingPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.puttingPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectPuttingPlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `).join('');

            section.style.display = 'block';
            document.getElementById('puttingStartSection').style.display = 'block';
        }

        function selectPuttingPlayerColor(playerIndex, color) {
            window.puttingPlayers[playerIndex].color = color;
            refreshPuttingPlayerInputs();
        }

        function refreshPuttingPlayerInputs() {
            const colors = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
            const inputsDiv = document.getElementById('puttingPlayerNameInputs');

            inputsDiv.innerHTML = window.puttingPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.puttingPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectPuttingPlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function launchPuttPracticeGame() {
            if (!window.puttingPlayers || window.puttingPlayers.length === 0) {
                alert('Please add at least one player');
                return;
            }

            // Save players to localStorage
            localStorage.setItem('puttingPlayers', JSON.stringify(window.puttingPlayers));
            localStorage.setItem('puttingCurrentPlayer', '0');

            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'putting-green.html',
                title: 'Putt Practice',
                width: 1400,
                height: 900,
                playerData: {
                    players: window.puttingPlayers,
                    currentPlayer: 0
                }
            });

            // Return to menu
            backToMenu();
        }

        function startBowling() {
            console.log('üé≥ Starting Bowling...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('bowlingGameMode', 'local');
            localStorage.removeItem('bowlingSteamLobby');

            // Hide menu, show game container with setup
            document.getElementById('menuScreen').style.display = 'none';
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.classList.add('active');

            // Initialize Bowling setup
            showBowlingSetup();
        }

        function showBowlingSetup() {
            const gameContent = document.getElementById('gameContent');
            gameContent.innerHTML = `
                <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
                    <h2 style="text-align: center; margin-bottom: 30px;">üé≥ Bowling Setup</h2>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Number of Players</h3>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${[1,2,3,4].map(n => `
                                <button onclick="setBowlingPlayerCount(${n})"
                                        style="flex: 1; min-width: 80px; padding: 15px; font-size: 1.2em;
                                               background: rgba(255, 107, 53, 0.3); border: 2px solid #FF6B35;
                                               color: white; border-radius: 8px; cursor: pointer;">
                                    ${n} Player${n > 1 ? 's' : ''}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">üìê Visual Offset (Projector Alignment)</h3>
                        <!-- Live Preview Canvas -->
                        <div style="margin-bottom: 20px; text-align: center;">
                            <canvas id="bowlingOffsetPreviewCanvas" width="600" height="400"
                                    style="border: 2px solid #FF6B35; border-radius: 8px; background: #1a1a1a; max-width: 100%;"></canvas>
                            <div style="font-size: 0.9em; opacity: 0.7; margin-top: 8px;">
                                Live Preview - Adjust sliders to see offset in real-time
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Horizontal: <span id="bowlingOffsetXValue" style="color: #FF6B35;">0</span> px
                            </div>
                            <input type="range" id="bowlingOffsetXSlider" min="-500" max="500" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #FF6B35;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üê Left (-500)</span>
                                <span>Center (0)</span>
                                <span>Right (+500) ‚Üí</span>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Vertical: <span id="bowlingOffsetYValue" style="color: #FF6B35;">0</span> px
                            </div>
                            <input type="range" id="bowlingOffsetYSlider" min="-300" max="300" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #FF6B35;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üë Up (-300)</span>
                                <span>Center (0)</span>
                                <span>Down (+300) ‚Üì</span>
                            </div>
                        </div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                            Adjust if your projector/screen is not centered.<br>
                            Shifts the camera view to align with your physical setup.
                        </div>
                    </div>

                    <div id="bowlingPlayerNamesSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Player Names</h3>
                        <div id="bowlingPlayerNameInputs"></div>
                    </div>

                    <div id="bowlingStartSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; text-align: center;">
                        <button onclick="launchBowlingGame()"
                                style="padding: 20px 40px; font-size: 1.3em; background: rgba(255, 107, 53, 0.5);
                                       border: 2px solid #FF6B35; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            üöÄ Launch Game
                        </button>
                        <br><br>
                        <button onclick="backToMenu()"
                                style="padding: 10px 20px; background: rgba(100,100,100,0.5); border: 2px solid #666;
                                       color: white; border-radius: 8px; cursor: pointer;">
                            ‚Üê Back to Menu
                        </button>
                    </div>
                </div>
            `;

            // Setup Visual Offset sliders
            setTimeout(() => {
                const offsetXSlider = document.getElementById('bowlingOffsetXSlider');
                const offsetXValue = document.getElementById('bowlingOffsetXValue');
                const offsetYSlider = document.getElementById('bowlingOffsetYSlider');
                const offsetYValue = document.getElementById('bowlingOffsetYValue');

                // Load saved offset values from localStorage
                const savedOffsetX = localStorage.getItem('golfVisualOffsetX') || '0';
                const savedOffsetY = localStorage.getItem('golfVisualOffsetY') || '0';

                const previewCanvas = document.getElementById('bowlingOffsetPreviewCanvas');
                const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;

                // Function to draw preview with offset
                function drawOffsetPreview(offsetX, offsetY) {
                    if (!previewCtx) return;

                    const canvas = previewCanvas;
                    const w = canvas.width;
                    const h = canvas.height;

                    // Clear canvas
                    previewCtx.fillStyle = '#1a1a1a';
                    previewCtx.fillRect(0, 0, w, h);

                    // Apply offset transform (scale down for preview - 600px canvas represents ~1920px screen)
                    const scale = w / 1920;
                    const offsetXScaled = offsetX * scale;
                    const offsetYScaled = offsetY * scale;

                    previewCtx.save();
                    previewCtx.translate(offsetXScaled, offsetYScaled);

                    // Draw grid
                    previewCtx.strokeStyle = 'rgba(255, 107, 53, 0.3)';
                    previewCtx.lineWidth = 1;
                    for (let x = 0; x <= w; x += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(x, 0);
                        previewCtx.lineTo(x, h);
                        previewCtx.stroke();
                    }
                    for (let y = 0; y <= h; y += 50) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(0, y);
                        previewCtx.lineTo(w, y);
                        previewCtx.stroke();
                    }

                    // Draw center crosshairs
                    previewCtx.strokeStyle = '#FF6B35';
                    previewCtx.lineWidth = 2;
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const crossSize = 30;

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX - crossSize, centerY);
                    previewCtx.lineTo(centerX + crossSize, centerY);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.moveTo(centerX, centerY - crossSize);
                    previewCtx.lineTo(centerX, centerY + crossSize);
                    previewCtx.stroke();

                    previewCtx.beginPath();
                    previewCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                    previewCtx.stroke();

                    // Draw corner markers
                    previewCtx.fillStyle = '#FF6B35';
                    const markerSize = 5;
                    previewCtx.fillRect(10, 10, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, 10, markerSize, markerSize);
                    previewCtx.fillRect(10, h - 10 - markerSize, markerSize, markerSize);
                    previewCtx.fillRect(w - 10 - markerSize, h - 10 - markerSize, markerSize, markerSize);

                    // Draw "TARGET" text
                    previewCtx.font = 'bold 24px Arial';
                    previewCtx.fillStyle = '#FF6B35';
                    previewCtx.textAlign = 'center';
                    previewCtx.textBaseline = 'middle';
                    previewCtx.fillText('TARGET', centerX, centerY + 50);

                    previewCtx.restore();

                    // Red border if offset active
                    if (offsetX !== 0 || offsetY !== 0) {
                        previewCtx.strokeStyle = '#ef4444';
                        previewCtx.lineWidth = 3;
                        previewCtx.strokeRect(2, 2, w - 4, h - 4);
                    }
                }

                if (offsetXSlider && offsetXValue) {
                    offsetXSlider.value = savedOffsetX;
                    offsetXValue.textContent = savedOffsetX;
                    offsetXSlider.addEventListener('input', (e) => {
                        offsetXValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetX', e.target.value);
                        drawOffsetPreview(parseInt(e.target.value), parseInt(offsetYSlider.value));
                    });
                }

                if (offsetYSlider && offsetYValue) {
                    offsetYSlider.value = savedOffsetY;
                    offsetYValue.textContent = savedOffsetY;
                    offsetYSlider.addEventListener('input', (e) => {
                        offsetYValue.textContent = e.target.value;
                        localStorage.setItem('golfVisualOffsetY', e.target.value);
                        drawOffsetPreview(parseInt(offsetXSlider.value), parseInt(e.target.value));
                    });
                }

                // Initial draw
                drawOffsetPreview(parseInt(savedOffsetX), parseInt(savedOffsetY));
            }, 100);
        }

        window.bowlingPlayers = [];

        function setBowlingPlayerCount(count) {
            window.bowlingPlayers = [];
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe'];

            for (let i = 0; i < count; i++) {
                window.bowlingPlayers.push({
                    name: `Player ${i + 1}`,
                    color: colors[i] || '#ffffff',
                    bumpers: false,
                    powerMultiplier: 1.0
                });
            }

            // Show player name inputs
            const section = document.getElementById('bowlingPlayerNamesSection');
            const inputsDiv = document.getElementById('bowlingPlayerNameInputs');

            inputsDiv.innerHTML = window.bowlingPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.bowlingPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectBowlingPlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 12px;">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
                            <input type="checkbox"
                                   ${player.bumpers ? 'checked' : ''}
                                   onchange="window.bowlingPlayers[${i}].bumpers = this.checked; refreshBowlingPlayerInputs();"
                                   style="width: 20px; height: 20px; cursor: pointer;">
                            <span style="font-size: 1em; color: white;">üõ°Ô∏è Bumpers (Kids Mode)</span>
                        </label>
                    </div>

                    <div style="margin-top: 12px; background: rgba(139, 92, 246, 0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.4);">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.9em; opacity: 0.9;">
                            üë∂ Power Boost (for kids/beginners):
                        </label>
                        <select onchange="window.bowlingPlayers[${i}].powerMultiplier = parseFloat(this.value)"
                                style="width: 100%; padding: 8px; font-size: 0.95em;
                                       background: rgba(0,0,0,0.3); border: 2px solid rgba(139, 92, 246, 0.6);
                                       color: white; border-radius: 6px; cursor: pointer;">
                            <option value="1.0" ${player.powerMultiplier === 1.0 ? 'selected' : ''}>None (1.0x)</option>
                            <option value="2.0" ${player.powerMultiplier === 2.0 ? 'selected' : ''}>2x Boost</option>
                            <option value="3.0" ${player.powerMultiplier === 3.0 ? 'selected' : ''}>3x Boost</option>
                            <option value="4.0" ${player.powerMultiplier === 4.0 ? 'selected' : ''}>4x Boost</option>
                            <option value="5.0" ${player.powerMultiplier === 5.0 ? 'selected' : ''}>5x Boost</option>
                        </select>
                        <div style="margin-top: 6px; font-size: 0.85em; opacity: 0.7; line-height: 1.3;">
                            Multiplies ball speed for weak shots (< 70 mph)
                        </div>
                    </div>
                </div>
            `).join('');

            section.style.display = 'block';
            document.getElementById('bowlingStartSection').style.display = 'block';
        }

        function selectBowlingPlayerColor(playerIndex, color) {
            window.bowlingPlayers[playerIndex].color = color;
            // Refresh the display without recreating players
            refreshBowlingPlayerInputs();
        }

        function refreshBowlingPlayerInputs() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#a29bfe'];
            const inputsDiv = document.getElementById('bowlingPlayerNameInputs');

            inputsDiv.innerHTML = window.bowlingPlayers.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.bowlingPlayers[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectBowlingPlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="margin-top: 12px;">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
                            <input type="checkbox"
                                   ${player.bumpers ? 'checked' : ''}
                                   onchange="window.bowlingPlayers[${i}].bumpers = this.checked; refreshBowlingPlayerInputs();"
                                   style="width: 20px; height: 20px; cursor: pointer;">
                            <span style="font-size: 1em; color: white;">üõ°Ô∏è Bumpers (Kids Mode)</span>
                        </label>
                    </div>

                    <div style="margin-top: 12px; background: rgba(139, 92, 246, 0.2); padding: 12px; border-radius: 8px; border: 1px solid rgba(139, 92, 246, 0.4);">
                        <label style="display: block; margin-bottom: 8px; font-size: 0.9em; opacity: 0.9;">
                            üë∂ Power Boost (for kids/beginners):
                        </label>
                        <select onchange="window.bowlingPlayers[${i}].powerMultiplier = parseFloat(this.value)"
                                style="width: 100%; padding: 8px; font-size: 0.95em;
                                       background: rgba(0,0,0,0.3); border: 2px solid rgba(139, 92, 246, 0.6);
                                       color: white; border-radius: 6px; cursor: pointer;">
                            <option value="1.0" ${player.powerMultiplier === 1.0 ? 'selected' : ''}>None (1.0x)</option>
                            <option value="2.0" ${player.powerMultiplier === 2.0 ? 'selected' : ''}>2x Boost</option>
                            <option value="3.0" ${player.powerMultiplier === 3.0 ? 'selected' : ''}>3x Boost</option>
                            <option value="4.0" ${player.powerMultiplier === 4.0 ? 'selected' : ''}>4x Boost</option>
                            <option value="5.0" ${player.powerMultiplier === 5.0 ? 'selected' : ''}>5x Boost</option>
                        </select>
                        <div style="margin-top: 6px; font-size: 0.85em; opacity: 0.7; line-height: 1.3;">
                            Multiplies ball speed for weak shots (< 70 mph)
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function launchBowlingGame() {
            // Save players to localStorage
            localStorage.setItem('bowlingPlayers', JSON.stringify(window.bowlingPlayers));
            localStorage.setItem('bowlingCurrentPlayer', '0');

            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'bowling.html',
                title: 'Bowling',
                width: 1400,
                height: 900,
                playerData: {
                    players: window.bowlingPlayers,
                    currentPlayer: 0
                }
            });

            // Return to menu
            backToMenu();
        }

        function startSoccerPenalty() {
            console.log('‚öΩ Starting Soccer Penalty...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('soccerGameMode', 'local');
            localStorage.removeItem('soccerSteamLobby');

            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'soccer-penalty.html',
                title: 'Soccer Penalty Kick',
                width: 1400,
                height: 900
            });
        }

        function startBeerPong() {
            console.log('üç∫ Starting Beer Pong...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('beerPongGameMode', 'local');
            localStorage.removeItem('beerPongSteamLobby');

            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'beer-pong.html',
                title: 'Beer Pong',
                width: 1400,
                height: 900
            });
        }

        function startGolfPar3() {
            console.log('‚õ≥ Starting Golf Courses...');

            // Set local mode (not Steam multiplayer)
            localStorage.setItem('golfGameMode', 'local');
            localStorage.removeItem('golfSteamLobby');

            // Hide menu, show game container with setup
            document.getElementById('menuScreen').style.display = 'none';
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.classList.add('active');

            // Initialize Golf Par 3 setup
            showGolfPar3Setup();
        }

        const golfCourseNames = {
            shanktuary: 'Shanktuary Hills Golf',
            rockwiga: 'Rockwiga Country Club'
        };

        window.golfSelectedCourse = 'shanktuary';
        window.golfSelectedHoles = 'all'; // Default to all holes
        window.golfGameMode = 'standard'; // 'standard' | 'draft-solo' | 'draft-multi'

        try {
            const storedCourse = localStorage.getItem('golfSelectedCourse');
            if (storedCourse && golfCourseNames[storedCourse]) {
                window.golfSelectedCourse = storedCourse;
            }
        } catch (e) {
            console.log('Could not load golf course selection, using default');
        }

        function selectGolfGameMode(mode) {
            window.golfGameMode = mode;

            // Update button styles
            const modes = ['standard', 'draft-solo', 'draft-multi'];
            const modeIds = ['gameModeStandard', 'gameModeDraftSolo', 'gameModeDraftMulti'];

            modeIds.forEach((id, i) => {
                const btn = document.getElementById(id);
                if (btn) {
                    if (modes[i] === mode) {
                        btn.style.background = 'rgba(74, 222, 128, 0.5)';
                        btn.style.border = '3px solid #4ade80';
                        btn.style.fontWeight = 'bold';
                    } else {
                        btn.style.background = 'rgba(74, 222, 128, 0.3)';
                        btn.style.border = '2px solid #4ade80';
                        btn.style.fontWeight = 'normal';
                    }
                }
            });

            // Show/hide draft description
            const draftDesc = document.getElementById('draftGolfDescription');
            if (draftDesc) {
                draftDesc.style.display = mode.startsWith('draft') ? 'block' : 'none';
            }

            // For draft modes, auto-set player count based on mode
            if (mode === 'draft-solo') {
                // Solo mode: 1 human + 3 AI (handled in game)
                // Hide player count section as it's fixed for draft
            } else if (mode === 'draft-multi') {
                // Multi mode: 4 humans (handled in game)
            }

            console.log('Selected game mode:', mode);
        }

        function showGolfPar3Setup() {
            const gameContent = document.getElementById('gameContent');
            gameContent.innerHTML = `
                <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
                    <h2 style="text-align: center; margin-bottom: 30px;">‚õ≥ Golf Courses Setup</h2>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Select Course</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
                            <button onclick="selectGolfCourse('shanktuary')" id="courseShanktuary"
                                    style="padding: 20px; font-size: 1.05em; background: rgba(74, 222, 128, 0.5);
                                           border: 3px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                üèûÔ∏è Shanktuary Hills
                            </button>
                            <button onclick="selectGolfCourse('rockwiga')" id="courseRockwiga"
                                    style="padding: 20px; font-size: 1.05em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                üå≤ Rockwiga Country Club
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Select Holes to Play</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
                            <button onclick="selectGolfHoles('all')" id="holesAll"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.5);
                                           border: 3px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                üèåÔ∏è Full Round<br><span style="font-size: 0.9em; opacity: 0.8;">All 5 Holes</span>
                            </button>
                            <button onclick="selectGolfHoles(1)" id="holes1"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                ‚õ≥ Hole 1<br><span style="font-size: 0.9em; opacity: 0.8;">Par 3 - 150 yds</span>
                            </button>
                            <button onclick="selectGolfHoles(2)" id="holes2"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                üå≥ Hole 2<br><span style="font-size: 0.9em; opacity: 0.8;">Par 4 - 320 yds Dogleg L</span>
                            </button>
                            <button onclick="selectGolfHoles(3)" id="holes3"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                üèùÔ∏è Hole 3<br><span style="font-size: 0.9em; opacity: 0.8;">Par 4 - 250 yds Islands</span>
                            </button>
                            <button onclick="selectGolfHoles(4)" id="holes4"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                üíß Hole 4<br><span style="font-size: 0.9em; opacity: 0.8;">Par 4 - 395 yds Dogleg R</span>
                            </button>
                            <button onclick="selectGolfHoles(5)" id="holes5"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                üå≤ Hole 5<br><span style="font-size: 0.9em; opacity: 0.8;">Par 5 - 494 yds Pines</span>
                            </button>
                            <button onclick="selectGolfHoles(6)" id="holes6"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; display: none;">
                                üå≥ Hole 6<br><span style="font-size: 0.9em; opacity: 0.8;">Par 4 - 326 yds</span>
                            </button>
                            <button onclick="selectGolfHoles(7)" id="holes7"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; display: none;">
                                üèåÔ∏è Hole 7<br><span style="font-size: 0.9em; opacity: 0.8;">Par 5 - 434 yds</span>
                            </button>
                            <button onclick="selectGolfHoles(8)" id="holes8"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; display: none;">
                                ‚õ∞Ô∏è Hole 8<br><span style="font-size: 0.9em; opacity: 0.8;">Par 3 - 148 yds</span>
                            </button>
                            <button onclick="selectGolfHoles(9)" id="holes9"
                                    style="padding: 20px; font-size: 1.1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; display: none;">
                                üîÑ Hole 9<br><span style="font-size: 0.9em; opacity: 0.8;">Par 4 - 398 yds</span>
                            </button>
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Number of Players</h3>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${[1,2,3,4].map(n => `
                                <button onclick="setGolfPar3PlayerCount(${n})"
                                        style="flex: 1; min-width: 80px; padding: 15px; font-size: 1.2em;
                                               background: rgba(74, 222, 128, 0.3); border: 2px solid #4ade80;
                                               color: white; border-radius: 8px; cursor: pointer;">
                                    ${n} Player${n > 1 ? 's' : ''}
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Game Mode</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                            <button onclick="selectGolfGameMode('standard')" id="gameModeStandard"
                                    style="padding: 20px; font-size: 1em; background: rgba(74, 222, 128, 0.5);
                                           border: 3px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                                <div style="font-size: 1.3em; margin-bottom: 5px;">üèåÔ∏è</div>
                                Standard<br><span style="font-size: 0.8em; opacity: 0.8;">Classic golf</span>
                            </button>
                            <button onclick="selectGolfGameMode('draft-solo')" id="gameModeDraftSolo"
                                    style="padding: 20px; font-size: 1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                <div style="font-size: 1.3em; margin-bottom: 5px;">üéØ</div>
                                Draft Golf<br><span style="font-size: 0.8em; opacity: 0.8;">Solo vs 3 AI</span>
                            </button>
                            <button onclick="selectGolfGameMode('draft-multi')" id="gameModeDraftMulti"
                                    style="padding: 20px; font-size: 1em; background: rgba(74, 222, 128, 0.3);
                                           border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer;">
                                <div style="font-size: 1.3em; margin-bottom: 5px;">üë•</div>
                                Draft Golf<br><span style="font-size: 0.8em; opacity: 0.8;">4 Players</span>
                            </button>
                        </div>
                        <div id="draftGolfDescription" style="display: none; margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; font-size: 0.9em;">
                            <strong style="color: #4ade80;">Draft Golf Rules:</strong><br>
                            All 4 players hit their shots, then take turns drafting which ball position to play from next.
                            <div style="margin-top: 10px;">
                                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                    <input type="checkbox" id="draftAdvancedMode" style="width: 18px; height: 18px;">
                                    <span>Advanced: Randomize draft order each round</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Gimmie Rules</h3>
                        <label style="display: flex; align-items: center; gap: 15px; cursor: pointer; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <input type="checkbox" id="golfGimmieCircles" style="width: 24px; height: 24px; cursor: pointer;">
                            <div>
                                <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">Enable Gimmie Circles</div>
                                <div style="font-size: 0.9em; opacity: 0.8;">
                                    üü° Within 5 feet = Automatic 1 putt<br>
                                    üü† Within 10 feet = Automatic 2 putts
                                </div>
                            </div>
                        </label>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">‚õ≥ Green Speed</h3>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Stimpmeter: <span id="golfStimpValue" style="color: #4ade80;">10.0</span> ft
                            </div>
                            <input type="range" id="golfStimpSlider" min="7" max="14" step="0.5" value="10"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #4ade80;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>7 (Slow)</span>
                                <span>10 (Medium)</span>
                                <span>14 (Fast)</span>
                            </div>
                            <div style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                                Controls how far putts roll on the greens.<br>
                                Higher = faster greens (tournament conditions)
                            </div>
                        </div>
                    </div>

                    <div style="background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">üìê Visual Offset (Projector Alignment)</h3>

                        <!-- Live Preview Canvas -->
                        <div style="margin-bottom: 20px; text-align: center;">
                            <canvas id="golfOffsetPreviewCanvas" width="600" height="400"
                                    style="border: 2px solid #4ade80; border-radius: 8px; background: #1a1a1a; max-width: 100%;"></canvas>
                            <div style="font-size: 0.9em; opacity: 0.7; margin-top: 8px;">
                                Live Preview - Adjust sliders to see offset in real-time
                            </div>
                        </div>

                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Horizontal: <span id="golfOffsetXValue" style="color: #4ade80;">0</span> px
                            </div>
                            <input type="range" id="golfOffsetXSlider" min="-500" max="500" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #4ade80;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üê Left (-500)</span>
                                <span>Center (0)</span>
                                <span>Right (+500) ‚Üí</span>
                            </div>
                        </div>
                        <div style="padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 10px;">
                                Vertical: <span id="golfOffsetYValue" style="color: #4ade80;">0</span> px
                            </div>
                            <input type="range" id="golfOffsetYSlider" min="-300" max="300" step="10" value="0"
                                   style="width: 100%; height: 8px; cursor: pointer; accent-color: #4ade80;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85em; opacity: 0.7; margin-top: 8px;">
                                <span>‚Üë Up (-300)</span>
                                <span>Center (0)</span>
                                <span>Down (+300) ‚Üì</span>
                            </div>
                        </div>
                        <div style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;">
                            Adjust if your projector/screen is not centered.<br>
                            Shifts the camera view to align with your physical setup.
                        </div>
                    </div>

                    <div id="golfPar3PlayerNamesSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">Player Names</h3>
                        <div id="golfPar3PlayerNameInputs"></div>
                    </div>

                    <div id="golfPar3StartSection" style="display: none; background: rgba(0,0,0,0.3); padding: 30px; border-radius: 15px; text-align: center;">
                        <button onclick="launchGolfPar3Game()"
                                style="padding: 20px 40px; font-size: 1.3em; background: rgba(74, 222, 128, 0.5);
                                       border: 2px solid #4ade80; color: white; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            üöÄ Launch Game
                        </button>
                        <br><br>
                        <button onclick="backToMenu()"
                                style="padding: 10px 20px; background: rgba(100,100,100,0.5); border: 2px solid #666;
                                       color: white; border-radius: 8px; cursor: pointer;">
                            ‚Üê Back to Menu
                        </button>
                    </div>
                </div>
            `;

            selectGolfCourse(window.golfSelectedCourse);

            // Setup Golf Stimp slider (must be after innerHTML is set)
            const stimpSlider = document.getElementById('golfStimpSlider');
            const stimpValue = document.getElementById('golfStimpValue');
            if (stimpSlider && stimpValue) {
                stimpSlider.addEventListener('input', (e) => {
                    stimpValue.textContent = parseFloat(e.target.value).toFixed(1);
                });
            }

            // Setup Visual Offset sliders and preview
            const offsetXSlider = document.getElementById('golfOffsetXSlider');
            const offsetXValue = document.getElementById('golfOffsetXValue');
            const offsetYSlider = document.getElementById('golfOffsetYSlider');
            const offsetYValue = document.getElementById('golfOffsetYValue');
            const previewCanvas = document.getElementById('golfOffsetPreviewCanvas');
            const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;

            // Load saved offset values from localStorage
            const savedOffsetX = localStorage.getItem('golfVisualOffsetX') || '0';
            const savedOffsetY = localStorage.getItem('golfVisualOffsetY') || '0';

            // Function to draw preview with offset
            function drawOffsetPreview(offsetX, offsetY) {
                if (!previewCtx) return;

                const canvas = previewCanvas;
                const w = canvas.width;
                const h = canvas.height;

                // Clear canvas
                previewCtx.fillStyle = '#1a1a1a';
                previewCtx.fillRect(0, 0, w, h);

                // Apply offset transform (scale down for preview - 600px canvas represents ~1920px screen)
                const scale = w / 1920;
                const offsetXScaled = offsetX * scale;
                const offsetYScaled = offsetY * scale;

                previewCtx.save();
                previewCtx.translate(offsetXScaled, offsetYScaled);

                // Draw grid
                previewCtx.strokeStyle = 'rgba(74, 222, 128, 0.3)';
                previewCtx.lineWidth = 1;
                for (let x = 0; x <= w; x += 50) {
                    previewCtx.beginPath();
                    previewCtx.moveTo(x, 0);
                    previewCtx.lineTo(x, h);
                    previewCtx.stroke();
                }
                for (let y = 0; y <= h; y += 50) {
                    previewCtx.beginPath();
                    previewCtx.moveTo(0, y);
                    previewCtx.lineTo(w, y);
                    previewCtx.stroke();
                }

                // Draw center crosshairs (bright green)
                previewCtx.strokeStyle = '#4ade80';
                previewCtx.lineWidth = 2;
                const centerX = w / 2;
                const centerY = h / 2;
                const crossSize = 30;

                // Horizontal line
                previewCtx.beginPath();
                previewCtx.moveTo(centerX - crossSize, centerY);
                previewCtx.lineTo(centerX + crossSize, centerY);
                previewCtx.stroke();

                // Vertical line
                previewCtx.beginPath();
                previewCtx.moveTo(centerX, centerY - crossSize);
                previewCtx.lineTo(centerX, centerY + crossSize);
                previewCtx.stroke();

                // Draw center circle
                previewCtx.beginPath();
                previewCtx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                previewCtx.stroke();

                // Draw corner markers
                previewCtx.fillStyle = '#4ade80';
                const markerSize = 5;
                previewCtx.fillRect(10, 10, markerSize, markerSize); // Top-left
                previewCtx.fillRect(w - 10 - markerSize, 10, markerSize, markerSize); // Top-right
                previewCtx.fillRect(10, h - 10 - markerSize, markerSize, markerSize); // Bottom-left
                previewCtx.fillRect(w - 10 - markerSize, h - 10 - markerSize, markerSize, markerSize); // Bottom-right

                // Draw "TARGET" text in center
                previewCtx.font = 'bold 24px Arial';
                previewCtx.fillStyle = '#4ade80';
                previewCtx.textAlign = 'center';
                previewCtx.textBaseline = 'middle';
                previewCtx.fillText('TARGET', centerX, centerY + 50);

                previewCtx.restore();

                // Draw border indicating offset direction
                if (offsetX !== 0 || offsetY !== 0) {
                    previewCtx.strokeStyle = '#ef4444';
                    previewCtx.lineWidth = 3;
                    previewCtx.strokeRect(2, 2, w - 4, h - 4);
                }
            }

            if (offsetXSlider && offsetXValue) {
                offsetXSlider.value = savedOffsetX;
                offsetXValue.textContent = savedOffsetX;
                offsetXSlider.addEventListener('input', (e) => {
                    offsetXValue.textContent = e.target.value;
                    localStorage.setItem('golfVisualOffsetX', e.target.value);
                    drawOffsetPreview(parseInt(e.target.value), parseInt(offsetYSlider.value));
                });
            }

            if (offsetYSlider && offsetYValue) {
                offsetYSlider.value = savedOffsetY;
                offsetYValue.textContent = savedOffsetY;
                offsetYSlider.addEventListener('input', (e) => {
                    offsetYValue.textContent = e.target.value;
                    localStorage.setItem('golfVisualOffsetY', e.target.value);
                    drawOffsetPreview(parseInt(offsetXSlider.value), parseInt(e.target.value));
                });
            }

            // Draw initial preview
            drawOffsetPreview(parseInt(savedOffsetX), parseInt(savedOffsetY));
        }

        function selectGolfCourse(courseId) {
            if (!golfCourseNames[courseId]) {
                return;
            }

            window.golfSelectedCourse = courseId;

            const courses = ['shanktuary', 'rockwiga'];
            courses.forEach(id => {
                const btn = document.getElementById('course' + id.charAt(0).toUpperCase() + id.slice(1));
                if (btn) {
                    if (id === courseId) {
                        btn.style.background = 'rgba(74, 222, 128, 0.5)';
                        btn.style.border = '3px solid #4ade80';
                        btn.style.fontWeight = 'bold';
                    } else {
                        btn.style.background = 'rgba(74, 222, 128, 0.3)';
                        btn.style.border = '2px solid #4ade80';
                        btn.style.fontWeight = 'normal';
                    }
                }
            });

            updateGolfHoleOptions();
        }

        function updateGolfHoleOptions() {
            const isRockwiga = window.golfSelectedCourse === 'rockwiga';
            const holesAll = document.getElementById('holesAll');

            const rockwigaHoles = [
                { num: 1, emoji: '\u{1F332}', desc: 'Par 4 - 400 yds' },
                { num: 2, emoji: '\u26F3', desc: 'Par 3 - 160 yds' },
                { num: 3, emoji: '\u{1F3CC}\uFE0F', desc: 'Par 5 - 484 yds' },
                { num: 4, emoji: '\u{1F332}', desc: 'Par 4 - 334 yds' },
                { num: 5, emoji: '\u2199\uFE0F', desc: 'Par 4 - 317 yds' },
                { num: 6, emoji: '\u{1F333}', desc: 'Par 4 - 326 yds' },
                { num: 7, emoji: '\u2197\uFE0F', desc: 'Par 5 - 434 yds' },
                { num: 8, emoji: '\u26F0\uFE0F', desc: 'Par 3 - 148 yds' },
                { num: 9, emoji: '\u{1F504}', desc: 'Par 4 - 398 yds' }
            ];
            var shanktuaryHoles = [
                { num: 1, emoji: '\u26F3', desc: 'Par 3 - 150 yds' },
                { num: 2, emoji: '\u{1F333}', desc: 'Par 4 - 320 yds Dogleg L' },
                { num: 3, emoji: '\u{1F3DD}\uFE0F', desc: 'Par 4 - 250 yds Islands' },
                { num: 4, emoji: '\u{1F4A7}', desc: 'Par 4 - 395 yds Dogleg R' },
                { num: 5, emoji: '\u{1F332}', desc: 'Par 5 - 494 yds Pines' }
            ];

            var courseHoles = isRockwiga ? rockwigaHoles : shanktuaryHoles;

            if (holesAll) {
                holesAll.innerHTML = "\u{1F3CC}\uFE0F Full Round<br><span style=\"font-size: 0.9em; opacity: 0.8;\">All " + courseHoles.length + " Holes</span>";
            }

            for (var i = 1; i <= 9; i++) {
                var btn = document.getElementById('holes' + i);
                if (!btn) continue;
                var holeData = null;
                for (var j = 0; j < courseHoles.length; j++) {
                    if (courseHoles[j].num === i) { holeData = courseHoles[j]; break; }
                }
                if (holeData) {
                    btn.innerHTML = holeData.emoji + " Hole " + i + "<br><span style=\"font-size: 0.9em; opacity: 0.8;\">" + holeData.desc + "</span>";
                    btn.style.display = 'block';
                } else {
                    btn.style.display = 'none';
                }
            }

            var maxHole = courseHoles.length;
            if (window.golfSelectedHoles !== 'all' && window.golfSelectedHoles > maxHole) {
                window.golfSelectedHoles = 'all';
            }

            selectGolfHoles(window.golfSelectedHoles);
        }

        function selectGolfHoles(selection) {
            window.golfSelectedHoles = selection;

            // Update button styles
            ['all', 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(h => {
                const btn = document.getElementById('holes' + h);
                if (btn) {
                    if (h === selection) {
                        btn.style.background = 'rgba(74, 222, 128, 0.5)';
                        btn.style.border = '3px solid #4ade80';
                        btn.style.fontWeight = 'bold';
                    } else {
                        btn.style.background = 'rgba(74, 222, 128, 0.3)';
                        btn.style.border = '2px solid #4ade80';
                        btn.style.fontWeight = 'normal';
                    }
                }
            });
        }

        window.golfPar3Players = [];

        function setGolfPar3PlayerCount(count) {
            window.golfPar3Players = [];
            const colors = ['#4ade80', '#60a5fa', '#f472b6', '#facc15', '#a78bfa', '#fb923c'];

            for (let i = 0; i < count; i++) {
                window.golfPar3Players.push({
                    name: `Player ${i + 1}`,
                    color: colors[i] || '#ffffff',
                    autoAim: true // Default to enabled (arcade mode)
                });
            }

            // Show player name inputs
            const section = document.getElementById('golfPar3PlayerNamesSection');
            const inputsDiv = document.getElementById('golfPar3PlayerNameInputs');

            inputsDiv.innerHTML = window.golfPar3Players.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.golfPar3Players[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectGolfPar3PlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                        <input type="checkbox" id="autoAim${i}" ${player.autoAim !== false ? 'checked' : ''}
                               onchange="window.golfPar3Players[${i}].autoAim = this.checked"
                               style="width: 20px; height: 20px; cursor: pointer;">
                        <div>
                            <div style="font-size: 1em; font-weight: bold;">Auto-Aim Assist</div>
                            <div style="font-size: 0.85em; opacity: 0.7;">Automatically aims toward the hole (Arcade mode)</div>
                        </div>
                    </label>
                </div>
            `).join('');

            section.style.display = 'block';
            document.getElementById('golfPar3StartSection').style.display = 'block';
        }

        function selectGolfPar3PlayerColor(playerIndex, color) {
            window.golfPar3Players[playerIndex].color = color;
            // Refresh the display without recreating players
            refreshGolfPar3PlayerInputs();
        }

        function refreshGolfPar3PlayerInputs() {
            const colors = ['#4ade80', '#60a5fa', '#f472b6', '#facc15', '#a78bfa', '#fb923c'];
            const inputsDiv = document.getElementById('golfPar3PlayerNameInputs');

            inputsDiv.innerHTML = window.golfPar3Players.map((player, i) => `
                <div style="margin-bottom: 20px; padding: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; border-left: 4px solid ${player.color};">
                    <label style="display: block; margin-bottom: 8px; font-weight: bold; color: ${player.color};">
                        Player ${i + 1}
                    </label>
                    <input type="text"
                           value="${player.name}"
                           onchange="window.golfPar3Players[${i}].name = this.value"
                           style="width: 100%; padding: 12px; font-size: 1em; margin-bottom: 12px;
                                  background: rgba(0,0,0,0.3); border: 2px solid ${player.color};
                                  color: white; border-radius: 8px; box-sizing: border-box;">

                    <div style="margin-bottom: 12px;">
                        <div style="font-size: 0.9em; opacity: 0.8; margin-bottom: 8px;">Choose Color:</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            ${colors.map((c, colorIndex) => `
                                <button onclick="selectGolfPar3PlayerColor(${i}, '${c}')"
                                        style="width: 40px; height: 40px; border-radius: 8px;
                                               background: ${c}; border: 3px solid ${player.color === c ? 'white' : 'rgba(255,255,255,0.3)'};
                                               cursor: pointer; transition: all 0.2s ease;
                                               ${player.color === c ? 'transform: scale(1.1); box-shadow: 0 0 10px ' + c + ';' : ''}">
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                        <input type="checkbox" id="autoAim${i}" ${player.autoAim !== false ? 'checked' : ''}
                               onchange="window.golfPar3Players[${i}].autoAim = this.checked"
                               style="width: 20px; height: 20px; cursor: pointer;">
                        <div>
                            <div style="font-size: 1em; font-weight: bold;">Auto-Aim Assist</div>
                            <div style="font-size: 0.85em; opacity: 0.7;">Automatically aims toward the hole (Arcade mode)</div>
                        </div>
                    </label>
                </div>
            `).join('');
        }

        function launchGolfPar3Game() {
            // Get gimmie circles setting
            const gimmieEnabled = document.getElementById('golfGimmieCircles').checked;

            // Get green speed (Stimp) setting
            const greenStimp = parseFloat(document.getElementById('golfStimpSlider').value);

            // Get visual offset settings
            const offsetX = parseInt(document.getElementById('golfOffsetXSlider').value);
            const offsetY = parseInt(document.getElementById('golfOffsetYSlider').value);

            // Get draft golf advanced mode setting
            const draftAdvancedCheckbox = document.getElementById('draftAdvancedMode');
            const draftAdvanced = draftAdvancedCheckbox ? draftAdvancedCheckbox.checked : false;

            // Save players, hole selection, gimmie, Stimp, game mode, and visual offset settings to localStorage
            localStorage.setItem('golfPar3Players', JSON.stringify(window.golfPar3Players));
            localStorage.setItem('golfPar3CurrentPlayer', '0');
            localStorage.setItem('golfSelectedHoles', JSON.stringify(window.golfSelectedHoles));
            localStorage.setItem('golfSelectedCourse', window.golfSelectedCourse);
            localStorage.setItem('golfGimmieCircles', gimmieEnabled ? 'true' : 'false');
            localStorage.setItem('golfGreenStimp', greenStimp.toString());
            localStorage.setItem('golfVisualOffsetX', offsetX.toString());
            localStorage.setItem('golfVisualOffsetY', offsetY.toString());
            localStorage.setItem('golfGameMode', window.golfGameMode);
            localStorage.setItem('golfDraftAdvanced', draftAdvanced ? 'true' : 'false');

            // Dynamic window title based on selection
            const courseName = golfCourseNames[window.golfSelectedCourse] || 'Shanktuary Hills Golf';
            let windowTitle = courseName;
            if (window.golfSelectedHoles === 1) windowTitle += ' - Hole 1';
            else if (window.golfSelectedHoles === 2) windowTitle += ' - Hole 2';
            else if (window.golfSelectedHoles === 3) windowTitle += ' - Hole 3';
            else if (window.golfSelectedHoles === 4) windowTitle += ' - Hole 4';
            else if (window.golfSelectedHoles === 5) windowTitle += ' - Hole 5';
            else windowTitle += ' - Full Round';

            // Open in new window using Electron IPC
            window.electronAPI.openGameWindow({
                url: 'golf-par3.html',
                title: windowTitle,
                width: 1400,
                height: 900,
                playerData: {
                    players: window.golfPar3Players,
                    currentPlayer: 0,
                    gimmieCircles: gimmieEnabled
                }
            });

            // Return to menu
            backToMenu();
        }

        function backToMenu() {
            if (currentGame) {
                currentGame.cleanup();
                currentGame = null;
            }

            document.getElementById('menuScreen').style.display = '';
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('gameContent').innerHTML = '';

            // Restore darts UI elements (in case Skee-Ball hid them)
            const dataPanels = document.querySelector('.data-panels');
            if (dataPanels) dataPanels.style.display = '';

            const testButtons = document.querySelectorAll('.test-button');
            testButtons.forEach(btn => btn.style.display = '');

            const backButton = document.querySelector('.back-button');
            if (backButton) backButton.style.display = '';

            const fullscreenDropdown = document.getElementById('fullscreenDropdown');
            if (fullscreenDropdown) fullscreenDropdown.style.display = '';

            if (projectorMode) {
                projectorChannel.postMessage({ type: 'game_end' });
            }
        }

        function restartGame() {
            if (!currentGame) return;

            if (typeof currentGame.restartGame === 'function') {
                currentGame.restartGame();
            } else {
                currentGame.cleanup();
                currentGame.init();
            }
        }

        function sendTestShot() {
            if (!currentGame) return;

            const testShot = {
                ball_speed: 80 + Math.random() * 100,
                hla: (Math.random() - 0.5) * 30,
                vla: 5 + Math.random() * 20,
                total_spin: 2000 + Math.random() * 2000,
                back_spin: 2000 + Math.random() * 2000,
                side_spin: (Math.random() - 0.5) * 1000,
                spin_axis: (Math.random() - 0.5) * 30,
                carry_distance: 150 + Math.random() * 150
            };

            currentGame.handleShot(testShot);
            updateDataDisplay(testShot);
        }

        function showShotFeedback(points, message, distanceFromCenter = null) {
            const feedback = document.getElementById('shotFeedback');
            if (!feedback) return;

            feedback.querySelector('.points').textContent = points > 0 ? `+${points}` : points;
            feedback.querySelector('.message').textContent = message;

            // Display distance from center if provided
            const distanceEl = feedback.querySelector('.distance');
            if (distanceEl && distanceFromCenter !== null && distanceFromCenter !== undefined) {
                distanceEl.textContent = `üìè ${distanceFromCenter.toFixed(1)}" from center`;
            } else if (distanceEl) {
                distanceEl.textContent = '';
            }

            feedback.classList.add('show');

            setTimeout(() => {
                feedback.classList.remove('show');
            }, 2000);

            if (projectorMode) {
                projectorChannel.postMessage({
                    type: 'shot_feedback',
                    data: { points, message, distanceFromCenter }
                });
            }
        }

        // Calculate carry distance using aerodynamic model
        function calculateCarry(shotData) {
            // Physical constants
            const g = 9.81; // gravity in m/s¬≤
            const rho = 1.225; // air density in kg/m¬≥
            const mass = 0.0459; // golf ball mass in kg
            const radius = 0.0213; // golf ball radius in m
            const area = Math.PI * radius * radius;

            // Convert inputs (handle both naming conventions)
            const ballSpeed = shotData.ball_speed || shotData.ballSpeed || 0;
            const vla = shotData.vla || shotData.verticalLaunchAngle || 0;
            const hla = shotData.hla || shotData.horizontalLaunchAngle || 0;
            const spin = shotData.total_spin || shotData.spin || 2500;
            const spinAxis = shotData.spin_axis || shotData.spinAxis || 0;

            if (ballSpeed === 0 || vla === 0) {
                return 0; // Not enough data
            }

            const v0 = ballSpeed * 0.44704; // mph to m/s
            const theta = vla * Math.PI / 180; // vertical angle in radians
            const psi = hla * Math.PI / 180; // horizontal angle in radians
            const spinRPS = spin / 60; // rpm to rev/s
            const alpha = spinAxis * Math.PI / 180; // spin axis in radians

            // Initial velocity components (3D)
            let vx = v0 * Math.cos(theta) * Math.sin(psi); // lateral
            let vy = v0 * Math.cos(theta) * Math.cos(psi); // forward
            let vz = v0 * Math.sin(theta); // vertical

            // Position
            let x = 0, y = 0, z = 0;

            // Constant B from aerodynamic model
            const B = rho * area / (2 * mass);

            // Time step
            const dt = 0.01;
            let t = 0;
            const maxTime = 10;

            // Lift coefficient lookup table from A.J. Smits (1994)
            const sn_Cl_spin = [0, 0.04, 0.1, 0.2, 0.4];
            const sn_Cl_lift = [0, 0.1, 0.16, 0.23, 0.33];

            function interpolate(x, xp, fp) {
                if (x <= xp[0]) return fp[0];
                if (x >= xp[xp.length - 1]) return fp[fp.length - 1];

                for (let i = 0; i < xp.length - 1; i++) {
                    if (x >= xp[i] && x <= xp[i + 1]) {
                        const t = (x - xp[i]) / (xp[i + 1] - xp[i]);
                        return fp[i] + t * (fp[i + 1] - fp[i]);
                    }
                }
                return fp[fp.length - 1];
            }

            // Numerical integration
            while (z >= 0 && t < maxTime) {
                // Current velocity magnitude
                const v = Math.sqrt(vx*vx + vy*vy + vz*vz);

                if (v > 0.1) {
                    // Effective spin parameter (dimensionless)
                    const sn = spinRPS * 2 * Math.PI * radius / v;

                    // Drag coefficient from MacDonald and Hanzely (1991)
                    const Cd = 0.24 + 0.18 * sn;

                    // Lift coefficient from Smits table
                    const Cl = interpolate(sn, sn_Cl_spin, sn_Cl_lift);

                    // Accelerations from aerodynamic forces
                    const dvxdt = -B * v * (Cd * vx + Cl * vy * Math.sin(alpha));
                    const dvydt = -B * v * (Cd * vy - Cl * (vx * Math.sin(alpha) - vz * Math.cos(alpha)));
                    const dvzdt = -g - B * v * (Cd * vz - Cl * vy * Math.cos(alpha));

                    // Update velocities
                    vx += dvxdt * dt;
                    vy += dvydt * dt;
                    vz += dvzdt * dt;
                } else {
                    // Simple gravity for very low speeds
                    vz -= g * dt;
                }

                // Update positions
                x += vx * dt;
                y += vy * dt;
                z += vz * dt;

                t += dt;
            }

            // Convert to yards (y is the forward distance)
            const carryYards = y * 1.09361;

            return Math.round(carryYards * 10) / 10;
        }

        function updateDataDisplay(shotData) {
            document.getElementById('dataBallSpeed').textContent =
                shotData.ball_speed ? `${shotData.ball_speed.toFixed(1)} mph` : '--';
            document.getElementById('dataHLA').textContent =
                shotData.hla !== undefined ? `${shotData.hla.toFixed(1)}¬∞` : '--';
            document.getElementById('dataVLA').textContent =
                shotData.vla !== undefined ? `${shotData.vla.toFixed(1)}¬∞` : '--';
            document.getElementById('dataTotalSpin').textContent =
                shotData.total_spin ? `${shotData.total_spin.toFixed(0)} rpm` : '--';
            document.getElementById('dataSpinAxis').textContent =
                shotData.spin_axis !== undefined ? `${shotData.spin_axis.toFixed(1)}¬∞` : '--';
            document.getElementById('dataCarry').textContent =
                shotData.carry_distance ? `${shotData.carry_distance.toFixed(0)} yds` : '--';
        }

        function toggleFullscreenDropdown() {
            const dropdown = document.getElementById('fullscreenDropdownContent');
            dropdown.classList.toggle('show');
        }

        function closeFullscreenDropdown() {
            document.getElementById('fullscreenDropdownContent').classList.remove('show');
        }

        function selectComputerFullscreen() {
            closeFullscreenDropdown();
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function exitFullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            }
        }

        // Update exit fullscreen button visibility
        function updateExitFullscreenButton() {
            const button = document.getElementById('exitFullscreenButton');
            if (document.fullscreenElement) {
                button.classList.add('visible');
            } else {
                button.classList.remove('visible');
            }
        }

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', updateExitFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateExitFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateExitFullscreenButton);
        document.addEventListener('MSFullscreenChange', updateExitFullscreenButton);

        function selectProjectorFullscreen() {
            closeFullscreenDropdown();
            toggleProjectorFullscreen();
        }

        function toggleProjectorFullscreen() {
            if (projectorWindow && !projectorWindow.closed) {
                projectorWindow.close();
                projectorWindow = null;
                projectorMode = false;
                window.projectorMode = false;
                document.body.classList.remove('projector-mode');
                updateActiveProfile(); // Switch to computer profile
            } else {
                projectorWindow = window.open(
                    'projector.html',
                    'ProjectorView',
                    'width=1920,height=1080,toolbar=no,menubar=no,location=no'
                );

                if (projectorWindow) {
                    projectorMode = true;
                    window.projectorMode = true;
                    document.body.classList.add('projector-mode');
                    updateActiveProfile(); // Switch to projector profile

                    if (currentGame) {
                        setTimeout(() => {
                            broadcastGameStart('darts');
                            syncGameState();
                        }, 1000);
                    }
                } else {
                    alert('Could not open projector window. Please allow popups.');
                }
            }
        }

        function broadcastGameStart(gameType) {
            projectorChannel.postMessage({
                type: 'game_start',
                data: { gameType }
            });
        }

        function syncGameState() {
            const canvas = document.querySelector('#gameContent canvas');

            if (canvas) {
                try {
                    const dataUrl = canvas.toDataURL();
                    projectorChannel.postMessage({
                        type: 'game_update',
                        data: {
                            canvasData: dataUrl,
                            width: canvas.width,
                            height: canvas.height
                        }
                    });
                } catch (err) {
                    console.error('Error syncing canvas:', err);
                }
            }
        }

        function setupProjectorSync() {
            const gameContent = document.getElementById('gameContent');
            if (!gameContent) return;

            const observer = new MutationObserver(() => {
                if (projectorMode) syncGameState();
            });

            observer.observe(gameContent, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true
            });

            setInterval(() => {
                if (projectorMode) syncGameState();
            }, 100);

            // Monitor projector window status
            setInterval(() => {
                if (projectorWindow && projectorWindow.closed) {
                    console.log('üì° Detected projector window was closed');
                    projectorWindow = null;
                    projectorMode = false;
                    window.projectorMode = false;
                    document.body.classList.remove('projector-mode');
                    updateActiveProfile(); // Switch back to computer profile
                }
            }, 1000);
        }

        projectorChannel.onmessage = (event) => {
            if (event.data.type === 'projector_ready') {
                // PRIORITY: Handle wizard mode first (wizard takes precedence over game)
                if (wizardInProgress && wizardCurrentStep === 5) {
                    console.log('üì° Projector ready - sending CALIBRATION dartboard (wizard active)');
                    projectorChannel.postMessage({
                        type: 'game_start',
                        data: { gameType: 'calibration_wizard' }
                    });
                    drawWizardDartboard();
                }
                // Handle regular game (only if wizard is NOT active)
                else if (currentGame) {
                    console.log('üì° Projector ready - sending GAME dartboard');
                    broadcastGameStart('darts');
                    syncGameState();
                }
            } else if (event.data.type === 'projector_closing') {
                // Handle projector window closing independently
                console.log('üì° Projector window closed by user');
                projectorWindow = null;
                projectorMode = false;
                window.projectorMode = false;
                document.body.classList.remove('projector-mode');
                updateActiveProfile(); // Switch back to computer profile
            }
        };

        window.addEventListener('click', (event) => {
            const dropdown = document.getElementById('fullscreenDropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                closeFullscreenDropdown();
            }
        });

        window.addEventListener('load', () => {
            setupProjectorSync();
        });
    </script>

    <!-- Load game scripts -->
    <script src="steam-network-adapter.js"></script>
    <script src="darts_multiplayer.js"></script>
    <script src="./node_modules/three/build/three.module.js" type="module"></script>
    <script src="./node_modules/cannon-es/dist/cannon-es.js" type="module"></script>
    <script src="skeeball_putting.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Putting Green</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
            text-align: center;
            margin-bottom: 8px;
        }

        .button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        #controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            flex: 1;
            min-width: 70px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        #controls button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .stat-section h4 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            opacity: 0.8;
        }

        .stat-value {
            font-weight: bold;
            color: #4CAF50;
            font-size: 13px;
        }

        #playerIndicator {
            background: rgba(251, 191, 36, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            text-align: center;
            border: 1px solid #fbbf24;
        }

        #playerIndicator strong {
            font-size: 11px;
        }

        #currentPlayerName {
            font-size: 15px;
            margin-top: 3px;
            font-weight: bold;
        }

        .slider-container {
            margin: 8px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            color: #4CAF50;
            font-weight: bold;
            font-size: 11px;
        }

        .collapse-toggle {
            background: rgba(76, 175, 80, 0.3) !important;
            border: 2px solid #4CAF50 !important;
            padding: 6px 10px !important;
            margin-bottom: 8px;
            font-size: 12px !important;
            width: 100%;
            text-align: center;
        }

        .collapse-toggle:hover {
            background: rgba(76, 175, 80, 0.5) !important;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <div id="playerIndicator">
            <strong style="color: #fbbf24;">Current Player:</strong>
            <div id="currentPlayerName">Player 1</div>
        </div>

        <!-- Mode Toggle (Collapseable) -->
        <button class="collapse-toggle" onclick="toggleSection('modeSection')">
            üéÆ Game Modes <span id="modeSectionArrow">‚ñº</span>
        </button>
        <div id="modeSection" class="button-group" style="margin-bottom: 12px; flex-direction: column;">
            <button id="practiceModeBtn" onclick="setPracticeMode()" style="background: #4CAF50;">Practice</button>
            <button id="ladderModeBtn" onclick="setLadderMode()" style="background: rgba(76, 175, 80, 0.3);">Ladder</button>
            <button id="clockDrillBtn" onclick="setClockDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Clock Drill</button>
            <button id="gateDrillBtn" onclick="setGateDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Gate Drill</button>
            <button id="circleDrillBtn" onclick="setCircleDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Circle Drill</button>
            <button id="starDrillBtn" onclick="setStarDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Star Drill</button>
        </div>

        <!-- Ladder Stats (hidden by default) -->
        <div id="ladderStats" class="stat-section" style="display: none; background: rgba(251, 191, 36, 0.1); border: 1px solid #fbbf24;">
            <h4 style="color: #fbbf24; margin-bottom: 10px; text-align: center;">üéØ Ladder Progress</h4>
            <div class="stat-row">
                <span class="stat-label">Level:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderLevel">1 (2 ft)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes at Level:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderMakes">0/2</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Putts:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderTotalPutts">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Make %:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderMakePercent">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Personal Best:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderPersonalBest">2 ft</span>
            </div>
        </div>

        <!-- Clock Drill Stats (hidden by default) -->
        <div id="clockDrillStats" class="stat-section" style="display: none; background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6;">
            <h4 style="color: #3b82f6; margin-bottom: 10px; text-align: center;">üïê Clock Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockDistance">6 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockPosition">12 o'clock (1/12)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockMakes">0/12</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Streak:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockStreak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Success Rate:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockSuccessRate">0%</span>
            </div>
        </div>

        <!-- Gate Drill Stats (hidden by default) -->
        <div id="gateDrillStats" class="stat-section" style="display: none; background: rgba(168, 85, 247, 0.1); border: 1px solid #a855f7;">
            <h4 style="color: #a855f7; margin-bottom: 10px; text-align: center;">‚ö° Gate Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateDistance">10 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Gate Width:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateWidth">6 in</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Through Gate:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateThroughCount">0/0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateMakes">0/0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateAccuracy">0%</span>
            </div>
        </div>

        <!-- Circle Drill Stats (hidden by default) -->
        <div id="circleDrillStats" class="stat-section" style="display: none; background: rgba(236, 72, 153, 0.1); border: 1px solid #ec4899;">
            <h4 style="color: #ec4899; margin-bottom: 10px; text-align: center;">‚≠ï Circle Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Current Distance:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleCurrentDistance">3 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Attempts at Distance:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleAttempts">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleMakes">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Round Progress:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleProgress">1/4 distances</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Overall Success:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleSuccess">0%</span>
            </div>
        </div>

        <!-- Star Drill Stats (hidden by default) -->
        <div id="starDrillStats" class="stat-section" style="display: none; background: rgba(249, 115, 22, 0.1); border: 1px solid #f97316;">
            <h4 style="color: #f97316; margin-bottom: 10px; text-align: center;">‚≠ê Star Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #f97316;" id="starDistance">8 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position:</span>
                <span class="stat-value" style="color: #f97316;" id="starPosition">Point 1 (1/5)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #f97316;" id="starMakes">0/5</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Streak:</span>
                <span class="stat-value" style="color: #f97316;" id="starStreak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Success Rate:</span>
                <span class="stat-value" style="color: #f97316;" id="starSuccessRate">0%</span>
            </div>
        </div>

        <div class="stat-section" id="practiceControls">
            <button onclick="togglePracticeSettings()" style="width: 100%; background: transparent; border: none; color: #4CAF50; cursor: pointer; padding: 0; margin-bottom: 10px; text-align: left; font-size: 16px; font-weight: bold;">
                <span id="practiceSettingsToggle">‚ñº</span> Practice Settings
            </button>

            <div id="practiceSettingsContent">
                <div class="slider-container">
                    <label>
                        Distance: <span class="slider-value" id="distanceValue">20 ft</span>
                    </label>
                    <input type="range" id="distanceSlider" min="1" max="40" value="20" step="1">
                </div>

                <div class="slider-container">
                    <label>
                        Stimp (Green Speed): <span class="slider-value" id="stimpValue">10.0</span>
                    </label>
                    <input type="range" id="stimpSlider" min="7" max="14" value="10" step="0.5">
                </div>

                <div class="slider-container">
                    <label>
                        Break: <span class="slider-value" id="breakValue">0 (Straight)</span>
                    </label>
                    <input type="range" id="breakSlider" min="-10" max="10" value="0" step="1">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; opacity: 0.6; margin-top: 4px;">
                        <span>‚Üê Left</span>
                        <span>Straight</span>
                        <span>Right ‚Üí</span>
                    </div>
                    <div id="breakAngle" style="text-align: center; margin-top: 8px; font-size: 13px; color: #FFA500;">
                        Slope: 0.0¬∞
                    </div>
                </div>

                <div class="slider-container">
                    <label>
                        Elevation: <span class="slider-value" id="elevationValue">0 (Flat)</span>
                    </label>
                    <input type="range" id="elevationSlider" min="-10" max="10" value="0" step="1">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; opacity: 0.6; margin-top: 4px;">
                        <span>‚Üì Downhill</span>
                        <span>Flat</span>
                        <span>Uphill ‚Üë</span>
                    </div>
                    <div id="elevationAngle" style="text-align: center; margin-top: 8px; font-size: 13px; color: #FFA500;">
                        Grade: 0.0¬∞
                    </div>
                </div>
            </div>
        </div>

        <div class="stat-section" style="background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50;">
            <h4 style="color: #4CAF50; margin-bottom: 10px; text-align: center;">Distance to Hole</h4>
            <div style="text-align: center; font-size: 32px; font-weight: bold; color: #4CAF50;" id="distanceToHole">
                -- ft
            </div>
        </div>

        <div class="button-group">
            <button id="viewBtn">Change View</button>
            <button id="topoBtn" onclick="toggleTopoLines()">Toggle Grid</button>
            <button id="resetBtn" onclick="resetBall()">Reset Ball</button>
        </div>
        <div class="button-group">
            <button id="nextPlayerBtn" onclick="nextPlayer()" style="background: rgba(251, 191, 36, 0.3); border-color: #fbbf24;">Next Player ‚Üí</button>
        </div>

        <div id="scoreInfo" class="stat-section">
            <h4 style="color: #4CAF50; margin-bottom: 10px;">Score</h4>
            <div class="stat-row">
                <span class="stat-label">Putts:</span>
                <span class="stat-value" id="puttCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Holes:</span>
                <span class="stat-value" id="holesCompleted">0</span>
            </div>
        </div>

        <div id="shotInfo" class="stat-section">
            <h4 style="color: #4CAF50; margin-bottom: 10px;">Last Putt</h4>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="ballSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Backspin:</span>
                <span class="stat-value" id="backSpin">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Sidespin:</span>
                <span class="stat-value" id="sideSpin">--</span>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let ball, ballBody;
        let currentView = 'follow'; // 'overhead', 'behind', 'follow', 'side'
        let holes = [];
        let puttCount = 0;
        let holesCompleted = 0;
        let topoLines = null; // Topographical grid lines
        let showTopoLines = false;

        // Ladder Mode variables
        let isLadderMode = false;
        let ladderLevel = 1; // Start at level 1 (2ft)

        // Clock Drill variables
        let isClockDrillMode = false;
        let clockDistance = 6; // Default 6 feet
        let clockPosition = 0; // 0-11 for 12 positions around hole

        // Gate Drill variables
        let isGateDrillMode = false;
        let gateDistance = 10; // Default 10 feet
        let gateWidth = 6; // Width in inches (default 6 inches)
        let gateThroughCount = 0; // Successful putts through gate
        let gateAttempts = 0;
        let gateMakes = 0;
        let gateObjects = []; // Visual gate markers

        // Circle Drill variables
        let isCircleDrillMode = false;
        const CIRCLE_DISTANCES = [3, 6, 9, 12]; // ft
        let circleDistanceIndex = 0; // Current distance in sequence (0-3)
        let circleAttemptsAtDistance = 0;
        let circleMakesAtDistance = 0;
        let circleTotalAttempts = 0;
        let circleTotalMakes = 0;

        // Star Drill variables
        let isStarDrillMode = false;
        let starDistance = 8; // Default 8 feet
        let starPosition = 0; // 0-4 for 5 positions (72 degrees apart)
        let starMakes = 0;
        let starCurrentStreak = 0;
        let starAttempts = 0;
        let clockMakes = 0;
        let clockCurrentStreak = 0;
        let clockAttempts = 0;
        let ladderMakesAtLevel = 0; // Consecutive makes at current level
        let ladderTotalPutts = 0;
        let ladderTotalMakes = 0;
        let ladderPersonalBest = 2; // Best distance reached (in feet)
        const LADDER_DISTANCES = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]; // 2ft increments

        // Practice settings
        let currentDistance = 20; // feet
        let currentStimp = 10.0; // Stimpmeter rating
        let currentBreak = 0; // -10 (left) to +10 (right)
        let currentElevation = 0; // -10 (downhill) to +10 (uphill)

        // Ball physics
        const ballRadius = 0.021; // Golf ball radius in meters (42.67mm diameter)
        const gravity = 9.81;
        let friction = 0.15; // Rolling friction coefficient (will be calculated from Stimp)
        const restitution = 0.5; // Bounciness

        // Ball state
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let ballSpin = new THREE.Vector3(0, 0, 0);
        let isMoving = false;
        let lastTime = performance.now();
        let puttResultProcessed = false; // Track if result was processed for ladder mode

        // Players
        window.puttingPlayers = [];
        window.currentPlayerIndex = 0;

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 5);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -15;
            sunLight.shadow.camera.right = 15;
            sunLight.shadow.camera.top = 15;
            sunLight.shadow.camera.bottom = -15;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            createGreen();
            createBall();
            createHoles();

            // Update camera position now that ball exists
            updateCameraPosition();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('viewBtn').addEventListener('click', cycleView);

            // Setup sliders
            setupSliders();

            // Check for Electron IPC
            if (window.electronAPI) {
                console.log('‚úì Running in Electron - IPC available');
                setupElectronIPC();
            } else {
                console.log('‚ö† Not running in Electron - standalone mode');
            }
        }

        function createGreen() {
            // Main putting green (15 meters = ~49 ft to accommodate 40 ft putts)
            const greenGeometry = new THREE.CircleGeometry(15, 64);
            const greenTexture = createGrassTexture();
            const greenMaterial = new THREE.MeshLambertMaterial({
                map: greenTexture,
                side: THREE.DoubleSide
            });
            const green = new THREE.Mesh(greenGeometry, greenMaterial);
            green.rotation.x = -Math.PI / 2;
            green.receiveShadow = true;
            scene.add(green);

            // Fringe (darker grass around green)
            const fringeGeometry = new THREE.RingGeometry(15, 17, 64);
            const fringeTexture = createGrassTexture(0.3);
            const fringeMaterial = new THREE.MeshLambertMaterial({
                map: fringeTexture,
                side: THREE.DoubleSide
            });
            const fringe = new THREE.Mesh(fringeGeometry, fringeMaterial);
            fringe.rotation.x = -Math.PI / 2;
            fringe.position.y = -0.01;
            fringe.receiveShadow = true;
            scene.add(fringe);
        }

        function createGrassTexture(brightness = 0.5) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base green color
            const greenShade = Math.floor(100 + brightness * 60);
            ctx.fillStyle = `rgb(0, ${greenShade}, 0)`;
            ctx.fillRect(0, 0, 512, 512);

            // Add grass texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const shade = Math.floor(80 + Math.random() * 40 + brightness * 40);
                ctx.fillStyle = `rgba(0, ${shade}, 0, 0.3)`;
                ctx.fillRect(x, y, 2, 2);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.05,
                shininess: 100
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, ballRadius, -8); // Start near edge
            ball.castShadow = true;
            scene.add(ball);
        }

        function createHoles() {
            // Create hole at center of green
            createHole(0, 0, 1);
        }

        function createHole(x, z, number) {
            // Cup (hole)
            const cupGeometry = new THREE.CylinderGeometry(0.054, 0.054, 0.1, 32); // 108mm diameter
            const cupMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const cup = new THREE.Mesh(cupGeometry, cupMaterial);
            cup.position.set(x, -0.05, z);
            scene.add(cup);

            // Flag pole - moved to back edge of hole so it doesn't block putts
            const poleGeometry = new THREE.CylinderGeometry(0.005, 0.005, 2, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, 1, z + 0.054); // Moved to back edge of hole
            pole.castShadow = true;
            scene.add(pole);

            // Flag
            const flagGeometry = new THREE.PlaneGeometry(0.3, 0.2);
            const flagMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF0000,
                side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(x + 0.15, 1.8, z + 0.054); // Moved with pole
            scene.add(flag);

            holes.push({ x, z, number, radius: 0.054 });
        }

        function updateCameraPosition() {
            switch (currentView) {
                case 'overhead':
                    camera.position.set(0, 15, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'behind':
                    // Camera positioned behind the ball, looking toward the hole
                    // Calculate direction from ball to hole
                    const directionToHole = new THREE.Vector3(
                        -ball.position.x,
                        0,
                        -ball.position.z
                    ).normalize();

                    // Position camera behind ball (opposite direction to hole)
                    const behindDistance = 1.5; // meters behind the ball
                    const behindHeight = 0.3; // height above ground
                    camera.position.set(
                        ball.position.x - directionToHole.x * behindDistance,
                        ball.position.y + behindHeight,
                        ball.position.z - directionToHole.z * behindDistance
                    );

                    // Look at the hole (or slightly above the ball)
                    camera.lookAt(ball.position.x + directionToHole.x * 2, ball.position.y, ball.position.z + directionToHole.z * 2);
                    break;
                case 'follow':
                    // Follow camera stays behind the ball as it moves
                    if (isMoving && ballVelocity.length() > 0.01) {
                        // Get ball's direction of travel
                        const travelDirection = ballVelocity.clone().normalize();

                        // Position camera behind the ball's direction of travel
                        const followDistance = 1.0;
                        const followHeight = 0.4;
                        camera.position.set(
                            ball.position.x - travelDirection.x * followDistance,
                            ball.position.y + followHeight,
                            ball.position.z - travelDirection.z * followDistance
                        );

                        // Look slightly ahead of the ball
                        camera.lookAt(
                            ball.position.x + travelDirection.x * 0.5,
                            ball.position.y,
                            ball.position.z + travelDirection.z * 0.5
                        );
                    } else {
                        // If ball stopped, use same as behind view
                        const dirToHole = new THREE.Vector3(
                            -ball.position.x,
                            0,
                            -ball.position.z
                        ).normalize();
                        camera.position.set(
                            ball.position.x - dirToHole.x * 1.0,
                            ball.position.y + 0.4,
                            ball.position.z - dirToHole.z * 1.0
                        );
                        camera.lookAt(ball.position.x + dirToHole.x, ball.position.y, ball.position.z + dirToHole.z);
                    }
                    break;
                case 'side':
                    camera.position.set(8, 2, 0);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        }

        function cycleView() {
            const views = ['overhead', 'behind', 'follow', 'side'];
            const currentIndex = views.indexOf(currentView);
            currentView = views[(currentIndex + 1) % views.length];
            updateCameraPosition();
            showNotification(`Camera: ${currentView.charAt(0).toUpperCase() + currentView.slice(1)}`);
        }

        function showNotification(message) {
            const existing = document.getElementById('cameraNotification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'cameraNotification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updatePhysics(deltaTime) {
            if (!isMoving) return;

            // Apply friction
            const speed = ballVelocity.length();
            if (speed > 0.001) {
                const frictionForce = friction * gravity * deltaTime;
                const frictionDecel = Math.min(frictionForce / speed, 1);
                ballVelocity.multiplyScalar(1 - frictionDecel);

                // Apply elevation (uphill/downhill)
                // Uphill: slows ball down, Downhill: speeds ball up
                if (currentElevation !== 0) {
                    const elevationAngle = currentElevation * 0.5 * Math.PI / 180; // Convert to radians
                    const gradeForce = gravity * Math.sin(elevationAngle);

                    // Apply force in Z direction (along the line to hole)
                    // Ball rolls toward hole (negative Z direction)
                    // Uphill (positive elevation) = opposing force (positive Z) = slows down
                    // Downhill (negative elevation) = assisting force (negative Z) = speeds up
                    ballVelocity.z -= gradeForce * deltaTime; // REVERSED: subtract to get correct direction
                }

                // Apply break (simulates slope)
                // Break force is perpendicular to velocity, scaled by speed and break amount
                // The slower the ball, the more it breaks (realistic putting physics)
                if (currentBreak !== 0) {
                    // Calculate break force based on green slope
                    // Break scale: each point = ~0.5 degrees of slope
                    const breakAngle = currentBreak * 0.5 * Math.PI / 180; // Convert to radians
                    const slopeForce = gravity * Math.sin(breakAngle);

                    // Apply break force in X direction (positive = right, negative = left)
                    // Break effect increases as ball slows down (realistic)
                    const speedFactor = Math.max(0.2, 1 - (speed / 5)); // More break when slower
                    const breakForce = slopeForce * speedFactor * deltaTime;

                    ballVelocity.x += breakForce;
                }

                // Apply spin effect (Magnus force - simplified)
                if (ballSpin.length() > 0.1) {
                    const spinEffect = new THREE.Vector3()
                        .crossVectors(ballSpin, ballVelocity)
                        .multiplyScalar(0.0001 * deltaTime);
                    ballVelocity.add(spinEffect);

                    // Spin decay
                    ballSpin.multiplyScalar(1 - deltaTime * 2);
                }

                // Update position
                ball.position.add(ballVelocity.clone().multiplyScalar(deltaTime));

                // Check gate post collisions (if in gate drill mode)
                if (isGateDrillMode && gateObjects.length > 0) {
                    checkGatePostCollisions();
                }

                // Keep ball on green (simple collision)
                const distFromCenter = Math.sqrt(ball.position.x ** 2 + ball.position.z ** 2);
                if (distFromCenter > 14.8) {
                    // Bounce off edge
                    const normal = new THREE.Vector3(ball.position.x, 0, ball.position.z).normalize();
                    ballVelocity.reflect(normal).multiplyScalar(restitution);
                    ball.position.x = normal.x * 14.8;
                    ball.position.z = normal.z * 14.8;
                }

                // Check for hole
                checkHoleCollision();

                // Update distance to hole display
                updateDistanceToHole();

                // Re-check speed after all forces applied (prevents infinite roll with break)
                const finalSpeed = ballVelocity.length();
                if (finalSpeed < 0.001) {
                    ballVelocity.set(0, 0, 0);
                    ballSpin.set(0, 0, 0);
                    isMoving = false;

                    // Check for ladder mode miss
                    if (isLadderMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            ladderPuttMissed();
                            resetBall();
                        }, 1500);
                    }

                    // Check for clock drill miss
                    if (isClockDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            clockDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for gate drill miss
                    if (isGateDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            gateDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for circle drill miss
                    if (isCircleDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            circleDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for star drill miss
                    if (isStarDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            starDrillPuttMissed();
                        }, 1500);
                    }
                }
            } else {
                // Ball stopped
                ballVelocity.set(0, 0, 0);
                ballSpin.set(0, 0, 0);
                isMoving = false;
                updateDistanceToHole();
            }
        }

        function updateDistanceToHole() {
            // Calculate distance from ball to hole (hole is at origin 0,0,0)
            const distanceMeters = Math.sqrt(ball.position.x ** 2 + ball.position.z ** 2);
            const distanceFeet = distanceMeters / 0.3048;

            const displayElement = document.getElementById('distanceToHole');
            if (distanceFeet < 0.5) {
                displayElement.textContent = '< 6"';
                displayElement.style.color = '#FFD700'; // Gold when very close
            } else if (distanceFeet < 1) {
                displayElement.textContent = (distanceFeet * 12).toFixed(1) + '"';
                displayElement.style.color = '#4CAF50';
            } else {
                displayElement.textContent = distanceFeet.toFixed(1) + ' ft';
                displayElement.style.color = '#4CAF50';
            }
        }

        function checkHoleCollision() {
            holes.forEach(hole => {
                const dx = ball.position.x - hole.x;
                const dz = ball.position.z - hole.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                // Increased detection radius and velocity threshold for easier holing
                // Ball just needs to be within hole area and moving at putter speed
                if (dist < hole.radius + ballRadius && ballVelocity.length() < 2.0) {
                    // Ball in hole!
                    ballVelocity.set(0, 0, 0);
                    isMoving = false;
                    puttResultProcessed = true; // Mark as processed

                    if (isLadderMode) {
                        // Ladder mode - track progress
                        ladderPuttMade();
                    } else if (isClockDrillMode) {
                        // Clock drill - track progress
                        clockDrillPuttMade();
                    } else if (isGateDrillMode) {
                        // Gate drill - track progress
                        gateDrillPuttMade();
                    } else if (isCircleDrillMode) {
                        // Circle drill - track progress
                        circleDrillPuttMade();
                    } else if (isStarDrillMode) {
                        // Star drill - track progress
                        starDrillPuttMade();
                    } else {
                        // Practice mode - normal behavior
                        holesCompleted++;
                        document.getElementById('holesCompleted').textContent = holesCompleted;
                        showNotification(`Hole ${hole.number} Complete! üèåÔ∏è`);
                    }

                    // Reset ball after delay
                    setTimeout(() => {
                        resetBall();
                    }, 2000);
                }
            });
        }

        function setupSliders() {
            const distanceSlider = document.getElementById('distanceSlider');
            const distanceValue = document.getElementById('distanceValue');
            const stimpSlider = document.getElementById('stimpSlider');
            const stimpValue = document.getElementById('stimpValue');
            const breakSlider = document.getElementById('breakSlider');
            const breakValue = document.getElementById('breakValue');
            const elevationSlider = document.getElementById('elevationSlider');
            const elevationValue = document.getElementById('elevationValue');

            // Distance slider
            distanceSlider.addEventListener('input', (e) => {
                currentDistance = parseInt(e.target.value);
                distanceValue.textContent = currentDistance + ' ft';

                if (isGateDrillMode) {
                    gateDistance = currentDistance;
                    createGateMarkers(); // Recreate gate at new distance
                    updateGateDrillDisplay();
                } else if (isClockDrillMode) {
                    clockDistance = currentDistance;
                    positionBallForClockDrill();
                } else if (isStarDrillMode) {
                    starDistance = currentDistance;
                    positionBallForStarDrill();
                }

                updateBallPosition();
            });

            // Stimp slider
            stimpSlider.addEventListener('input', (e) => {
                currentStimp = parseFloat(e.target.value);
                stimpValue.textContent = currentStimp.toFixed(1);
                updateFrictionFromStimp();
            });

            // Break slider
            breakSlider.addEventListener('input', (e) => {
                currentBreak = parseInt(e.target.value);
                updateBreakDisplay();
                if (showTopoLines) createTopoLines(); // Update lines if visible
            });

            // Elevation slider
            elevationSlider.addEventListener('input', (e) => {
                currentElevation = parseInt(e.target.value);
                updateElevationDisplay();
                if (showTopoLines) createTopoLines(); // Update lines if visible
            });

            // Initialize
            updateBallPosition();
            updateFrictionFromStimp();
            updateBreakDisplay();
            updateElevationDisplay();
        }

        function updateBreakDisplay() {
            const breakValue = document.getElementById('breakValue');
            const breakAngle = document.getElementById('breakAngle');

            // Calculate slope angle (each break point = ~0.5 degrees)
            const slopeAngleDegrees = currentBreak * 0.5;

            if (currentBreak === 0) {
                breakValue.textContent = '0 (Straight)';
                breakAngle.textContent = 'Slope: 0.0¬∞';
                breakAngle.style.color = '#4CAF50';
            } else if (currentBreak < 0) {
                breakValue.textContent = `${currentBreak} (‚Üê Left)`;
                breakAngle.textContent = `Slope: ${Math.abs(slopeAngleDegrees).toFixed(1)}¬∞ Left`;
                breakAngle.style.color = '#FFA500';
            } else {
                breakValue.textContent = `${currentBreak} (Right ‚Üí)`;
                breakAngle.textContent = `Slope: ${slopeAngleDegrees.toFixed(1)}¬∞ Right`;
                breakAngle.style.color = '#FFA500';
            }
            console.log(`Break set to: ${currentBreak} (${currentBreak < 0 ? 'Left' : currentBreak > 0 ? 'Right' : 'Straight'}), Slope: ${slopeAngleDegrees.toFixed(1)}¬∞`);
        }

        function updateElevationDisplay() {
            const elevationValue = document.getElementById('elevationValue');
            const elevationAngle = document.getElementById('elevationAngle');

            // Calculate grade angle (each elevation point = ~0.5 degrees)
            const gradeAngleDegrees = currentElevation * 0.5;

            if (currentElevation === 0) {
                elevationValue.textContent = '0 (Flat)';
                elevationAngle.textContent = 'Grade: 0.0¬∞';
                elevationAngle.style.color = '#4CAF50';
            } else if (currentElevation < 0) {
                elevationValue.textContent = `${currentElevation} (‚Üì Downhill)`;
                elevationAngle.textContent = `Grade: ${Math.abs(gradeAngleDegrees).toFixed(1)}¬∞ Down`;
                elevationAngle.style.color = '#00BFFF'; // Light blue for downhill
            } else {
                elevationValue.textContent = `${currentElevation} (Uphill ‚Üë)`;
                elevationAngle.textContent = `Grade: ${gradeAngleDegrees.toFixed(1)}¬∞ Up`;
                elevationAngle.style.color = '#FF6347'; // Red for uphill
            }
            console.log(`Elevation set to: ${currentElevation} (${currentElevation < 0 ? 'Downhill' : currentElevation > 0 ? 'Uphill' : 'Flat'}), Grade: ${gradeAngleDegrees.toFixed(1)}¬∞`);
        }

        function updateFrictionFromStimp() {
            // Based on Stanford physics paper (Kolkowitz 2007)
            // Deceleration: a = -(5/7) √ó œÅ_g √ó g
            // Stimpmeter releases ball at 1.83 m/s
            // Fast green (Stimp 12): rolls 3.66m ‚Üí œÅ_g = 0.065
            // Slow green (Stimp 4): rolls 1.22m ‚Üí œÅ_g = 0.196

            // Linear interpolation between slow and fast
            // Stimp range: 7 (slow) to 14 (fast)
            const stimpRange = 14 - 7;
            const rhoGFast = 0.065;
            const rhoGSlow = 0.196;
            const t = (currentStimp - 7) / stimpRange; // 0 = slow, 1 = fast
            const rhoG = rhoGSlow - t * (rhoGSlow - rhoGFast); // Interpolate

            // Deceleration = (5/7) √ó œÅ_g √ó g
            const deceleration = (5/7) * rhoG * gravity;

            // For our physics update: friction coefficient such that
            // frictionForce = friction √ó gravity √ó deltaTime gives correct deceleration
            friction = rhoG * (5/7);

            console.log(`Stimp ${currentStimp} ‚Üí œÅ_g: ${rhoG.toFixed(4)}, Decel: ${deceleration.toFixed(3)} m/s¬≤, Friction: ${friction.toFixed(4)}`);
        }

        // Listen for Stimp changes from Electron menu
        if (window.electronAPI) {
            // Get initial Stimp from Electron on load
            window.electronAPI.getGreenStimp().then(stimp => {
                currentStimp = stimp;
                document.getElementById('stimpSlider').value = stimp;
                document.getElementById('stimpValue').textContent = stimp.toFixed(1);
                updateFrictionFromStimp();
                console.log(`Loaded Stimp from Electron settings: ${stimp} ft`);
            }).catch(() => {
                console.log('Not running in Electron, using default Stimp: 10 ft');
            });

            // Listen for Stimp changes
            window.electronAPI.onStimpChanged((stimp) => {
                currentStimp = stimp;
                document.getElementById('stimpSlider').value = stimp;
                document.getElementById('stimpValue').textContent = stimp.toFixed(1);
                updateFrictionFromStimp();
                console.log(`‚öôÔ∏è Stimp updated from menu: ${stimp} ft`);
            });
        }

        function updateBallPosition() {
            // Convert feet to meters
            const distanceMeters = currentDistance * 0.3048;

            // Position ball at specified distance from hole
            // Hole is at (0, 0), ball positioned south (negative Z)
            ball.position.set(0, ballRadius, -distanceMeters);

            // Reset physics
            ballVelocity.set(0, 0, 0);
            ballSpin.set(0, 0, 0);
            isMoving = false;

            // Update distance display
            updateDistanceToHole();

            console.log(`Ball positioned ${currentDistance} ft (${distanceMeters.toFixed(2)}m) from hole`);
        }

        function resetBall() {
            puttResultProcessed = false; // Reset for new putt
            updateBallPosition();
        }

        // Ladder Mode Functions
        function setPracticeMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = '#4CAF50';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'block'; // Show score in practice mode
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;
            resetBall();
        }

        function setLadderMode() {
            isLadderMode = true;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = '#fbbf24';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'block';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none'; // Hide score in ladder mode (duplicated in ladder stats)
            document.getElementById('practiceControls').style.display = 'block'; // Keep sliders visible but distance disabled
            document.getElementById('distanceSlider').disabled = true;

            // Reset ladder stats
            ladderLevel = 1;
            ladderMakesAtLevel = 0;
            ladderTotalPutts = 0;
            ladderTotalMakes = 0;
            ladderPersonalBest = LADDER_DISTANCES[0];

            // Set initial distance
            currentDistance = LADDER_DISTANCES[ladderLevel - 1];
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateLadderDisplay();
            resetBall();
            showNotification('üéØ Ladder Mode Started! Make 2 putts at each distance.');
        }

        function updateLadderDisplay() {
            const distance = LADDER_DISTANCES[ladderLevel - 1];
            document.getElementById('ladderLevel').textContent = `${ladderLevel} (${distance} ft)`;
            document.getElementById('ladderMakes').textContent = `${ladderMakesAtLevel}/2`;
            document.getElementById('ladderTotalPutts').textContent = ladderTotalPutts;

            const makePercent = ladderTotalPutts > 0 ? Math.round((ladderTotalMakes / ladderTotalPutts) * 100) : 0;
            document.getElementById('ladderMakePercent').textContent = makePercent + '%';
            document.getElementById('ladderPersonalBest').textContent = ladderPersonalBest + ' ft';
        }

        function ladderPuttMade() {
            ladderTotalPutts++;
            ladderTotalMakes++;
            ladderMakesAtLevel++;

            const currentDist = LADDER_DISTANCES[ladderLevel - 1];

            // Update personal best
            if (currentDist > ladderPersonalBest) {
                ladderPersonalBest = currentDist;
                showNotification(`üèÜ New Personal Best: ${ladderPersonalBest} ft!`);
            }

            if (ladderMakesAtLevel >= 2) {
                // Advance to next level
                if (ladderLevel < LADDER_DISTANCES.length) {
                    ladderLevel++;
                    ladderMakesAtLevel = 0;
                    currentDistance = LADDER_DISTANCES[ladderLevel - 1];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                    showNotification(`‚¨ÜÔ∏è Level Up! Now at ${currentDistance} ft`);
                } else {
                    showNotification('üéâ You completed the ladder! Congratulations!');
                }
            } else {
                showNotification(`‚úÖ Made! ${ladderMakesAtLevel}/2 at ${currentDist} ft`);
            }

            updateLadderDisplay();
        }

        function ladderPuttMissed() {
            ladderTotalPutts++;

            // Drop back one level (but not below level 1)
            if (ladderLevel > 1) {
                ladderLevel--;
                ladderMakesAtLevel = 0;
                currentDistance = LADDER_DISTANCES[ladderLevel - 1];
                document.getElementById('distanceSlider').value = currentDistance;
                document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                showNotification(`‚¨áÔ∏è Miss! Dropped to ${currentDistance} ft`);
            } else {
                // Already at level 1, just reset makes
                ladderMakesAtLevel = 0;
                showNotification(`‚ùå Miss! Starting over at ${LADDER_DISTANCES[0]} ft`);
            }

            updateLadderDisplay();
        }

        // Clock Drill Functions
        function setClockDrillMode() {
            isLadderMode = false;
            isClockDrillMode = true;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = '#3b82f6';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'block';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false; // Allow distance selection

            // Reset clock drill stats
            clockPosition = 0;
            clockMakes = 0;
            clockCurrentStreak = 0;
            clockAttempts = 0;

            // Set distance (can be adjusted)
            currentDistance = clockDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateClockDrillDisplay();
            positionBallForClockDrill();
            showNotification('üïê Clock Drill Started! Complete 12 putts around the hole.');
        }

        function positionBallForClockDrill() {
            // Position ball around the hole in a circle
            // 12 positions like clock: 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 o'clock
            const angleRadians = (clockPosition * 30) * (Math.PI / 180); // 30 degrees per position
            const distanceMeters = currentDistance * 0.3048; // Convert feet to meters

            // Calculate offset from hole (hole is at 0, 0, 0)
            const xOffset = Math.sin(angleRadians) * distanceMeters;
            const zOffset = Math.cos(angleRadians) * distanceMeters;

            // Position ball
            ball.position.set(xOffset, ballRadius, zOffset);
            if (ballBody) {
                ballBody.position.set(xOffset, ballRadius, zOffset);
                ballBody.quaternion.set(0, 0, 0, 1);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }

            console.log(`Clock position ${clockPosition + 1}/12 (${getClockLabel(clockPosition)}): x=${xOffset.toFixed(2)}m, z=${zOffset.toFixed(2)}m`);
        }

        function getClockLabel(position) {
            const labels = ['12', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'];
            return labels[position] + " o'clock";
        }

        function updateClockDrillDisplay() {
            document.getElementById('clockDistance').textContent = currentDistance + ' ft';
            document.getElementById('clockPosition').textContent = `${getClockLabel(clockPosition)} (${clockPosition + 1}/12)`;
            document.getElementById('clockMakes').textContent = `${clockMakes}/12`;
            document.getElementById('clockStreak').textContent = clockCurrentStreak;

            const successRate = clockAttempts > 0 ? Math.round((clockMakes / clockAttempts) * 100) : 0;
            document.getElementById('clockSuccessRate').textContent = successRate + '%';
        }

        function clockDrillPuttMade() {
            clockMakes++;
            clockCurrentStreak++;
            clockAttempts++;

            if (clockPosition < 11) {
                // Move to next position
                clockPosition++;
                showNotification(`‚úÖ Make! Moving to ${getClockLabel(clockPosition)}`);
                updateClockDrillDisplay();
                positionBallForClockDrill();
            } else {
                // Completed all 12 positions!
                updateClockDrillDisplay();
                showNotification(`üéâ Clock Drill Complete! ${clockMakes}/12 makes (${Math.round((clockMakes/12)*100)}%)`);

                // Reset for another round
                setTimeout(() => {
                    clockPosition = 0;
                    clockMakes = 0;
                    clockCurrentStreak = 0;
                    clockAttempts = 0;
                    updateClockDrillDisplay();
                    positionBallForClockDrill();
                    showNotification('üïê Starting new round!');
                }, 3000);
            }
        }

        function clockDrillPuttMissed() {
            clockCurrentStreak = 0;
            clockAttempts++;

            if (clockPosition < 11) {
                // Move to next position anyway
                clockPosition++;
                showNotification(`‚ùå Miss. Moving to ${getClockLabel(clockPosition)}`);
                updateClockDrillDisplay();
                positionBallForClockDrill();
            } else {
                // Completed all 12 positions
                updateClockDrillDisplay();
                showNotification(`üïê Clock Drill Complete! ${clockMakes}/12 makes (${Math.round((clockMakes/12)*100)}%)`);

                // Reset for another round
                setTimeout(() => {
                    clockPosition = 0;
                    clockMakes = 0;
                    clockCurrentStreak = 0;
                    clockAttempts = 0;
                    updateClockDrillDisplay();
                    positionBallForClockDrill();
                    showNotification('üïê Starting new round!');
                }, 3000);
            }
        }

        // Gate Drill Functions
        function setGateDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = true;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = '#a855f7';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'block';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;

            // Reset gate drill stats
            gateThroughCount = 0;
            gateAttempts = 0;
            gateMakes = 0;

            // Set distance
            currentDistance = gateDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateGateDrillDisplay();
            createGateMarkers();
            resetBall();
            showNotification('‚ö° Gate Drill Started! Putt through the alignment gates.');
        }

        function createGateMarkers() {
            removeGateMarkers();

            const gateWidthMeters = (gateWidth / 12) * 0.3048; // Convert inches to meters
            const halfWidth = gateWidthMeters / 2;
            const distanceMeters = currentDistance * 0.3048;
            const gatePositionZ = -distanceMeters / 2; // Place gate halfway to hole

            // Create left post
            const postGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 8);
            const postMaterial = new THREE.MeshStandardMaterial({
                color: 0xa855f7,
                emissive: 0xa855f7,
                emissiveIntensity: 0.5
            });

            const leftPost = new THREE.Mesh(postGeometry, postMaterial);
            leftPost.position.set(-halfWidth, 0.1, gatePositionZ);
            scene.add(leftPost);
            gateObjects.push(leftPost);

            // Create right post
            const rightPost = new THREE.Mesh(postGeometry, postMaterial);
            rightPost.position.set(halfWidth, 0.1, gatePositionZ);
            scene.add(rightPost);
            gateObjects.push(rightPost);

            // Create connecting line between posts
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-halfWidth, 0.15, gatePositionZ),
                new THREE.Vector3(halfWidth, 0.15, gatePositionZ)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xa855f7, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            gateObjects.push(line);
        }

        function removeGateMarkers() {
            gateObjects.forEach(obj => scene.remove(obj));
            gateObjects = [];
        }

        function checkGatePostCollisions() {
            // Only check against the actual posts (first 2 objects), not the line
            if (gateObjects.length < 2) return;

            const leftPost = gateObjects[0];
            const rightPost = gateObjects[1];
            const postRadius = 0.01; // Same as post geometry radius
            const ballCollisionRadius = ballRadius + postRadius;

            // Check collision with left post
            const dxLeft = ball.position.x - leftPost.position.x;
            const dzLeft = ball.position.z - leftPost.position.z;
            const distLeft = Math.sqrt(dxLeft * dxLeft + dzLeft * dzLeft);

            if (distLeft < ballCollisionRadius) {
                // Collision with left post - bounce off
                const normal = new THREE.Vector3(dxLeft, 0, dzLeft).normalize();
                ballVelocity.reflect(normal).multiplyScalar(0.8); // Some energy loss

                // Push ball away from post to prevent sticking
                ball.position.x = leftPost.position.x + normal.x * ballCollisionRadius;
                ball.position.z = leftPost.position.z + normal.z * ballCollisionRadius;
            }

            // Check collision with right post
            const dxRight = ball.position.x - rightPost.position.x;
            const dzRight = ball.position.z - rightPost.position.z;
            const distRight = Math.sqrt(dxRight * dxRight + dzRight * dzRight);

            if (distRight < ballCollisionRadius) {
                // Collision with right post - bounce off
                const normal = new THREE.Vector3(dxRight, 0, dzRight).normalize();
                ballVelocity.reflect(normal).multiplyScalar(0.8); // Some energy loss

                // Push ball away from post to prevent sticking
                ball.position.x = rightPost.position.x + normal.x * ballCollisionRadius;
                ball.position.z = rightPost.position.z + normal.z * ballCollisionRadius;
            }
        }

        function updateGateDrillDisplay() {
            document.getElementById('gateDistance').textContent = currentDistance + ' ft';
            document.getElementById('gateWidth').textContent = gateWidth + ' in';
            document.getElementById('gateThroughCount').textContent = gateThroughCount + '/' + gateAttempts;
            document.getElementById('gateMakes').textContent = gateMakes + '/' + gateAttempts;

            const accuracy = gateAttempts > 0 ? Math.round((gateThroughCount / gateAttempts) * 100) : 0;
            document.getElementById('gateAccuracy').textContent = accuracy + '%';
        }

        function checkBallThroughGate() {
            if (!isGateDrillMode) return true; // Not in gate mode, always return true

            const gateWidthMeters = (gateWidth / 12) * 0.3048;
            const halfWidth = gateWidthMeters / 2;
            const distanceMeters = currentDistance * 0.3048;
            const gatePositionZ = -distanceMeters / 2;

            // Check if ball crossed the gate line (Z position)
            const tolerance = 0.1; // 10cm tolerance for gate detection
            const ballZ = ball.position.z;

            // If ball is near gate Z position, check X position
            if (Math.abs(ballZ - gatePositionZ) < tolerance) {
                const ballX = ball.position.x;
                return Math.abs(ballX) < halfWidth; // True if ball is between posts
            }

            return true; // Default to true if not at gate yet
        }

        function gateDrillPuttMade() {
            gateAttempts++;
            gateMakes++;

            // Check if ball went through gate (simple check based on final position)
            const throughGate = checkBallThroughGate();
            if (throughGate) {
                gateThroughCount++;
                showNotification('‚ö° Made through gate! Great accuracy!');
            } else {
                showNotification('‚úÖ Made putt (missed gate)');
            }

            updateGateDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        function gateDrillPuttMissed() {
            gateAttempts++;

            const throughGate = checkBallThroughGate();
            if (throughGate) {
                gateThroughCount++;
                showNotification('‚ö° Good line (through gate, missed hole)');
            } else {
                showNotification('‚ùå Missed (off line)');
            }

            updateGateDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        // Circle Drill Functions
        function setCircleDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = true;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = '#ec4899';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'block';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = true; // Distance controlled by drill

            // Reset circle drill stats
            circleDistanceIndex = 0;
            circleAttemptsAtDistance = 0;
            circleMakesAtDistance = 0;
            circleTotalAttempts = 0;
            circleTotalMakes = 0;

            // Set initial distance
            currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateCircleDrillDisplay();
            resetBall();
            showNotification('‚≠ï Circle Drill Started! 10 putts at each distance: 3ft, 6ft, 9ft, 12ft');
        }

        function updateCircleDrillDisplay() {
            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            document.getElementById('circleCurrentDistance').textContent = currentDist + ' ft';
            document.getElementById('circleAttempts').textContent = circleAttemptsAtDistance + '/10';
            document.getElementById('circleMakes').textContent = circleMakesAtDistance + '/10';
            document.getElementById('circleProgress').textContent = (circleDistanceIndex + 1) + '/4 distances';

            const overallSuccess = circleTotalAttempts > 0 ? Math.round((circleTotalMakes / circleTotalAttempts) * 100) : 0;
            document.getElementById('circleSuccess').textContent = overallSuccess + '%';
        }

        function circleDrillPuttMade() {
            circleAttemptsAtDistance++;
            circleMakesAtDistance++;
            circleTotalAttempts++;
            circleTotalMakes++;

            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            showNotification(`‚úÖ Made! ${circleMakesAtDistance}/10 at ${currentDist} ft`);

            if (circleAttemptsAtDistance >= 10) {
                // Move to next distance
                if (circleDistanceIndex < CIRCLE_DISTANCES.length - 1) {
                    circleDistanceIndex++;
                    circleAttemptsAtDistance = 0;
                    circleMakesAtDistance = 0;

                    currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';

                    setTimeout(() => {
                        showNotification(`‚≠ï Moving to ${currentDistance} ft`);
                    }, 2000);
                } else {
                    // Completed all distances
                    const totalSuccess = Math.round((circleTotalMakes / circleTotalAttempts) * 100);
                    setTimeout(() => {
                        showNotification(`üéâ Circle Drill Complete! ${circleTotalMakes}/40 makes (${totalSuccess}%)`);
                    }, 2000);

                    // Reset for another round
                    setTimeout(() => {
                        circleDistanceIndex = 0;
                        circleAttemptsAtDistance = 0;
                        circleMakesAtDistance = 0;
                        circleTotalAttempts = 0;
                        circleTotalMakes = 0;
                        currentDistance = CIRCLE_DISTANCES[0];
                        document.getElementById('distanceSlider').value = currentDistance;
                        document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                        updateCircleDrillDisplay();
                        showNotification('‚≠ï Starting new round!');
                    }, 5000);
                }
            }

            updateCircleDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        function circleDrillPuttMissed() {
            circleAttemptsAtDistance++;
            circleTotalAttempts++;

            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            showNotification(`‚ùå Miss. ${circleMakesAtDistance}/10 at ${currentDist} ft`);

            if (circleAttemptsAtDistance >= 10) {
                // Move to next distance
                if (circleDistanceIndex < CIRCLE_DISTANCES.length - 1) {
                    circleDistanceIndex++;
                    circleAttemptsAtDistance = 0;
                    circleMakesAtDistance = 0;

                    currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';

                    setTimeout(() => {
                        showNotification(`‚≠ï Moving to ${currentDistance} ft`);
                    }, 2000);
                } else {
                    // Completed all distances
                    const totalSuccess = Math.round((circleTotalMakes / circleTotalAttempts) * 100);
                    setTimeout(() => {
                        showNotification(`üéâ Circle Drill Complete! ${circleTotalMakes}/40 makes (${totalSuccess}%)`);
                    }, 2000);

                    // Reset for another round
                    setTimeout(() => {
                        circleDistanceIndex = 0;
                        circleAttemptsAtDistance = 0;
                        circleMakesAtDistance = 0;
                        circleTotalAttempts = 0;
                        circleTotalMakes = 0;
                        currentDistance = CIRCLE_DISTANCES[0];
                        document.getElementById('distanceSlider').value = currentDistance;
                        document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                        updateCircleDrillDisplay();
                        showNotification('‚≠ï Starting new round!');
                    }, 5000);
                }
            }

            updateCircleDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        // Star Drill Functions
        function setStarDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = true;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = '#f97316';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'block';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;

            // Reset star drill stats
            starPosition = 0;
            starMakes = 0;
            starCurrentStreak = 0;
            starAttempts = 0;

            // Set distance
            currentDistance = starDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateStarDrillDisplay();
            positionBallForStarDrill();
            showNotification('‚≠ê Star Drill Started! 5 putts from different angles.');
        }

        function positionBallForStarDrill() {
            // Position ball at 5 positions like a star (72 degrees apart)
            const angleRadians = (starPosition * 72) * (Math.PI / 180); // 72 degrees per position
            const distanceMeters = currentDistance * 0.3048; // Convert feet to meters

            // Calculate offset from hole (hole is at 0, 0, 0)
            const xOffset = Math.sin(angleRadians) * distanceMeters;
            const zOffset = Math.cos(angleRadians) * distanceMeters;

            // Position ball
            ball.position.set(xOffset, ballRadius, zOffset);
            if (ballBody) {
                ballBody.position.set(xOffset, ballRadius, zOffset);
                ballBody.quaternion.set(0, 0, 0, 1);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }
        }

        function updateStarDrillDisplay() {
            document.getElementById('starDistance').textContent = currentDistance + ' ft';
            document.getElementById('starPosition').textContent = `Point ${starPosition + 1} (${starPosition + 1}/5)`;
            document.getElementById('starMakes').textContent = starMakes + '/5';
            document.getElementById('starStreak').textContent = starCurrentStreak;

            const successRate = starAttempts > 0 ? Math.round((starMakes / starAttempts) * 100) : 0;
            document.getElementById('starSuccessRate').textContent = successRate + '%';
        }

        function starDrillPuttMade() {
            starAttempts++;
            starMakes++;
            starCurrentStreak++;

            showNotification(`‚≠ê Made! Streak: ${starCurrentStreak}`);

            // Move to next position
            starPosition++;
            if (starPosition >= 5) {
                // Completed all 5 positions
                updateStarDrillDisplay();
                showNotification(`üéâ Star Drill Complete! ${starMakes}/5 makes`);

                // Reset for another round
                setTimeout(() => {
                    starPosition = 0;
                    starMakes = 0;
                    starCurrentStreak = 0;
                    starAttempts = 0;
                    updateStarDrillDisplay();
                    positionBallForStarDrill();
                    showNotification('‚≠ê Starting new round!');
                }, 3000);
            } else {
                updateStarDrillDisplay();
                positionBallForStarDrill();
            }
        }

        function starDrillPuttMissed() {
            starAttempts++;
            starCurrentStreak = 0; // Reset streak on miss

            showNotification('‚ùå Miss. Streak reset.');

            // Move to next position
            starPosition++;
            if (starPosition >= 5) {
                // Completed all 5 positions
                updateStarDrillDisplay();
                showNotification(`‚≠ê Star Drill Complete! ${starMakes}/5 makes`);

                // Reset for another round
                setTimeout(() => {
                    starPosition = 0;
                    starMakes = 0;
                    starCurrentStreak = 0;
                    starAttempts = 0;
                    updateStarDrillDisplay();
                    positionBallForStarDrill();
                    showNotification('‚≠ê Starting new round!');
                }, 3000);
            } else {
                updateStarDrillDisplay();
                positionBallForStarDrill();
            }
        }

        function toggleTopoLines() {
            showTopoLines = !showTopoLines;

            if (showTopoLines) {
                createTopoLines();
                console.log('Topographical lines enabled');
            } else {
                if (topoLines) {
                    scene.remove(topoLines);
                    topoLines = null;
                }
                console.log('Topographical lines disabled');
            }
        }

        function togglePracticeSettings() {
            const content = document.getElementById('practiceSettingsContent');
            const toggle = document.getElementById('practiceSettingsToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const arrow = document.getElementById(sectionId + 'Arrow');

            if (section.style.display === 'none') {
                section.style.display = 'flex';
                arrow.textContent = '‚ñº';
            } else {
                section.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        function createTopoLines() {
            // Remove existing lines if any
            if (topoLines) {
                scene.remove(topoLines);
            }

            const group = new THREE.Group();
            const greenRadius = 15;

            // Always show base grid
            const gridHelper = new THREE.GridHelper(greenRadius * 2, 20, 0x888888, 0x444444);
            gridHelper.position.y = 0.02;
            group.add(gridHelper);

            // Create topographical lines based on break and elevation
            // Lines will be perpendicular to the slope direction
            if (currentBreak !== 0 || currentElevation !== 0) {
                // Calculate slope direction
                const breakAngle = currentBreak * 0.5 * Math.PI / 180;
                const elevationAngle = currentElevation * 0.5 * Math.PI / 180;

                // For break: lines run parallel to slope (left-right for break)
                // For elevation: lines run perpendicular to hole direction (across the green)

                const lineCount = 20;
                const spacing = greenRadius * 2 / lineCount;

                for (let i = -lineCount/2; i <= lineCount/2; i++) {
                    const points = [];

                    if (Math.abs(currentBreak) > Math.abs(currentElevation)) {
                        // Break dominant - draw lines parallel to X axis (showing left-right slope)
                        const z = i * spacing;
                        points.push(new THREE.Vector3(-greenRadius, 0.02, z));
                        points.push(new THREE.Vector3(greenRadius, 0.02, z));
                    } else {
                        // Elevation dominant - draw lines parallel to Z axis (showing uphill/downhill)
                        const x = i * spacing;
                        points.push(new THREE.Vector3(x, 0.02, -greenRadius));
                        points.push(new THREE.Vector3(x, 0.02, greenRadius));
                    }

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    // Color based on intensity
                    let color = 0xFFFFFF;
                    let opacity = 0.3;

                    // Highlight certain lines to show slope intensity
                    if (i % 5 === 0) {
                        opacity = 0.6;
                        if (currentBreak > 0) color = 0xFF8800; // Orange for right break
                        else if (currentBreak < 0) color = 0x0088FF; // Blue for left break
                        else if (currentElevation > 0) color = 0xFF4444; // Red for uphill
                        else if (currentElevation < 0) color = 0x44FF44; // Green for downhill
                    }

                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        opacity: opacity,
                        transparent: true
                    });

                    const line = new THREE.Line(geometry, material);
                    group.add(line);
                }
            }

            topoLines = group;
            scene.add(topoLines);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'y' || e.key === 'Y') {
                toggleTopoLines();
            }
        });

        function hitBall(speed, backspin, sidespin, hla = 0) {
            if (isMoving) return; // Don't hit while ball is moving

            puttCount++;
            document.getElementById('puttCount').textContent = puttCount;

            // Convert mph to m/s
            const speedMS = speed * 0.44704;

            // Set ball velocity with horizontal launch angle
            // HLA positive = right, negative = left
            const hlaRad = hla * Math.PI / 180;

            // Base direction toward hole
            const directionToHole = new THREE.Vector3(
                -ball.position.x,
                0,
                -ball.position.z
            ).normalize();

            // Apply horizontal launch angle
            // X component: lateral (left/right), Z component: forward (toward hole)
            // HLA: negative = left, positive = right (flipped sign to match convention)
            ballVelocity.set(
                -speedMS * Math.sin(hlaRad),  // Lateral velocity (negative HLA = left, positive HLA = right)
                0,
                speedMS * Math.cos(hlaRad) * (directionToHole.z < 0 ? -1 : 1)  // Forward velocity toward hole
            );

            // Set spin (convert RPM to rad/s)
            ballSpin.set(
                backspin * Math.PI / 30,  // backspin
                0,
                -sidespin * Math.PI / 30  // sidespin
            );

            isMoving = true;
            puttResultProcessed = false; // Reset for new putt

            // Update display
            document.getElementById('ballSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('backSpin').textContent = Math.round(backspin) + ' rpm';
            document.getElementById('sideSpin').textContent = Math.round(sidespin) + ' rpm';
        }

        function setupElectronIPC() {
            // Load players from localStorage
            const playersData = localStorage.getItem('puttingPlayers');
            window.puttingPlayers = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#ff6b6b' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('puttingCurrentPlayer') || '0');

            updatePlayerDisplay();

            // Hide Next Player button if only 1 player
            if (window.puttingPlayers.length === 1) {
                document.getElementById('nextPlayerBtn').style.display = 'none';
            }

            // Listen for shot data
            window.electronAPI.onShotData((shotData) => {
                console.log('üì° Putt received:', shotData);

                // Only accept putter shots
                if (shotData.club && shotData.club !== 'PT') {
                    console.log('‚ö† Not a putter shot, ignoring');
                    return;
                }

                const speed = shotData.ball_speed || 0;
                const backspin = shotData.back_spin || 0;
                const sidespin = shotData.side_spin || 0;
                const hla = shotData.hla || 0;

                if (speed > 0) {
                    hitBall(speed, backspin, sidespin, hla);
                }
            });
        }

        function updatePlayerDisplay() {
            if (!window.puttingPlayers || window.puttingPlayers.length === 0) return;

            const player = window.puttingPlayers[window.currentPlayerIndex];
            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }
        }

        function nextPlayer() {
            if (!window.puttingPlayers || window.puttingPlayers.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.puttingPlayers.length;
            localStorage.setItem('puttingCurrentPlayer', window.currentPlayerIndex.toString());

            updatePlayerDisplay();
            puttCount = 0;
            document.getElementById('puttCount').textContent = puttCount;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updatePhysics(deltaTime);

            // Update camera for follow and behind modes
            if (currentView === 'follow' || currentView === 'behind') {
                updateCameraPosition();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

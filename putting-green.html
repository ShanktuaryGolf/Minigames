<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Putting Green</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 240px;
            max-width: 240px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        #controls h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
            text-align: center;
            margin-bottom: 8px;
        }

        .button-group {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        #controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            flex: 1;
            min-width: 70px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        #controls button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .stat-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .stat-section h4 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-row {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            opacity: 0.8;
        }

        .stat-value {
            font-weight: bold;
            color: #4CAF50;
            font-size: 13px;
        }

        #playerIndicator {
            background: rgba(251, 191, 36, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            text-align: center;
            border: 1px solid #fbbf24;
        }

        #playerIndicator strong {
            font-size: 11px;
        }

        #currentPlayerName {
            font-size: 15px;
            margin-top: 3px;
            font-weight: bold;
        }

        .slider-container {
            margin: 8px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            color: #4CAF50;
            font-weight: bold;
            font-size: 11px;
        }

        .collapse-toggle {
            background: rgba(76, 175, 80, 0.3) !important;
            border: 2px solid #4CAF50 !important;
            padding: 6px 10px !important;
            margin-bottom: 8px;
            font-size: 12px !important;
            width: 100%;
            text-align: center;
        }

        .collapse-toggle:hover {
            background: rgba(76, 175, 80, 0.5) !important;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <div id="playerIndicator">
            <strong style="color: #fbbf24;">Current Player:</strong>
            <div id="currentPlayerName">Player 1</div>
        </div>

        <!-- Mode Toggle (Collapseable) -->
        <button class="collapse-toggle" onclick="toggleSection('modeSection')">
            üéÆ Game Modes <span id="modeSectionArrow">‚ñº</span>
        </button>
        <div id="modeSection" class="button-group" style="margin-bottom: 12px; flex-direction: column;">
            <button id="practiceModeBtn" onclick="setPracticeMode()" style="background: #4CAF50;">Practice</button>
            <button id="ladderModeBtn" onclick="setLadderMode()" style="background: rgba(76, 175, 80, 0.3);">Ladder</button>
            <button id="clockDrillBtn" onclick="setClockDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Clock Drill</button>
            <button id="gateDrillBtn" onclick="setGateDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Gate Drill</button>
            <button id="circleDrillBtn" onclick="setCircleDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Circle Drill</button>
            <button id="starDrillBtn" onclick="setStarDrillMode()" style="background: rgba(76, 175, 80, 0.3);">Star Drill</button>
        </div>

        <!-- Ladder Stats (hidden by default) -->
        <div id="ladderStats" class="stat-section" style="display: none; background: rgba(251, 191, 36, 0.1); border: 1px solid #fbbf24;">
            <h4 style="color: #fbbf24; margin-bottom: 10px; text-align: center;">üéØ Ladder Progress</h4>
            <div class="stat-row">
                <span class="stat-label">Level:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderLevel">1 (2 ft)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes at Level:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderMakes">0/2</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Total Putts:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderTotalPutts">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Make %:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderMakePercent">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Personal Best:</span>
                <span class="stat-value" style="color: #fbbf24;" id="ladderPersonalBest">2 ft</span>
            </div>
        </div>

        <!-- Clock Drill Stats (hidden by default) -->
        <div id="clockDrillStats" class="stat-section" style="display: none; background: rgba(59, 130, 246, 0.1); border: 1px solid #3b82f6;">
            <h4 style="color: #3b82f6; margin-bottom: 10px; text-align: center;">üïê Clock Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockDistance">6 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockPosition">12 o'clock (1/12)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockMakes">0/12</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Streak:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockStreak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Success Rate:</span>
                <span class="stat-value" style="color: #3b82f6;" id="clockSuccessRate">0%</span>
            </div>
        </div>

        <!-- Gate Drill Stats (hidden by default) -->
        <div id="gateDrillStats" class="stat-section" style="display: none; background: rgba(168, 85, 247, 0.1); border: 1px solid #a855f7;">
            <h4 style="color: #a855f7; margin-bottom: 10px; text-align: center;">‚ö° Gate Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateDistance">10 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Gate Width:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateWidth">6 in</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Through Gate:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateThroughCount">0/0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateMakes">0/0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Accuracy:</span>
                <span class="stat-value" style="color: #a855f7;" id="gateAccuracy">0%</span>
            </div>
        </div>

        <!-- Circle Drill Stats (hidden by default) -->
        <div id="circleDrillStats" class="stat-section" style="display: none; background: rgba(236, 72, 153, 0.1); border: 1px solid #ec4899;">
            <h4 style="color: #ec4899; margin-bottom: 10px; text-align: center;">‚≠ï Circle Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Current Distance:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleCurrentDistance">3 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Attempts at Distance:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleAttempts">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleMakes">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Round Progress:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleProgress">1/4 distances</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Overall Success:</span>
                <span class="stat-value" style="color: #ec4899;" id="circleSuccess">0%</span>
            </div>
        </div>

        <!-- Star Drill Stats (hidden by default) -->
        <div id="starDrillStats" class="stat-section" style="display: none; background: rgba(249, 115, 22, 0.1); border: 1px solid #f97316;">
            <h4 style="color: #f97316; margin-bottom: 10px; text-align: center;">‚≠ê Star Drill</h4>
            <div class="stat-row">
                <span class="stat-label">Distance:</span>
                <span class="stat-value" style="color: #f97316;" id="starDistance">8 ft</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Position:</span>
                <span class="stat-value" style="color: #f97316;" id="starPosition">Point 1 (1/5)</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Makes:</span>
                <span class="stat-value" style="color: #f97316;" id="starMakes">0/5</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Current Streak:</span>
                <span class="stat-value" style="color: #f97316;" id="starStreak">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Success Rate:</span>
                <span class="stat-value" style="color: #f97316;" id="starSuccessRate">0%</span>
            </div>
        </div>

        <div class="stat-section" id="practiceControls">
            <button onclick="togglePracticeSettings()" style="width: 100%; background: transparent; border: none; color: #4CAF50; cursor: pointer; padding: 0; margin-bottom: 10px; text-align: left; font-size: 16px; font-weight: bold;">
                <span id="practiceSettingsToggle">‚ñº</span> Practice Settings
            </button>

            <div id="practiceSettingsContent">
                <div class="slider-container">
                    <label>
                        Distance: <span class="slider-value" id="distanceValue">20 ft</span>
                    </label>
                    <input type="range" id="distanceSlider" min="1" max="40" value="20" step="1">
                </div>

                <div class="slider-container">
                    <label>
                        Stimp (Green Speed): <span class="slider-value" id="stimpValue">10.0</span>
                    </label>
                    <input type="range" id="stimpSlider" min="7" max="14" value="10" step="0.5">
                </div>

                <div class="slider-container">
                    <label>
                        Break: <span class="slider-value" id="breakValue">0 (Straight)</span>
                    </label>
                    <input type="range" id="breakSlider" min="-10" max="10" value="0" step="1">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; opacity: 0.6; margin-top: 4px;">
                        <span>‚Üê Left</span>
                        <span>Straight</span>
                        <span>Right ‚Üí</span>
                    </div>
                    <div id="breakAngle" style="text-align: center; margin-top: 8px; font-size: 13px; color: #FFA500;">
                        Slope: 0.0¬∞
                    </div>
                </div>

                <div class="slider-container">
                    <label>
                        Elevation: <span class="slider-value" id="elevationValue">0 (Flat)</span>
                    </label>
                    <input type="range" id="elevationSlider" min="-10" max="10" value="0" step="1">
                    <div style="display: flex; justify-content: space-between; font-size: 11px; opacity: 0.6; margin-top: 4px;">
                        <span>‚Üì Downhill</span>
                        <span>Flat</span>
                        <span>Uphill ‚Üë</span>
                    </div>
                    <div id="elevationAngle" style="text-align: center; margin-top: 8px; font-size: 13px; color: #FFA500;">
                        Grade: 0.0¬∞
                    </div>
                </div>
            </div>
        </div>

        <div class="stat-section" style="background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50;">
            <h4 style="color: #4CAF50; margin-bottom: 10px; text-align: center;">Distance to Hole</h4>
            <div style="text-align: center; font-size: 32px; font-weight: bold; color: #4CAF50;" id="distanceToHole">
                -- ft
            </div>
        </div>

        <div class="button-group">
            <button id="viewBtn">Change View</button>
            <button id="topoBtn" onclick="toggleTopoLines()">Toggle Grid</button>
            <button id="resetBtn" onclick="resetBall()">Reset Ball</button>
        </div>
        <div class="button-group">
            <button id="nextPlayerBtn" onclick="nextPlayer()" style="background: rgba(251, 191, 36, 0.3); border-color: #fbbf24;">Next Player ‚Üí</button>
        </div>

        <!-- Debug Controls - DISABLED FOR PRODUCTION -->
        <div class="stat-section" style="background: rgba(255, 165, 0, 0.1); border: 1px solid #FFA500; display: none;">
            <h4 style="color: #FFA500; margin-bottom: 10px;">üõ†Ô∏è Debug Controls</h4>
            <div style="margin-bottom: 8px;">
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Speed (mph):</label>
                <input type="number" id="debugSpeed" value="5.0" step="0.1" min="0" max="30"
                       style="width: 100%; padding: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.3);
                              border-radius: 4px; color: white; font-size: 14px;">
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Horizontal Angle (¬∞):</label>
                <input type="number" id="debugHLA" value="0" step="1" min="-45" max="45"
                       style="width: 100%; padding: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.3);
                              border-radius: 4px; color: white; font-size: 14px;">
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: block; font-size: 12px; margin-bottom: 4px;">Vertical Angle (¬∞):</label>
                <input type="number" id="debugVLA" value="0" step="0.1" min="-5" max="5"
                       style="width: 100%; padding: 6px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.3);
                              border-radius: 4px; color: white; font-size: 14px;">
            </div>
            <button onclick="testShot()" style="width: 100%; background: rgba(255, 165, 0, 0.3); border: 1px solid #FFA500; color: white;
                   padding: 10px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold;">
                üèåÔ∏è Test Shot
            </button>
        </div>

        <div id="scoreInfo" class="stat-section">
            <h4 style="color: #4CAF50; margin-bottom: 10px;">Score</h4>
            <div class="stat-row">
                <span class="stat-label">Putts:</span>
                <span class="stat-value" id="puttCount">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Holes:</span>
                <span class="stat-value" id="holesCompleted">0</span>
            </div>
        </div>

        <div id="shotInfo" class="stat-section">
            <h4 style="color: #4CAF50; margin-bottom: 10px;">Last Putt</h4>
            <div class="stat-row">
                <span class="stat-label">Ball Speed:</span>
                <span class="stat-value" id="ballSpeed">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">HLA:</span>
                <span class="stat-value" id="hla">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">VLA:</span>
                <span class="stat-value" id="vla">--</span>
            </div>
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let ball, ballBody;
        let currentView = 'follow'; // 'overhead', 'behind', 'follow', 'side'
        let holes = [];
        let puttCount = 0;
        let holesCompleted = 0;
        let topoLines = null; // Topographical grid lines
        let showTopoLines = false;

        // Ladder Mode variables
        let isLadderMode = false;
        let ladderLevel = 1; // Start at level 1 (2ft)

        // Clock Drill variables
        let isClockDrillMode = false;
        let clockDistance = 6; // Default 6 feet
        let clockPosition = 0; // 0-11 for 12 positions around hole

        // Gate Drill variables
        let isGateDrillMode = false;
        let gateDistance = 10; // Default 10 feet
        let gateWidth = 6; // Width in inches (default 6 inches)
        let gateThroughCount = 0; // Successful putts through gate
        let gateAttempts = 0;
        let gateMakes = 0;
        let gateObjects = []; // Visual gate markers
        let ballPassedGate = false; // Track if ball successfully passed through gate
        let ballBeforeGate = true; // Track if ball is still approaching gate

        // Circle Drill variables
        let isCircleDrillMode = false;
        const CIRCLE_DISTANCES = [3, 6, 9, 12]; // ft
        let circleDistanceIndex = 0; // Current distance in sequence (0-3)
        let circleAttemptsAtDistance = 0;
        let circleMakesAtDistance = 0;
        let circleTotalAttempts = 0;
        let circleTotalMakes = 0;

        // Star Drill variables
        let isStarDrillMode = false;
        let starDistance = 8; // Default 8 feet
        let starPosition = 0; // 0-4 for 5 positions (72 degrees apart)
        let starMakes = 0;
        let starCurrentStreak = 0;
        let starAttempts = 0;
        let clockMakes = 0;
        let clockCurrentStreak = 0;
        let clockAttempts = 0;
        let ladderMakesAtLevel = 0; // Consecutive makes at current level
        let ladderTotalPutts = 0;
        let ladderTotalMakes = 0;
        let ladderPersonalBest = 2; // Best distance reached (in feet)
        const LADDER_DISTANCES = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]; // 2ft increments

        // Practice settings
        let currentDistance = 20; // feet
        let currentStimp = 10.0; // Stimpmeter rating
        let currentBreak = 0; // -10 (left) to +10 (right)
        let currentElevation = 0; // -10 (downhill) to +10 (uphill)

        // Ball physics
        const ballRadius = 0.021; // Golf ball radius in meters (42.67mm diameter)
        const gravity = 9.81;
        let friction = 0.15; // Rolling friction coefficient (will be calculated from Stimp)
        const restitution = 0.5; // Bounciness

        // Ball state
        let ballVelocity = new THREE.Vector3(0, 0, 0);
        let ballSpin = new THREE.Vector3(0, 0, 0);
        let isMoving = false;
        let lastTime = performance.now();
        let puttResultProcessed = false; // Track if result was processed for ladder mode

        const DEBUG_PUTTING_COLLISION = false;
        const logCollision = DEBUG_PUTTING_COLLISION ? console.log.bind(console) : () => {};
        const DISTANCE_UPDATE_INTERVAL_MS = 100;
        let lastDistanceUpdateTime = 0;

        const tempSpinEffect = new THREE.Vector3();
        const tempNormal = new THREE.Vector3();
        const tempDirToHole = new THREE.Vector3();

        // Players
        window.puttingPlayers = [];
        window.currentPlayerIndex = 0;

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Better sky gradient background
            const skyColor = new THREE.Color(0x87CEEB);      // Sky blue
            const horizonColor = new THREE.Color(0xB0E0E6);  // Light blue at horizon
            scene.background = skyColor;
            scene.fog = new THREE.Fog(horizonColor, 30, 100); // Add atmospheric fog

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Load Visual Offset from localStorage (for projector alignment)
            let visualOffsetX = 0;
            let visualOffsetY = 0;
            const savedOffsetX = localStorage.getItem('golfVisualOffsetX');
            const savedOffsetY = localStorage.getItem('golfVisualOffsetY');
            if (savedOffsetX) visualOffsetX = parseInt(savedOffsetX);
            if (savedOffsetY) visualOffsetY = parseInt(savedOffsetY);

            // Apply visual offset to camera
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                camera.setViewOffset(window.innerWidth, window.innerHeight, visualOffsetX, visualOffsetY, window.innerWidth, window.innerHeight);
            }

            // Renderer with better settings
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;  // Better color mapping
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // Improved lighting setup
            // Hemisphere light for realistic sky/ground lighting
            const hemisphereLight = new THREE.HemisphereLight(
                0x87CEEB,  // Sky color
                0x2d5016,  // Ground color (dark green)
                0.4
            );
            scene.add(hemisphereLight);

            // Ambient light for base illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Main sun light - stronger and better positioned
            const sunLight = new THREE.DirectionalLight(0xFFFAF0, 1.2);  // Slightly warm white
            sunLight.position.set(15, 25, 10);
            sunLight.castShadow = true;

            // Higher quality shadows
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.mapSize.width = 4096;   // Higher resolution shadows
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.02;
            scene.add(sunLight);

            // Fill light to soften shadows
            const fillLight = new THREE.DirectionalLight(0xB0E0E6, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            createEnvironment();
            createGreen();
            createBall();
            createHoles();

            // Update camera position now that ball exists
            updateCameraPosition();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('viewBtn').addEventListener('click', cycleView);

            // Setup sliders
            setupSliders();

            // Check for Electron IPC
            if (window.electronAPI) {
                console.log('‚úì Running in Electron - IPC available');
                setupElectronIPC();
            } else {
                console.log('‚ö† Not running in Electron - standalone mode');
            }
        }

        function createEnvironment() {
            // Large ground plane surrounding the green
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundTexture = createGrassTexture(0.25); // Darker for rough
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.95,
                metalness: 0.0,
                color: 0x6B8E23  // Olive drab for rough grass
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createGreen() {
            // Main putting green (15 meters = ~49 ft to accommodate 40 ft putts)
            const greenGeometry = new THREE.CircleGeometry(15, 64);
            const greenTexture = createGrassTexture();
            const greenMaterial = new THREE.MeshStandardMaterial({
                map: greenTexture,
                roughness: 0.9,          // Grass is quite rough/diffuse
                metalness: 0.0,          // Grass is non-metallic
                side: THREE.DoubleSide
            });
            const green = new THREE.Mesh(greenGeometry, greenMaterial);
            green.rotation.x = -Math.PI / 2;
            green.receiveShadow = true;
            scene.add(green);

            // Fringe (darker grass around green)
            const fringeGeometry = new THREE.RingGeometry(15, 17, 64);
            const fringeTexture = createGrassTexture(0.3);
            const fringeMaterial = new THREE.MeshStandardMaterial({
                map: fringeTexture,
                roughness: 0.95,         // Fringe grass is rougher
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            const fringe = new THREE.Mesh(fringeGeometry, fringeMaterial);
            fringe.rotation.x = -Math.PI / 2;
            fringe.position.y = -0.01;
            fringe.receiveShadow = true;
            scene.add(fringe);
        }

        function createDetailGrass() {
            // High-detail shader grass only in 3-meter radius around hole
            const detailRadius = 3.0;
            const bladeWidth = 0.012;  // Slightly thinner for more natural look
            const bladeHeight = 0.05;  // Shorter for putting green

            const grassVertexShader = `
                uniform float time;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                varying float vAO;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }

                void main() {
                    vUv = uv;
                    vNormal = normal;
                    vec3 pos = position;

                    float heightPercent = uv.y;

                    // Per-blade randomness
                    float randomHeight = hash(vec2(pos.x * 10.0, pos.z * 10.0)) * 0.3 + 0.85;
                    float randomBend = hash(vec2(pos.z * 10.0, pos.x * 10.0)) * 0.2 + 0.1;

                    // Subtle wind
                    float wind = sin(time * 0.6 + pos.x * 2.0 + pos.z * 2.0) * 0.08;
                    wind += sin(time * 1.3 + pos.x) * 0.04;

                    // Apply effects
                    pos.y *= randomHeight;
                    float curve = heightPercent * heightPercent;
                    pos.x += curve * (randomBend + wind);
                    pos.z += curve * wind * 0.5;

                    // Ambient occlusion at base
                    vAO = mix(0.7, 1.0, heightPercent * heightPercent);
                    vPosition = pos;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const grassFragmentShader = `
                uniform vec3 baseColor;
                uniform vec3 tipColor;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                varying float vAO;

                void main() {
                    float heightPercent = vUv.y;

                    // Darker at base, lighter at tip
                    vec3 grassColor = mix(baseColor, tipColor, pow(heightPercent, 1.5));

                    // Simple lighting
                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                    float diff = max(dot(normalize(vNormal), lightDir), 0.0) * 0.5 + 0.5;

                    vec3 finalColor = grassColor * diff * vAO;
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const geometry = new THREE.PlaneGeometry(bladeWidth, bladeHeight, 1, 3);
            geometry.translate(0, bladeHeight / 2, 0);

            const baseColor = new THREE.Color(0x2a7a1a);
            const tipColor = new THREE.Color(0x4db82e);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: baseColor },
                    tipColor: { value: tipColor }
                },
                vertexShader: grassVertexShader,
                fragmentShader: grassFragmentShader,
                side: THREE.DoubleSide
            });

            // Increased density for better coverage around hole
            const instanceCount = 20000;
            const instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;

            const dummy = new THREE.Object3D();

            for (let i = 0; i < instanceCount; i++) {
                // Random position within detail radius
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.sqrt(Math.random()) * detailRadius;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                dummy.position.set(x, 0.001, z); // Slightly above ground
                dummy.rotation.y = Math.random() * Math.PI * 2;
                dummy.scale.set(
                    0.9 + Math.random() * 0.3,
                    0.9 + Math.random() * 0.3,
                    1.0
                );
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
            scene.add(instancedMesh);

            // Store for animation
            if (!window.grassMeshes) window.grassMeshes = [];
            window.grassMeshes.push(material);
        }

        function createGrassTexture(brightness = 0.5) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // Base green color - more realistic golf green shade
            const baseR = Math.floor(20 + brightness * 15);
            const baseG = Math.floor(100 + brightness * 60);
            const baseB = Math.floor(20 + brightness * 15);
            ctx.fillStyle = `rgb(${baseR}, ${baseG}, ${baseB})`;
            ctx.fillRect(0, 0, 1024, 1024);

            // Add natural color variation (patches of slightly different green)
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const size = 20 + Math.random() * 80;
                const variation = -10 + Math.random() * 20;
                const patchG = Math.max(0, Math.min(255, baseG + variation));

                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `rgba(${baseR}, ${patchG}, ${baseB}, 0.3)`);
                gradient.addColorStop(1, `rgba(${baseR}, ${patchG}, ${baseB}, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(x - size, y - size, size * 2, size * 2);
            }

            // Add grass blade texture - many small directional strokes
            for (let i = 0; i < 15000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const length = 2 + Math.random() * 4;
                const angle = Math.random() * Math.PI * 2;
                const shade = Math.floor(80 + Math.random() * 40 + brightness * 40);

                ctx.strokeStyle = `rgba(0, ${shade}, 0, ${0.2 + Math.random() * 0.3})`;
                ctx.lineWidth = 0.5 + Math.random() * 0.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                ctx.stroke();
            }

            // Add subtle noise for realism
            const imageData = ctx.getImageData(0, 0, 1024, 1024);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = (Math.random() - 0.5) * 10;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));     // R
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
            }
            ctx.putImageData(imageData, 0, 0);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4); // Repeat for detail

            return texture;
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.3,          // Slightly glossy golf ball
                metalness: 0.1,          // Very slight metallic look
                emissive: 0x222222,      // Subtle glow
                emissiveIntensity: 0.02
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, ballRadius, -8); // Start near edge
            ball.castShadow = true;
            ball.receiveShadow = true;   // Ball can receive shadows too
            scene.add(ball);
        }

        function createHoles() {
            // Create hole at center of green
            createHole(0, 0, 1);
        }

        function createHole(x, z, number) {
            // Cup (hole) - dark interior
            const cupGeometry = new THREE.CylinderGeometry(0.054, 0.054, 0.1, 32); // 108mm diameter
            const cupMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.8,
                metalness: 0.0,
                emissive: 0x000000
            });
            const cup = new THREE.Mesh(cupGeometry, cupMaterial);
            cup.position.set(x, -0.05, z);
            cup.receiveShadow = true;
            scene.add(cup);

            // White cup liner (plastic ring at top of hole)
            const linerGeometry = new THREE.TorusGeometry(0.054, 0.003, 8, 32);
            const linerMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.3,
                metalness: 0.1
            });
            const liner = new THREE.Mesh(linerGeometry, linerMaterial);
            liner.rotation.x = Math.PI / 2;
            liner.position.set(x, 0.001, z); // Just above ground level
            liner.castShadow = true;
            liner.receiveShadow = true;
            scene.add(liner);

            // Flag pole - proper golf flag height
            const poleGeometry = new THREE.CylinderGeometry(0.008, 0.008, 1.5, 16); // Standard golf flag height
            const poleMaterial = new THREE.MeshStandardMaterial({
                color: 0xE8E8E8,      // Light gray, not pure white
                roughness: 0.5,
                metalness: 0.3,
                envMapIntensity: 0.5
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(x, 0.75, z + 0.054); // Moved to back edge of hole
            pole.castShadow = true;
            pole.receiveShadow = true;
            scene.add(pole);

            // Pole top cap (decorative ball on top)
            const capGeometry = new THREE.SphereGeometry(0.015, 16, 16);
            const capMaterial = new THREE.MeshStandardMaterial({
                color: 0xE8E8E8,
                roughness: 0.3,
                metalness: 0.5
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.set(x, 1.515, z + 0.054);
            cap.castShadow = true;
            scene.add(cap);

            // Flag - larger and more detailed
            const flagGeometry = new THREE.PlaneGeometry(0.35, 0.25);
            const flagMaterial = new THREE.MeshStandardMaterial({
                color: 0xCC0000,      // Slightly darker red
                roughness: 0.8,       // More fabric-like
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(x + 0.175, 1.3, z + 0.054); // Centered on larger flag
            flag.castShadow = true;
            flag.receiveShadow = true;
            scene.add(flag);

            holes.push({ x, z, number, radius: 0.054 });
        }

        function updateCameraPosition() {
            switch (currentView) {
                case 'overhead':
                    camera.position.set(0, 15, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'behind':
                    // Camera positioned behind the ball, looking toward the hole
                    // Calculate direction from ball to hole
                    tempDirToHole.set(
                        -ball.position.x,
                        0,
                        -ball.position.z
                    ).normalize();

                    // Position camera behind ball (opposite direction to hole)
                    const behindDistance = 1.5; // meters behind the ball
                    const behindHeight = 0.3; // height above ground
                    camera.position.set(
                        ball.position.x - tempDirToHole.x * behindDistance,
                        ball.position.y + behindHeight,
                        ball.position.z - tempDirToHole.z * behindDistance
                    );

                    // Look at the hole (or slightly above the ball)
                    camera.lookAt(ball.position.x + tempDirToHole.x * 2, ball.position.y, ball.position.z + tempDirToHole.z * 2);
                    break;
                case 'follow':
                    // Follow camera stays behind the ball as it moves
                    if (isMoving && ballVelocity.length() > 0.01) {
                        // Get ball's direction of travel
                        tempDirToHole.copy(ballVelocity).normalize();

                        // Position camera behind the ball's direction of travel
                        const followDistance = 1.0;
                        const followHeight = 0.4;
                        camera.position.set(
                            ball.position.x - tempDirToHole.x * followDistance,
                            ball.position.y + followHeight,
                            ball.position.z - tempDirToHole.z * followDistance
                        );

                        // Look slightly ahead of the ball
                        camera.lookAt(
                            ball.position.x + tempDirToHole.x * 0.5,
                            ball.position.y,
                            ball.position.z + tempDirToHole.z * 0.5
                        );
                    } else {
                        // If ball stopped, use same as behind view
                        tempDirToHole.set(
                            -ball.position.x,
                            0,
                            -ball.position.z
                        ).normalize();
                        camera.position.set(
                            ball.position.x - tempDirToHole.x * 1.0,
                            ball.position.y + 0.4,
                            ball.position.z - tempDirToHole.z * 1.0
                        );
                        camera.lookAt(ball.position.x + tempDirToHole.x, ball.position.y, ball.position.z + tempDirToHole.z);
                    }
                    break;
                case 'side':
                    camera.position.set(8, 2, 0);
                    camera.lookAt(0, 0, 0);
                    break;
            }
        }

        function cycleView() {
            const views = ['overhead', 'behind', 'follow', 'side'];
            const currentIndex = views.indexOf(currentView);
            currentView = views[(currentIndex + 1) % views.length];
            updateCameraPosition();
            showNotification(`Camera: ${currentView.charAt(0).toUpperCase() + currentView.slice(1)}`);
        }

        function showNotification(message) {
            const existing = document.getElementById('cameraNotification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'cameraNotification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 24px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 1500);
        }

        function updatePhysics(deltaTime) {
            if (!isMoving) return;

            // Apply friction
            const speed = ballVelocity.length();
            if (speed > 0.001) {
                const frictionForce = friction * gravity * deltaTime;
                const frictionDecel = Math.min(frictionForce / speed, 1);
                ballVelocity.multiplyScalar(1 - frictionDecel);

                // Apply elevation (uphill/downhill)
                // Uphill: slows ball down, Downhill: speeds ball up
                if (currentElevation !== 0) {
                    const elevationAngle = currentElevation * 0.5 * Math.PI / 180; // Convert to radians
                    const gradeForce = gravity * Math.sin(elevationAngle);

                    // Apply force in Z direction (along the line to hole)
                    // Ball rolls toward hole (negative Z direction)
                    // Uphill (positive elevation) = opposing force (positive Z) = slows down
                    // Downhill (negative elevation) = assisting force (negative Z) = speeds up
                    ballVelocity.z -= gradeForce * deltaTime; // REVERSED: subtract to get correct direction
                }

                // Apply break (simulates slope)
                // Break force is perpendicular to velocity, scaled by speed and break amount
                // The slower the ball, the more it breaks (realistic putting physics)
                if (currentBreak !== 0) {
                    // Calculate break force based on green slope
                    // Break scale: each point = ~0.5 degrees of slope
                    const breakAngle = currentBreak * 0.5 * Math.PI / 180; // Convert to radians
                    const slopeForce = gravity * Math.sin(breakAngle);

                    // Apply break force in X direction (positive = right, negative = left)
                    // Break effect increases as ball slows down (realistic)
                    const speedFactor = Math.max(0.2, 1 - (speed / 5)); // More break when slower
                    const breakForce = slopeForce * speedFactor * deltaTime;

                    ballVelocity.x += breakForce;
                }

                // Apply spin effect (Magnus force - simplified)
                if (ballSpin.length() > 0.1) {
                    tempSpinEffect
                        .crossVectors(ballSpin, ballVelocity)
                        .multiplyScalar(0.0001 * deltaTime);
                    ballVelocity.add(tempSpinEffect);

                    // Spin decay
                    ballSpin.multiplyScalar(1 - deltaTime * 2);
                }

                // Check for hole collision BEFORE moving (predictive)
                const hadCollision = checkHoleCollisionPredictive(deltaTime);

                // Update position (only if no collision happened, since collision already positioned the ball)
                if (!hadCollision) {
                    ball.position.addScaledVector(ballVelocity, deltaTime);
                }

                // Check gate post collisions and gate crossing (if in gate drill mode)
                if (isGateDrillMode && gateObjects.length > 0) {
                    checkGatePostCollisions();
                    checkBallThroughGate(); // Track if ball passed through gate
                }

                // Keep ball on green (simple collision)
                const distFromCenter = Math.sqrt(ball.position.x ** 2 + ball.position.z ** 2);
                if (distFromCenter > 14.8) {
                    // Bounce off edge
                    tempNormal.set(ball.position.x, 0, ball.position.z).normalize();
                    ballVelocity.reflect(tempNormal).multiplyScalar(restitution);
                    ball.position.x = tempNormal.x * 14.8;
                    ball.position.z = tempNormal.z * 14.8;
                }

                // Check for hole (post-movement for slow balls)
                checkHoleCollision();

                // Update distance to hole display
                updateDistanceToHole();

                // Re-check speed after all forces applied (prevents infinite roll with break)
                const finalSpeed = ballVelocity.length();
                if (finalSpeed < 0.001) {
                    ballVelocity.set(0, 0, 0);
                    ballSpin.set(0, 0, 0);
                    isMoving = false;

                    // Check for ladder mode miss
                    if (isLadderMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            ladderPuttMissed();
                            resetBall();
                        }, 1500);
                    }

                    // Check for clock drill miss
                    if (isClockDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            clockDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for gate drill miss
                    if (isGateDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            gateDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for circle drill miss
                    if (isCircleDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            circleDrillPuttMissed();
                        }, 1500);
                    }

                    // Check for star drill miss
                    if (isStarDrillMode && !puttResultProcessed) {
                        puttResultProcessed = true;
                        // Ball stopped but didn't go in hole - it's a miss
                        setTimeout(() => {
                            starDrillPuttMissed();
                        }, 1500);
                    }
                }
            } else {
                // Ball stopped
                ballVelocity.set(0, 0, 0);
                ballSpin.set(0, 0, 0);
                isMoving = false;
                updateDistanceToHole();
            }
        }

        function updateDistanceToHole() {
            const now = performance.now();
            if (now - lastDistanceUpdateTime < DISTANCE_UPDATE_INTERVAL_MS) {
                return;
            }
            lastDistanceUpdateTime = now;

            // Calculate distance from ball to hole (hole is at origin 0,0,0)
            const distanceMeters = Math.sqrt(ball.position.x ** 2 + ball.position.z ** 2);
            const distanceFeet = distanceMeters / 0.3048;

            const displayElement = document.getElementById('distanceToHole');
            if (distanceFeet < 0.5) {
                displayElement.textContent = '< 6"';
                displayElement.style.color = '#FFD700'; // Gold when very close
            } else if (distanceFeet < 1) {
                displayElement.textContent = (distanceFeet * 12).toFixed(1) + '"';
                displayElement.style.color = '#4CAF50';
            } else {
                displayElement.textContent = distanceFeet.toFixed(1) + ' ft';
                displayElement.style.color = '#4CAF50';
            }
        }

        function checkHoleCollisionPredictive(deltaTime) {
            const ballSpeed = ballVelocity.length();

            logCollision(`üîç Predictive check - Speed: ${ballSpeed.toFixed(2)} m/s, Ball pos: (${ball.position.x.toFixed(3)}, ${ball.position.z.toFixed(3)})`);

            // Only check fast balls predictively
            if (ballSpeed < 2.0) {
                logCollision('   ‚è© Ball too slow, skipping predictive check');
                return false;
            }

            let collisionHappened = false;

            holes.forEach(hole => {
                const collisionRadius = hole.radius + ballRadius;

                // Current distance to hole
                const currentDx = ball.position.x - hole.x;
                const currentDz = ball.position.z - hole.z;
                const currentDist = Math.sqrt(currentDx * currentDx + currentDz * currentDz);

                // Next position after movement
                const nextX = ball.position.x + ballVelocity.x * deltaTime;
                const nextZ = ball.position.z + ballVelocity.z * deltaTime;
                const nextDx = nextX - hole.x;
                const nextDz = nextZ - hole.z;
                const nextDist = Math.sqrt(nextDx * nextDx + nextDz * nextDz);

                logCollision(`   üìè Current dist: ${currentDist.toFixed(3)}m, Next dist: ${nextDist.toFixed(3)}m, Collision radius: ${collisionRadius.toFixed(3)}m`);

                // Check if ball will cross into collision radius this frame
                if (currentDist > collisionRadius && nextDist <= collisionRadius) {
                    logCollision('   üéØ COLLISION INCOMING!');

                    // Ball is about to collide - find exact collision point
                    const dirX = ballVelocity.x / ballSpeed;
                    const dirZ = ballVelocity.z / ballSpeed;

                    // Use quadratic equation to find collision time
                    // Circle-ray intersection
                    const ex = ball.position.x - hole.x;
                    const ez = ball.position.z - hole.z;
                    const a = dirX * dirX + dirZ * dirZ;
                    const b = 2 * (ex * dirX + ez * dirZ);
                    const c = ex * ex + ez * ez - collisionRadius * collisionRadius;

                    const discriminant = b * b - 4 * a * c;

                    logCollision(`   üßÆ Quadratic: a=${a.toFixed(4)}, b=${b.toFixed(4)}, c=${c.toFixed(4)}, disc=${discriminant.toFixed(4)}`);

                    if (discriminant >= 0) {
                        const t = (-b - Math.sqrt(discriminant)) / (2 * a);

                        logCollision(`   ‚è±Ô∏è Collision time t=${t.toFixed(4)}, maxT=${(ballSpeed * deltaTime).toFixed(4)}`);

                        if (t > 0 && t <= ballSpeed * deltaTime) {
                            logCollision(`   ‚úÖ APPLYING COLLISION - Moving ball to collision point`);
                            logCollision(`   üìç Before: (${ball.position.x.toFixed(3)}, ${ball.position.z.toFixed(3)})`);

                            // Move ball to exact collision point
                            ball.position.x += dirX * t;
                            ball.position.z += dirZ * t;

                            logCollision(`   üìç After move: (${ball.position.x.toFixed(3)}, ${ball.position.z.toFixed(3)})`);

                            // Calculate normal at collision point (points from hole center to ball)
                            tempNormal.set(
                                ball.position.x - hole.x,
                                0,
                                ball.position.z - hole.z
                            ).normalize();

                            logCollision(`   üîÑ Normal: (${tempNormal.x.toFixed(3)}, ${tempNormal.z.toFixed(3)})`);
                            logCollision(`   üèÉ Velocity before: (${ballVelocity.x.toFixed(3)}, ${ballVelocity.y.toFixed(3)}, ${ballVelocity.z.toFixed(3)})`);

                            // Reflect velocity using vector reflection formula: V' = V - 2(V¬∑N)N
                            const dot = ballVelocity.dot(tempNormal);
                            logCollision(`   üìä Dot product: ${dot.toFixed(3)}`);

                            ballVelocity.x -= 2 * dot * tempNormal.x;
                            ballVelocity.y -= 2 * dot * tempNormal.y;
                            ballVelocity.z -= 2 * dot * tempNormal.z;

                            // Energy loss
                            ballVelocity.multiplyScalar(0.7);

                            logCollision(`   üèÉ Velocity after: (${ballVelocity.x.toFixed(3)}, ${ballVelocity.z.toFixed(3)})`);
                            logCollision(`   üí• COLLISION HANDLED`);

                            collisionHappened = true;
                        } else {
                            logCollision(`   ‚ùå t out of range, no collision`);
                        }
                    } else {
                        logCollision(`   ‚ùå Negative discriminant, no collision`);
                    }
                } else {
                    if (currentDist <= collisionRadius) {
                        logCollision(`   ‚ö†Ô∏è Already inside collision radius!`);
                    }
                }
            });

            return collisionHappened;
        }

        function checkHoleCollision() {
            holes.forEach(hole => {
                const dx = ball.position.x - hole.x;
                const dz = ball.position.z - hole.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                const ballSpeed = ballVelocity.length();
                const collisionRadius = hole.radius + ballRadius;

                // Check if ball is going too fast - it will bounce off flagstick/hole edge
                if (dist <= collisionRadius && ballSpeed >= 2.0) {
                    // Ball hit the flagstick/hole edge going too fast - bounce off

                    // Calculate contact point on hole edge
                    tempNormal.set(dx, 0, dz).normalize();

                    // Position ball exactly at collision point (not past it)
                    ball.position.x = hole.x + tempNormal.x * collisionRadius;
                    ball.position.z = hole.z + tempNormal.z * collisionRadius;

                    // Reflect velocity smoothly
                    const dot = ballVelocity.dot(tempNormal);
                    ballVelocity.x -= 2 * dot * tempNormal.x;
                    ballVelocity.z -= 2 * dot * tempNormal.z;

                    // Energy loss on impact
                    ballVelocity.multiplyScalar(0.7);

                    return; // Don't process as holed
                }

                // Ball going slow enough to drop in hole
                if (dist < collisionRadius && ballSpeed < 2.0) {
                    // Ball in hole!
                    ballVelocity.set(0, 0, 0);
                    isMoving = false;
                    puttResultProcessed = true; // Mark as processed

                    if (isLadderMode) {
                        // Ladder mode - track progress
                        ladderPuttMade();
                    } else if (isClockDrillMode) {
                        // Clock drill - track progress
                        clockDrillPuttMade();
                    } else if (isGateDrillMode) {
                        // Gate drill - track progress
                        gateDrillPuttMade();
                    } else if (isCircleDrillMode) {
                        // Circle drill - track progress
                        circleDrillPuttMade();
                    } else if (isStarDrillMode) {
                        // Star drill - track progress
                        starDrillPuttMade();
                    } else {
                        // Practice mode - normal behavior
                        holesCompleted++;
                        document.getElementById('holesCompleted').textContent = holesCompleted;
                        showNotification(`Hole ${hole.number} Complete! üèåÔ∏è`);
                    }

                    // Reset ball after delay
                    setTimeout(() => {
                        resetBall();
                    }, 2000);
                }
            });
        }

        function setupSliders() {
            const distanceSlider = document.getElementById('distanceSlider');
            const distanceValue = document.getElementById('distanceValue');
            const stimpSlider = document.getElementById('stimpSlider');
            const stimpValue = document.getElementById('stimpValue');
            const breakSlider = document.getElementById('breakSlider');
            const breakValue = document.getElementById('breakValue');
            const elevationSlider = document.getElementById('elevationSlider');
            const elevationValue = document.getElementById('elevationValue');

            // Distance slider
            distanceSlider.addEventListener('input', (e) => {
                currentDistance = parseInt(e.target.value);
                distanceValue.textContent = currentDistance + ' ft';

                if (isGateDrillMode) {
                    gateDistance = currentDistance;
                    createGateMarkers(); // Recreate gate at new distance
                    updateGateDrillDisplay();
                } else if (isClockDrillMode) {
                    clockDistance = currentDistance;
                    positionBallForClockDrill();
                } else if (isStarDrillMode) {
                    starDistance = currentDistance;
                    positionBallForStarDrill();
                }

                updateBallPosition();
            });

            // Stimp slider
            stimpSlider.addEventListener('input', (e) => {
                currentStimp = parseFloat(e.target.value);
                stimpValue.textContent = currentStimp.toFixed(1);
                updateFrictionFromStimp();
            });

            // Break slider
            breakSlider.addEventListener('input', (e) => {
                currentBreak = parseInt(e.target.value);
                updateBreakDisplay();
                if (showTopoLines) createTopoLines(); // Update lines if visible
            });

            // Elevation slider
            elevationSlider.addEventListener('input', (e) => {
                currentElevation = parseInt(e.target.value);
                updateElevationDisplay();
                if (showTopoLines) createTopoLines(); // Update lines if visible
            });

            // Initialize
            updateBallPosition();
            updateFrictionFromStimp();
            updateBreakDisplay();
            updateElevationDisplay();
        }

        function updateBreakDisplay() {
            const breakValue = document.getElementById('breakValue');
            const breakAngle = document.getElementById('breakAngle');

            // Calculate slope angle (each break point = ~0.5 degrees)
            const slopeAngleDegrees = currentBreak * 0.5;

            if (currentBreak === 0) {
                breakValue.textContent = '0 (Straight)';
                breakAngle.textContent = 'Slope: 0.0¬∞';
                breakAngle.style.color = '#4CAF50';
            } else if (currentBreak < 0) {
                breakValue.textContent = `${currentBreak} (‚Üê Left)`;
                breakAngle.textContent = `Slope: ${Math.abs(slopeAngleDegrees).toFixed(1)}¬∞ Left`;
                breakAngle.style.color = '#FFA500';
            } else {
                breakValue.textContent = `${currentBreak} (Right ‚Üí)`;
                breakAngle.textContent = `Slope: ${slopeAngleDegrees.toFixed(1)}¬∞ Right`;
                breakAngle.style.color = '#FFA500';
            }
            console.log(`Break set to: ${currentBreak} (${currentBreak < 0 ? 'Left' : currentBreak > 0 ? 'Right' : 'Straight'}), Slope: ${slopeAngleDegrees.toFixed(1)}¬∞`);
        }

        function updateElevationDisplay() {
            const elevationValue = document.getElementById('elevationValue');
            const elevationAngle = document.getElementById('elevationAngle');

            // Calculate grade angle (each elevation point = ~0.5 degrees)
            const gradeAngleDegrees = currentElevation * 0.5;

            if (currentElevation === 0) {
                elevationValue.textContent = '0 (Flat)';
                elevationAngle.textContent = 'Grade: 0.0¬∞';
                elevationAngle.style.color = '#4CAF50';
            } else if (currentElevation < 0) {
                elevationValue.textContent = `${currentElevation} (‚Üì Downhill)`;
                elevationAngle.textContent = `Grade: ${Math.abs(gradeAngleDegrees).toFixed(1)}¬∞ Down`;
                elevationAngle.style.color = '#00BFFF'; // Light blue for downhill
            } else {
                elevationValue.textContent = `${currentElevation} (Uphill ‚Üë)`;
                elevationAngle.textContent = `Grade: ${gradeAngleDegrees.toFixed(1)}¬∞ Up`;
                elevationAngle.style.color = '#FF6347'; // Red for uphill
            }
            console.log(`Elevation set to: ${currentElevation} (${currentElevation < 0 ? 'Downhill' : currentElevation > 0 ? 'Uphill' : 'Flat'}), Grade: ${gradeAngleDegrees.toFixed(1)}¬∞`);
        }

        function updateFrictionFromStimp() {
            // Based on Stanford physics paper (Kolkowitz 2007)
            // Deceleration: a = -(5/7) √ó œÅ_g √ó g
            // Stimpmeter releases ball at 1.83 m/s
            // Fast green (Stimp 12): rolls 3.66m ‚Üí œÅ_g = 0.065
            // Slow green (Stimp 4): rolls 1.22m ‚Üí œÅ_g = 0.196

            // Linear interpolation between slow and fast
            // Stimp range: 7 (slow) to 14 (fast)
            const stimpRange = 14 - 7;
            const rhoGFast = 0.065;
            const rhoGSlow = 0.196;
            const t = (currentStimp - 7) / stimpRange; // 0 = slow, 1 = fast
            const rhoG = rhoGSlow - t * (rhoGSlow - rhoGFast); // Interpolate

            // Deceleration = (5/7) √ó œÅ_g √ó g
            const deceleration = (5/7) * rhoG * gravity;

            // For our physics update: friction coefficient such that
            // frictionForce = friction √ó gravity √ó deltaTime gives correct deceleration
            friction = rhoG * (5/7);

            console.log(`Stimp ${currentStimp} ‚Üí œÅ_g: ${rhoG.toFixed(4)}, Decel: ${deceleration.toFixed(3)} m/s¬≤, Friction: ${friction.toFixed(4)}`);
        }

        // Listen for Stimp changes from Electron menu
        if (window.electronAPI) {
            // Get initial Stimp from Electron on load
            window.electronAPI.getGreenStimp().then(stimp => {
                currentStimp = stimp;
                document.getElementById('stimpSlider').value = stimp;
                document.getElementById('stimpValue').textContent = stimp.toFixed(1);
                updateFrictionFromStimp();
                console.log(`Loaded Stimp from Electron settings: ${stimp} ft`);
            }).catch(() => {
                console.log('Not running in Electron, using default Stimp: 10 ft');
            });

            // Listen for Stimp changes
            window.electronAPI.onStimpChanged((stimp) => {
                currentStimp = stimp;
                document.getElementById('stimpSlider').value = stimp;
                document.getElementById('stimpValue').textContent = stimp.toFixed(1);
                updateFrictionFromStimp();
                console.log(`‚öôÔ∏è Stimp updated from menu: ${stimp} ft`);
            });
        }

        function updateBallPosition() {
            // Convert feet to meters
            const distanceMeters = currentDistance * 0.3048;

            // Position ball at specified distance from hole
            // Hole is at (0, 0), ball positioned south (negative Z)
            ball.position.set(0, ballRadius, -distanceMeters);

            // Reset physics
            ballVelocity.set(0, 0, 0);
            ballSpin.set(0, 0, 0);
            isMoving = false;

            // Update distance display
            updateDistanceToHole();

            console.log(`Ball positioned ${currentDistance} ft (${distanceMeters.toFixed(2)}m) from hole`);
        }

        function resetBall() {
            puttResultProcessed = false; // Reset for new putt

            // Reset gate tracking variables for new putt
            if (isGateDrillMode) {
                ballPassedGate = false;
                ballBeforeGate = true;
            }

            updateBallPosition();
        }

        // Ladder Mode Functions
        function setPracticeMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = '#4CAF50';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'block'; // Show score in practice mode
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;
            resetBall();
        }

        function setLadderMode() {
            isLadderMode = true;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = '#fbbf24';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'block';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none'; // Hide score in ladder mode (duplicated in ladder stats)
            document.getElementById('practiceControls').style.display = 'block'; // Keep sliders visible but distance disabled
            document.getElementById('distanceSlider').disabled = true;

            // Reset ladder stats
            ladderLevel = 1;
            ladderMakesAtLevel = 0;
            ladderTotalPutts = 0;
            ladderTotalMakes = 0;
            ladderPersonalBest = LADDER_DISTANCES[0];

            // Set initial distance
            currentDistance = LADDER_DISTANCES[ladderLevel - 1];
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateLadderDisplay();
            resetBall();
            showNotification('üéØ Ladder Mode Started! Make 2 putts at each distance.');
        }

        function updateLadderDisplay() {
            const distance = LADDER_DISTANCES[ladderLevel - 1];
            document.getElementById('ladderLevel').textContent = `${ladderLevel} (${distance} ft)`;
            document.getElementById('ladderMakes').textContent = `${ladderMakesAtLevel}/2`;
            document.getElementById('ladderTotalPutts').textContent = ladderTotalPutts;

            const makePercent = ladderTotalPutts > 0 ? Math.round((ladderTotalMakes / ladderTotalPutts) * 100) : 0;
            document.getElementById('ladderMakePercent').textContent = makePercent + '%';
            document.getElementById('ladderPersonalBest').textContent = ladderPersonalBest + ' ft';
        }

        function ladderPuttMade() {
            ladderTotalPutts++;
            ladderTotalMakes++;
            ladderMakesAtLevel++;

            const currentDist = LADDER_DISTANCES[ladderLevel - 1];

            // Update personal best
            if (currentDist > ladderPersonalBest) {
                ladderPersonalBest = currentDist;
                showNotification(`üèÜ New Personal Best: ${ladderPersonalBest} ft!`);
            }

            if (ladderMakesAtLevel >= 2) {
                // Advance to next level
                if (ladderLevel < LADDER_DISTANCES.length) {
                    ladderLevel++;
                    ladderMakesAtLevel = 0;
                    currentDistance = LADDER_DISTANCES[ladderLevel - 1];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                    showNotification(`‚¨ÜÔ∏è Level Up! Now at ${currentDistance} ft`);
                } else {
                    showNotification('üéâ You completed the ladder! Congratulations!');
                }
            } else {
                showNotification(`‚úÖ Made! ${ladderMakesAtLevel}/2 at ${currentDist} ft`);
            }

            updateLadderDisplay();
        }

        function ladderPuttMissed() {
            ladderTotalPutts++;

            // Drop back one level (but not below level 1)
            if (ladderLevel > 1) {
                ladderLevel--;
                ladderMakesAtLevel = 0;
                currentDistance = LADDER_DISTANCES[ladderLevel - 1];
                document.getElementById('distanceSlider').value = currentDistance;
                document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                showNotification(`‚¨áÔ∏è Miss! Dropped to ${currentDistance} ft`);
            } else {
                // Already at level 1, just reset makes
                ladderMakesAtLevel = 0;
                showNotification(`‚ùå Miss! Starting over at ${LADDER_DISTANCES[0]} ft`);
            }

            updateLadderDisplay();
        }

        // Clock Drill Functions
        function setClockDrillMode() {
            isLadderMode = false;
            isClockDrillMode = true;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = '#3b82f6';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'block';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false; // Allow distance selection

            // Reset clock drill stats
            clockPosition = 0;
            clockMakes = 0;
            clockCurrentStreak = 0;
            clockAttempts = 0;

            // Set distance (can be adjusted)
            currentDistance = clockDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateClockDrillDisplay();
            positionBallForClockDrill();
            showNotification('üïê Clock Drill Started! Complete 12 putts around the hole.');
        }

        function positionBallForClockDrill() {
            // Position ball around the hole in a circle
            // 12 positions like clock: 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 o'clock
            const angleRadians = (clockPosition * 30) * (Math.PI / 180); // 30 degrees per position
            const distanceMeters = currentDistance * 0.3048; // Convert feet to meters

            // Calculate offset from hole (hole is at 0, 0, 0)
            const xOffset = Math.sin(angleRadians) * distanceMeters;
            const zOffset = Math.cos(angleRadians) * distanceMeters;

            // Position ball
            ball.position.set(xOffset, ballRadius, zOffset);
            if (ballBody) {
                ballBody.position.set(xOffset, ballRadius, zOffset);
                ballBody.quaternion.set(0, 0, 0, 1);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }

            console.log(`Clock position ${clockPosition + 1}/12 (${getClockLabel(clockPosition)}): x=${xOffset.toFixed(2)}m, z=${zOffset.toFixed(2)}m`);
        }

        function getClockLabel(position) {
            const labels = ['12', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11'];
            return labels[position] + " o'clock";
        }

        function updateClockDrillDisplay() {
            document.getElementById('clockDistance').textContent = currentDistance + ' ft';
            document.getElementById('clockPosition').textContent = `${getClockLabel(clockPosition)} (${clockPosition + 1}/12)`;
            document.getElementById('clockMakes').textContent = `${clockMakes}/12`;
            document.getElementById('clockStreak').textContent = clockCurrentStreak;

            const successRate = clockAttempts > 0 ? Math.round((clockMakes / clockAttempts) * 100) : 0;
            document.getElementById('clockSuccessRate').textContent = successRate + '%';
        }

        function clockDrillPuttMade() {
            clockMakes++;
            clockCurrentStreak++;
            clockAttempts++;

            if (clockPosition < 11) {
                // Move to next position
                clockPosition++;
                showNotification(`‚úÖ Make! Moving to ${getClockLabel(clockPosition)}`);
                updateClockDrillDisplay();
                positionBallForClockDrill();
            } else {
                // Completed all 12 positions!
                updateClockDrillDisplay();
                showNotification(`üéâ Clock Drill Complete! ${clockMakes}/12 makes (${Math.round((clockMakes/12)*100)}%)`);

                // Reset for another round
                setTimeout(() => {
                    clockPosition = 0;
                    clockMakes = 0;
                    clockCurrentStreak = 0;
                    clockAttempts = 0;
                    updateClockDrillDisplay();
                    positionBallForClockDrill();
                    showNotification('üïê Starting new round!');
                }, 3000);
            }
        }

        function clockDrillPuttMissed() {
            clockCurrentStreak = 0;
            clockAttempts++;

            if (clockPosition < 11) {
                // Move to next position anyway
                clockPosition++;
                showNotification(`‚ùå Miss. Moving to ${getClockLabel(clockPosition)}`);
                updateClockDrillDisplay();
                positionBallForClockDrill();
            } else {
                // Completed all 12 positions
                updateClockDrillDisplay();
                showNotification(`üïê Clock Drill Complete! ${clockMakes}/12 makes (${Math.round((clockMakes/12)*100)}%)`);

                // Reset for another round
                setTimeout(() => {
                    clockPosition = 0;
                    clockMakes = 0;
                    clockCurrentStreak = 0;
                    clockAttempts = 0;
                    updateClockDrillDisplay();
                    positionBallForClockDrill();
                    showNotification('üïê Starting new round!');
                }, 3000);
            }
        }

        // Gate Drill Functions
        function setGateDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = true;
            isCircleDrillMode = false;
            isStarDrillMode = false;
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = '#a855f7';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'block';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;

            // Reset gate drill stats
            gateThroughCount = 0;
            gateAttempts = 0;
            gateMakes = 0;

            // Set distance
            currentDistance = gateDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateGateDrillDisplay();
            createGateMarkers();
            resetBall();
            showNotification('‚ö° Gate Drill Started! Putt through the alignment gates.');
        }

        function createGateMarkers() {
            removeGateMarkers();

            const gateWidthMeters = (gateWidth / 12) * 0.3048; // Convert inches to meters
            const halfWidth = gateWidthMeters / 2;
            const distanceMeters = currentDistance * 0.3048;
            const gatePositionZ = -distanceMeters / 2; // Place gate halfway to hole

            // Create left post
            const postGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 8);
            const postMaterial = new THREE.MeshStandardMaterial({
                color: 0xa855f7,
                emissive: 0xa855f7,
                emissiveIntensity: 0.5
            });

            const leftPost = new THREE.Mesh(postGeometry, postMaterial);
            leftPost.position.set(-halfWidth, 0.1, gatePositionZ);
            scene.add(leftPost);
            gateObjects.push(leftPost);

            // Create right post
            const rightPost = new THREE.Mesh(postGeometry, postMaterial);
            rightPost.position.set(halfWidth, 0.1, gatePositionZ);
            scene.add(rightPost);
            gateObjects.push(rightPost);

            // Create connecting line between posts
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-halfWidth, 0.15, gatePositionZ),
                new THREE.Vector3(halfWidth, 0.15, gatePositionZ)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xa855f7, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            gateObjects.push(line);
        }

        function removeGateMarkers() {
            gateObjects.forEach(obj => scene.remove(obj));
            gateObjects = [];
        }

        function checkGatePostCollisions() {
            // Only check against the actual posts (first 2 objects), not the line
            if (gateObjects.length < 2) return;

            const leftPost = gateObjects[0];
            const rightPost = gateObjects[1];
            const postRadius = 0.01; // Same as post geometry radius
            const ballCollisionRadius = ballRadius + postRadius;

            // Check collision with left post
            const dxLeft = ball.position.x - leftPost.position.x;
            const dzLeft = ball.position.z - leftPost.position.z;
            const distLeft = Math.sqrt(dxLeft * dxLeft + dzLeft * dzLeft);

            if (distLeft < ballCollisionRadius) {
                // Collision with left post - bounce off
                const normal = new THREE.Vector3(dxLeft, 0, dzLeft).normalize();
                ballVelocity.reflect(normal).multiplyScalar(0.8); // Some energy loss

                // Push ball away from post to prevent sticking
                ball.position.x = leftPost.position.x + normal.x * ballCollisionRadius;
                ball.position.z = leftPost.position.z + normal.z * ballCollisionRadius;

                // Mark gate as failed - ball hit the post
                ballPassedGate = false;
                ballBeforeGate = false; // Stop checking
            }

            // Check collision with right post
            const dxRight = ball.position.x - rightPost.position.x;
            const dzRight = ball.position.z - rightPost.position.z;
            const distRight = Math.sqrt(dxRight * dxRight + dzRight * dzRight);

            if (distRight < ballCollisionRadius) {
                // Collision with right post - bounce off
                const normal = new THREE.Vector3(dxRight, 0, dzRight).normalize();
                ballVelocity.reflect(normal).multiplyScalar(0.8); // Some energy loss

                // Push ball away from post to prevent sticking
                ball.position.x = rightPost.position.x + normal.x * ballCollisionRadius;
                ball.position.z = rightPost.position.z + normal.z * ballCollisionRadius;

                // Mark gate as failed - ball hit the post
                ballPassedGate = false;
                ballBeforeGate = false; // Stop checking
            }
        }

        function updateGateDrillDisplay() {
            document.getElementById('gateDistance').textContent = currentDistance + ' ft';
            document.getElementById('gateWidth').textContent = gateWidth + ' in';
            document.getElementById('gateThroughCount').textContent = gateThroughCount + '/' + gateAttempts;
            document.getElementById('gateMakes').textContent = gateMakes + '/' + gateAttempts;

            const accuracy = gateAttempts > 0 ? Math.round((gateThroughCount / gateAttempts) * 100) : 0;
            document.getElementById('gateAccuracy').textContent = accuracy + '%';
        }

        function checkBallThroughGate() {
            if (!isGateDrillMode) return true; // Not in gate mode, always return true

            const gateWidthMeters = (gateWidth / 12) * 0.3048;
            const halfWidth = gateWidthMeters / 2;
            const distanceMeters = currentDistance * 0.3048;
            const gatePositionZ = -distanceMeters / 2;

            const ballZ = ball.position.z;
            const ballX = ball.position.x;

            // Check if ball has crossed the gate plane
            if (ballBeforeGate && ballZ <= gatePositionZ) {
                // Ball just crossed the gate plane
                // Check if ball was within gate width when it crossed
                if (Math.abs(ballX) <= halfWidth) {
                    ballPassedGate = true; // Successfully passed through gate!
                } else {
                    ballPassedGate = false; // Went around/outside the gate posts
                }
                ballBeforeGate = false; // Ball has now crossed
            }

            return ballPassedGate;
        }

        function gateDrillPuttMade() {
            gateAttempts++;
            gateMakes++;

            // Check if ball went through gate (simple check based on final position)
            const throughGate = checkBallThroughGate();
            if (throughGate) {
                gateThroughCount++;
                showNotification('‚ö° Made through gate! Great accuracy!');
            } else {
                showNotification('‚úÖ Made putt (missed gate)');
            }

            updateGateDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        function gateDrillPuttMissed() {
            gateAttempts++;

            const throughGate = checkBallThroughGate();
            if (throughGate) {
                gateThroughCount++;
                showNotification('‚ö° Good line (through gate, missed hole)');
            } else {
                showNotification('‚ùå Missed (off line)');
            }

            updateGateDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        // Circle Drill Functions
        function setCircleDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = true;
            isStarDrillMode = false;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = '#ec4899';
            document.getElementById('starDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'block';
            document.getElementById('starDrillStats').style.display = 'none';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = true; // Distance controlled by drill

            // Reset circle drill stats
            circleDistanceIndex = 0;
            circleAttemptsAtDistance = 0;
            circleMakesAtDistance = 0;
            circleTotalAttempts = 0;
            circleTotalMakes = 0;

            // Set initial distance
            currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateCircleDrillDisplay();
            resetBall();
            showNotification('‚≠ï Circle Drill Started! 10 putts at each distance: 3ft, 6ft, 9ft, 12ft');
        }

        function updateCircleDrillDisplay() {
            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            document.getElementById('circleCurrentDistance').textContent = currentDist + ' ft';
            document.getElementById('circleAttempts').textContent = circleAttemptsAtDistance + '/10';
            document.getElementById('circleMakes').textContent = circleMakesAtDistance + '/10';
            document.getElementById('circleProgress').textContent = (circleDistanceIndex + 1) + '/4 distances';

            const overallSuccess = circleTotalAttempts > 0 ? Math.round((circleTotalMakes / circleTotalAttempts) * 100) : 0;
            document.getElementById('circleSuccess').textContent = overallSuccess + '%';
        }

        function circleDrillPuttMade() {
            circleAttemptsAtDistance++;
            circleMakesAtDistance++;
            circleTotalAttempts++;
            circleTotalMakes++;

            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            showNotification(`‚úÖ Made! ${circleMakesAtDistance}/10 at ${currentDist} ft`);

            if (circleAttemptsAtDistance >= 10) {
                // Move to next distance
                if (circleDistanceIndex < CIRCLE_DISTANCES.length - 1) {
                    circleDistanceIndex++;
                    circleAttemptsAtDistance = 0;
                    circleMakesAtDistance = 0;

                    currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';

                    setTimeout(() => {
                        showNotification(`‚≠ï Moving to ${currentDistance} ft`);
                    }, 2000);
                } else {
                    // Completed all distances
                    const totalSuccess = Math.round((circleTotalMakes / circleTotalAttempts) * 100);
                    setTimeout(() => {
                        showNotification(`üéâ Circle Drill Complete! ${circleTotalMakes}/40 makes (${totalSuccess}%)`);
                    }, 2000);

                    // Reset for another round
                    setTimeout(() => {
                        circleDistanceIndex = 0;
                        circleAttemptsAtDistance = 0;
                        circleMakesAtDistance = 0;
                        circleTotalAttempts = 0;
                        circleTotalMakes = 0;
                        currentDistance = CIRCLE_DISTANCES[0];
                        document.getElementById('distanceSlider').value = currentDistance;
                        document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                        updateCircleDrillDisplay();
                        showNotification('‚≠ï Starting new round!');
                    }, 5000);
                }
            }

            updateCircleDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        function circleDrillPuttMissed() {
            circleAttemptsAtDistance++;
            circleTotalAttempts++;

            const currentDist = CIRCLE_DISTANCES[circleDistanceIndex];
            showNotification(`‚ùå Miss. ${circleMakesAtDistance}/10 at ${currentDist} ft`);

            if (circleAttemptsAtDistance >= 10) {
                // Move to next distance
                if (circleDistanceIndex < CIRCLE_DISTANCES.length - 1) {
                    circleDistanceIndex++;
                    circleAttemptsAtDistance = 0;
                    circleMakesAtDistance = 0;

                    currentDistance = CIRCLE_DISTANCES[circleDistanceIndex];
                    document.getElementById('distanceSlider').value = currentDistance;
                    document.getElementById('distanceValue').textContent = currentDistance + ' ft';

                    setTimeout(() => {
                        showNotification(`‚≠ï Moving to ${currentDistance} ft`);
                    }, 2000);
                } else {
                    // Completed all distances
                    const totalSuccess = Math.round((circleTotalMakes / circleTotalAttempts) * 100);
                    setTimeout(() => {
                        showNotification(`üéâ Circle Drill Complete! ${circleTotalMakes}/40 makes (${totalSuccess}%)`);
                    }, 2000);

                    // Reset for another round
                    setTimeout(() => {
                        circleDistanceIndex = 0;
                        circleAttemptsAtDistance = 0;
                        circleMakesAtDistance = 0;
                        circleTotalAttempts = 0;
                        circleTotalMakes = 0;
                        currentDistance = CIRCLE_DISTANCES[0];
                        document.getElementById('distanceSlider').value = currentDistance;
                        document.getElementById('distanceValue').textContent = currentDistance + ' ft';
                        updateCircleDrillDisplay();
                        showNotification('‚≠ï Starting new round!');
                    }, 5000);
                }
            }

            updateCircleDrillDisplay();
            setTimeout(() => {
                puttResultProcessed = false;
                resetBall();
            }, 1500);
        }

        // Star Drill Functions
        function setStarDrillMode() {
            isLadderMode = false;
            isClockDrillMode = false;
            isGateDrillMode = false;
            isCircleDrillMode = false;
            isStarDrillMode = true;
            removeGateMarkers();
            document.getElementById('practiceModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('ladderModeBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('clockDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('gateDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('circleDrillBtn').style.background = 'rgba(76, 175, 80, 0.3)';
            document.getElementById('starDrillBtn').style.background = '#f97316';
            document.getElementById('ladderStats').style.display = 'none';
            document.getElementById('clockDrillStats').style.display = 'none';
            document.getElementById('gateDrillStats').style.display = 'none';
            document.getElementById('circleDrillStats').style.display = 'none';
            document.getElementById('starDrillStats').style.display = 'block';
            document.getElementById('scoreInfo').style.display = 'none';
            document.getElementById('practiceControls').style.display = 'block';
            document.getElementById('distanceSlider').disabled = false;

            // Reset star drill stats
            starPosition = 0;
            starMakes = 0;
            starCurrentStreak = 0;
            starAttempts = 0;

            // Set distance
            currentDistance = starDistance;
            document.getElementById('distanceSlider').value = currentDistance;
            document.getElementById('distanceValue').textContent = currentDistance + ' ft';

            updateStarDrillDisplay();
            positionBallForStarDrill();
            showNotification('‚≠ê Star Drill Started! 5 putts from different angles.');
        }

        function positionBallForStarDrill() {
            // Position ball at 5 positions like a star (72 degrees apart)
            const angleRadians = (starPosition * 72) * (Math.PI / 180); // 72 degrees per position
            const distanceMeters = currentDistance * 0.3048; // Convert feet to meters

            // Calculate offset from hole (hole is at 0, 0, 0)
            const xOffset = Math.sin(angleRadians) * distanceMeters;
            const zOffset = Math.cos(angleRadians) * distanceMeters;

            // Position ball
            ball.position.set(xOffset, ballRadius, zOffset);
            if (ballBody) {
                ballBody.position.set(xOffset, ballRadius, zOffset);
                ballBody.quaternion.set(0, 0, 0, 1);
                ballBody.velocity.set(0, 0, 0);
                ballBody.angularVelocity.set(0, 0, 0);
            }
        }

        function updateStarDrillDisplay() {
            document.getElementById('starDistance').textContent = currentDistance + ' ft';
            document.getElementById('starPosition').textContent = `Point ${starPosition + 1} (${starPosition + 1}/5)`;
            document.getElementById('starMakes').textContent = starMakes + '/5';
            document.getElementById('starStreak').textContent = starCurrentStreak;

            const successRate = starAttempts > 0 ? Math.round((starMakes / starAttempts) * 100) : 0;
            document.getElementById('starSuccessRate').textContent = successRate + '%';
        }

        function starDrillPuttMade() {
            starAttempts++;
            starMakes++;
            starCurrentStreak++;

            showNotification(`‚≠ê Made! Streak: ${starCurrentStreak}`);

            // Move to next position
            starPosition++;
            if (starPosition >= 5) {
                // Completed all 5 positions
                updateStarDrillDisplay();
                showNotification(`üéâ Star Drill Complete! ${starMakes}/5 makes`);

                // Reset for another round
                setTimeout(() => {
                    starPosition = 0;
                    starMakes = 0;
                    starCurrentStreak = 0;
                    starAttempts = 0;
                    updateStarDrillDisplay();
                    positionBallForStarDrill();
                    showNotification('‚≠ê Starting new round!');
                }, 3000);
            } else {
                updateStarDrillDisplay();
                positionBallForStarDrill();
            }
        }

        function starDrillPuttMissed() {
            starAttempts++;
            starCurrentStreak = 0; // Reset streak on miss

            showNotification('‚ùå Miss. Streak reset.');

            // Move to next position
            starPosition++;
            if (starPosition >= 5) {
                // Completed all 5 positions
                updateStarDrillDisplay();
                showNotification(`‚≠ê Star Drill Complete! ${starMakes}/5 makes`);

                // Reset for another round
                setTimeout(() => {
                    starPosition = 0;
                    starMakes = 0;
                    starCurrentStreak = 0;
                    starAttempts = 0;
                    updateStarDrillDisplay();
                    positionBallForStarDrill();
                    showNotification('‚≠ê Starting new round!');
                }, 3000);
            } else {
                updateStarDrillDisplay();
                positionBallForStarDrill();
            }
        }

        function toggleTopoLines() {
            showTopoLines = !showTopoLines;

            if (showTopoLines) {
                createTopoLines();
                console.log('Topographical lines enabled');
            } else {
                if (topoLines) {
                    scene.remove(topoLines);
                    topoLines = null;
                }
                console.log('Topographical lines disabled');
            }
        }

        function togglePracticeSettings() {
            const content = document.getElementById('practiceSettingsContent');
            const toggle = document.getElementById('practiceSettingsToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const arrow = document.getElementById(sectionId + 'Arrow');

            if (section.style.display === 'none') {
                section.style.display = 'flex';
                arrow.textContent = '‚ñº';
            } else {
                section.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        function createTopoLines() {
            // Remove existing lines if any
            if (topoLines) {
                scene.remove(topoLines);
            }

            const group = new THREE.Group();
            const greenRadius = 15;

            // Always show base grid
            const gridHelper = new THREE.GridHelper(greenRadius * 2, 20, 0x888888, 0x444444);
            gridHelper.position.y = 0.02;
            group.add(gridHelper);

            // Create topographical lines based on break and elevation
            // Lines will be perpendicular to the slope direction
            if (currentBreak !== 0 || currentElevation !== 0) {
                // Calculate slope direction
                const breakAngle = currentBreak * 0.5 * Math.PI / 180;
                const elevationAngle = currentElevation * 0.5 * Math.PI / 180;

                // For break: lines run parallel to slope (left-right for break)
                // For elevation: lines run perpendicular to hole direction (across the green)

                const lineCount = 20;
                const spacing = greenRadius * 2 / lineCount;

                for (let i = -lineCount/2; i <= lineCount/2; i++) {
                    const points = [];

                    if (Math.abs(currentBreak) > Math.abs(currentElevation)) {
                        // Break dominant - draw lines parallel to X axis (showing left-right slope)
                        const z = i * spacing;
                        points.push(new THREE.Vector3(-greenRadius, 0.02, z));
                        points.push(new THREE.Vector3(greenRadius, 0.02, z));
                    } else {
                        // Elevation dominant - draw lines parallel to Z axis (showing uphill/downhill)
                        const x = i * spacing;
                        points.push(new THREE.Vector3(x, 0.02, -greenRadius));
                        points.push(new THREE.Vector3(x, 0.02, greenRadius));
                    }

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);

                    // Color based on intensity
                    let color = 0xFFFFFF;
                    let opacity = 0.3;

                    // Highlight certain lines to show slope intensity
                    if (i % 5 === 0) {
                        opacity = 0.6;
                        if (currentBreak > 0) color = 0xFF8800; // Orange for right break
                        else if (currentBreak < 0) color = 0x0088FF; // Blue for left break
                        else if (currentElevation > 0) color = 0xFF4444; // Red for uphill
                        else if (currentElevation < 0) color = 0x44FF44; // Green for downhill
                    }

                    const material = new THREE.LineBasicMaterial({
                        color: color,
                        opacity: opacity,
                        transparent: true
                    });

                    const line = new THREE.Line(geometry, material);
                    group.add(line);
                }
            }

            topoLines = group;
            scene.add(topoLines);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'y' || e.key === 'Y') {
                toggleTopoLines();
            }
        });

        function hitBall(speed, backspin, sidespin, hla = 0) {
            if (isMoving) return; // Don't hit while ball is moving

            puttCount++;
            document.getElementById('puttCount').textContent = puttCount;

            // Convert mph to m/s
            const speedMS = speed * 0.44704;

            // Set ball velocity with horizontal launch angle
            // HLA positive = right, negative = left
            const hlaRad = hla * Math.PI / 180;

            // Base direction toward hole
            const directionToHole = new THREE.Vector3(
                -ball.position.x,
                0,
                -ball.position.z
            ).normalize();

            // Apply horizontal launch angle
            // X component: lateral (left/right), Z component: forward (toward hole)
            // HLA: negative = left, positive = right (flipped sign to match convention)
            ballVelocity.set(
                -speedMS * Math.sin(hlaRad),  // Lateral velocity (negative HLA = left, positive HLA = right)
                0,
                speedMS * Math.cos(hlaRad) * (directionToHole.z < 0 ? -1 : 1)  // Forward velocity toward hole
            );

            // Set spin (convert RPM to rad/s)
            ballSpin.set(
                backspin * Math.PI / 30,  // backspin
                0,
                -sidespin * Math.PI / 30  // sidespin
            );

            // Reset gate tracking for new shot
            if (isGateDrillMode) {
                ballPassedGate = false;
                ballBeforeGate = true;
            }

            isMoving = true;
            puttResultProcessed = false; // Reset for new putt

            // Update display
            document.getElementById('ballSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('hla').textContent = hla.toFixed(1) + '¬∞';
            document.getElementById('vla').textContent = '0.0¬∞'; // VLA is always 0 for putting
        }

        function testShot() {
            // Get debug values from inputs
            const speed = parseFloat(document.getElementById('debugSpeed').value) || 5.0;
            const hla = parseFloat(document.getElementById('debugHLA').value) || 0;
            const vla = parseFloat(document.getElementById('debugVLA').value) || 0;

            console.log(`üõ†Ô∏è Debug Test Shot: Speed=${speed} mph, HLA=${hla}¬∞, VLA=${vla}¬∞`);

            // Create shot data object
            const shotData = {
                ball_speed: speed,
                hla: hla,
                vla: vla,
                back_spin: 0,
                side_spin: 0
            };

            // Trigger the shot using the same logic as Electron shots
            const speedMS = speed * 0.44704; // mph to m/s
            const hlaRad = hla * Math.PI / 180;
            const vlaRad = vla * Math.PI / 180;

            // Calculate direction to hole (for putting, usually toward center)
            const directionToHole = new THREE.Vector3(0, 0, 0).sub(ball.position).normalize();

            // Calculate velocity components
            ballVelocity.set(
                speedMS * Math.sin(hlaRad),  // Left/Right
                speedMS * Math.sin(vlaRad),  // Up/Down (usually 0 for putting)
                speedMS * Math.cos(hlaRad) * (directionToHole.z < 0 ? -1 : 1)  // Forward
            );

            ballSpin.set(0, 0, 0); // No spin for debug shots

            // Reset gate tracking for new shot
            if (isGateDrillMode) {
                ballPassedGate = false;
                ballBeforeGate = true;
            }

            isMoving = true;
            puttResultProcessed = false;

            // Update display
            document.getElementById('ballSpeed').textContent = speed.toFixed(1) + ' mph';
            document.getElementById('hla').textContent = hla.toFixed(1) + '¬∞';
            document.getElementById('vla').textContent = vla.toFixed(1) + '¬∞';

            console.log('‚úÖ Test shot triggered');
        }

        function setupElectronIPC() {
            // Load players from localStorage
            const playersData = localStorage.getItem('puttingPlayers');
            window.puttingPlayers = playersData ? JSON.parse(playersData) : [{ name: 'Player 1', color: '#ff6b6b' }];
            window.currentPlayerIndex = parseInt(localStorage.getItem('puttingCurrentPlayer') || '0');

            updatePlayerDisplay();

            // Hide Next Player button if only 1 player
            if (window.puttingPlayers.length === 1) {
                document.getElementById('nextPlayerBtn').style.display = 'none';
            }

            // Listen for shot data
            window.electronAPI.onShotData((shotData) => {
                console.log('üì° Putt received:', shotData);

                // Only accept putter shots
                if (shotData.club && shotData.club !== 'PT') {
                    console.log('‚ö† Not a putter shot, ignoring');
                    return;
                }

                const speed = shotData.ball_speed || 0;
                const backspin = shotData.back_spin || 0;
                const sidespin = shotData.side_spin || 0;
                const hla = shotData.hla || 0;

                if (speed > 0) {
                    hitBall(speed, backspin, sidespin, hla);
                }
            });
        }

        function updatePlayerDisplay() {
            if (!window.puttingPlayers || window.puttingPlayers.length === 0) return;

            const player = window.puttingPlayers[window.currentPlayerIndex];
            const nameDiv = document.getElementById('currentPlayerName');
            if (nameDiv) {
                nameDiv.textContent = player.name;
                nameDiv.style.color = player.color;
            }
        }

        function nextPlayer() {
            if (!window.puttingPlayers || window.puttingPlayers.length <= 1) return;

            window.currentPlayerIndex = (window.currentPlayerIndex + 1) % window.puttingPlayers.length;
            localStorage.setItem('puttingCurrentPlayer', window.currentPlayerIndex.toString());

            updatePlayerDisplay();
            puttCount = 0;
            document.getElementById('puttCount').textContent = puttCount;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Reapply visual offset after resize
            if (visualOffsetX !== 0 || visualOffsetY !== 0) {
                camera.setViewOffset(window.innerWidth, window.innerHeight, visualOffsetX, visualOffsetY, window.innerWidth, window.innerHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            updatePhysics(deltaTime);

            // Update camera for follow and behind modes
            if (currentView === 'follow' || currentView === 'behind') {
                updateCameraPosition();
            }

            // Animate detail grass (subtle wind)
            if (window.grassMeshes) {
                const timeInSeconds = currentTime / 1000;
                window.grassMeshes.forEach(material => {
                    material.uniforms.time.value = timeInSeconds;
                });
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
